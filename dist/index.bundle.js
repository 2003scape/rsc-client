(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const mudclient = require('./src/mudclient');

if (typeof window === 'undefined') {
    throw new Error('rsc-client needs to run in a browser');
}

(async () => {
    const mcCanvas = document.createElement('canvas');
    const args = window.location.hash.slice(1).split(',');
    const mc = new mudclient(mcCanvas);

    window.mcOptions = mc.options;

    mc.options.middleClickCamera = true;
    mc.options.mouseWheel = true;
    mc.options.resetCompass = true;
    mc.options.zoomCamera = true;
    mc.options.accountManagement = true;

    mc.members = args[0] === 'members';
    mc.server = args[1] ? args[1] : '127.0.0.1';
    mc.port = args[2] && !isNaN(+args[2]) ? +args[2] : 43595;

    mc.threadSleep = 10;

    document.body.appendChild(mcCanvas);

    await mc.startApplication(512, 346, 'Runescape by Andrew Gower', false);
})();

},{"./src/mudclient":53}],2:[function(require,module,exports){
/** Burrows-Wheeler transform, computed with the Induced Sorting Suffix Array
 *  construction mechanism (sais).  Code is a port of:
 *    https://sites.google.com/site/yuta256/sais
 *  which is:
 *    Copyright (c) 2008-2010 Yuta Mori All Rights Reserved.
 *  and licensed under an MIT/X11 license.  I generally looked at both
 *  the C and the Java implementations to guide my work.
 *
 * This JavaScript port is:
 *    Copyright (c) 2013 C. Scott Ananian
 * and licensed under GPLv2; see the README at the top level of this package.
 */
const freeze = require('./freeze');
const Util = require('./Util');

var ASSERT = console.assert.bind(console);

// we're dispensing with the "arbitrary alphabet" stuff of the source
// and just using Uint8Arrays.

/** Find the start or end of each bucket. */
var getCounts = function(T, C, n, k) {
    var i;
    for (i = 0; i < k; i++) { C[i] = 0; }
    for (i = 0; i < n; i++) { C[T[i]]++; }
};
var getBuckets = function(C, B, k, end) {
    var i, sum = 0;
    if (end) {
        for (i = 0; i < k; i++) { sum += C[i]; B[i] = sum; }
    } else {
        for (i = 0; i < k; i++) { sum += C[i]; B[i] = sum - C[i]; }
    }
};

/** Sort all type LMS suffixes */
var LMSsort = function(T, SA, C, B, n, k) {
    var b, i, j;
    var c0, c1;
    /* compute SAl */
    if (C === B) { getCounts(T, C, n, k); }
    getBuckets(C, B, k, false); /* find starts of buckets */
    j = n - 1;
    b = B[c1 = T[j]];
    j--;
    SA[b++] = (T[j] < c1) ? ~j : j;
    for (i = 0; i < n; i++) {
        if ((j = SA[i]) > 0) {
            ASSERT(T[j] >= T[j+1]);
            if ((c0 = T[j]) !== c1) { B[c1] = b; b = B[c1 = c0]; }
            ASSERT(i < b);
            j--;
            SA[b++] = (T[j] < c1) ? ~j : j;
            SA[i] = 0;
        } else if (j < 0) {
            SA[i] = ~j;
        }
    }
    /* compute SAs */
    if (C === B) { getCounts(T, C, n, k); }
    getBuckets(C, B, k, 1); /* find ends of buckets */
    for (i = n-1, b = B[c1 = 0]; i >= 0; i--) {
        if ((j = SA[i]) > 0) {
            ASSERT(T[j] <= T[j+1]);
            if ((c0 = T[j]) !== c1) { B[c1] = b; b = B[c1 = c0]; }
            ASSERT(b <= i);
            j--;
            SA[--b] = (T[j] > c1) ? ~(j+1) : j;
            SA[i] = 0;
        }
    }
};

var LMSpostproc = function(T, SA, n, m) {
    var i, j, p, q, plen, qlen, name;
    var c0, c1;
    var diff;

    /* compact all the sorted substrings into the first m items of SA
        * 2*m must not be larger than n (provable) */
    ASSERT(n > 0);
    for (i = 0; (p = SA[i]) < 0; i++) { SA[i] = ~p; ASSERT((i+1) < n); }
    if (i < m) {
        for (j = i, i++; ; i++) {
            ASSERT(i < n);
            if ((p = SA[i]) < 0) {
                SA[j++] = ~p; SA[i] = 0;
                if (j === m) { break; }
            }
        }
    }

    /* store the length of all substrings */
    c0 = T[i = j = n - 1];
    do { c1 = c0; } while ( ((--i) >= 0 ) && ((c0=T[i]) >= c1) );
    for (; i >= 0; ) {
        do { c1 = c0; } while ( ((--i) >= 0 ) && ((c0=T[i]) <= c1) );
        if (i >= 0) {
            SA[m + ((i + 1) >>> 1)] = j - i; j = i + 1;
            do { c1 = c0; } while ( ((--i) >= 0 ) && ((c0=T[i]) >= c1) );
        }
    }

    /* find the lexicographic names of all substrings */
    for (i = 0, name = 0, q = n, qlen = 0; i < m; i++) {
        p = SA[i]; plen = SA[m + (p >>> 1)]; diff = true;
        if ((plen === qlen) && ((q + plen) < n)) {
            for (j = 0; (j < plen) && (T[p + j] === T[q + j]); ) { j++; }
            if (j === plen) { diff = false; }
        }
        if (diff) { name++; q = p; qlen = plen; }
        SA[m + (p >>> 1)] = name;
    }

    return name;
};

/* compute SA and BWT */
var induceSA = function(T, SA, C, B, n, k) {
    var b, i, j;
    var c0, c1;
    /* compute SAl */
    if (C === B) { getCounts(T, C, n, k); }
    getBuckets(C, B, k, false); /* find starts of buckets */
    j = n - 1;
    b = B[c1 = T[j]];
    SA[b++] = ((j > 0) && (T[j-1] < c1)) ? ~j : j;
    for (i = 0; i < n; i++) {
        j = SA[i]; SA[i] = ~j;
        if (j > 0) {
            j--;
            ASSERT( T[j] >= T[j + 1] );
            if ((c0 = T[j]) !== c1) { B[c1]  = b; b = B[c1=c0]; }
            ASSERT( i < b );
            SA[b++] = ((j > 0) && (T[j-1] < c1)) ? ~j : j;
        }
    }
    /* compute SAs */
    if (C === B) { getCounts(T, C, n, k); }
    getBuckets(C, B, k, true); /* find ends of buckets */
    for (i = n-1, b = B[c1 = 0]; i >= 0; i--) {
        if ((j = SA[i]) > 0) {
            j--;
            ASSERT( T[j] <= T[j + 1] );
            if ((c0 = T[j]) !== c1) { B[c1] = b; b = B[c1 = c0]; }
            ASSERT( b <= i );
            SA[--b] = ((j === 0) || (T[j - 1] > c1)) ? ~j : j;
        } else {
            SA[i] = ~j;
        }
    }
};

var computeBWT = function(T, SA, C, B, n, k) {
    var b, i, j, pidx = -1;
    var c0, c1;
    /* compute SAl */
    if (C === B) { getCounts(T, C, n, k); }
    getBuckets(C, B, k, false); /* find starts of buckets */
    j = n - 1;
    b = B[c1 = T[j]];
    SA[b++] = ((j > 0) && (T[j - 1] < c1)) ? ~j : j;
    for (i = 0; i < n; i++) {
        if ((j=SA[i]) > 0) {
            j--;
            ASSERT( T[j] >= T[j+1] );
            SA[i] = ~(c0 = T[j]);
            if (c0 !== c1) { B[c1] = b; b = B[c1 = c0]; }
            ASSERT( i < b );
            SA[b++] = ((j > 0) && (T[j - 1] < c1)) ? ~j : j;
        } else if (j !== 0) {
            SA[i] = ~j;
        }
    }
    /* compute SAs */
    if (C === B) { getCounts(T, C, n, k); }
    getBuckets(C, B, k, true); /* find ends of buckets */
    for (i = n-1, b = B[c1 = 0]; i >= 0; i--) {
        if ((j = SA[i]) > 0) {
            j--;
            ASSERT( T[j] <= T[j+1] );
            SA[i] = c0 = T[j];
            if (c0 !== c1) { B[c1] = b; b = B[c1 = c0]; }
            ASSERT( b <= i );
            SA[--b] = ((j > 0) && (T[j-1] > c1)) ? (~T[j-1]) : j;
        } else if (j !== 0) {
            SA[i] = ~j;
        } else {
            pidx = i;
        }
    }
    return pidx;
};

/* find the suffix array SA of T[0..n-1] in {0..k-1}^n
    use a working space (excluding T and SA) of at most 2n+O(1) for a
    constant alphabet */
var SA_IS = function(T, SA, fs, n, k, isbwt) {
    var C, B, RA;
    var i, j, b, c, m, p, q, name, pidx = 0, newfs;
    var c0, c1;
    var flags = 0;

    // allocate temporary storage [CSA]
    if (k <= 256) {
        C = Util.makeS32Buffer(k);
        if (k <= fs) { B = SA.subarray(n + fs - k); flags = 1; }
        else { B = Util.makeS32Buffer(k); flags = 3; }
    } else if (k <= fs) {
        C = SA.subarray(n + fs - k);
        if (k <= (fs - k)) { B = SA.subarray(n + fs - k * 2); flags = 0; }
        else if (k <= 1024) { B = Util.makeS32Buffer(k); flags = 2; }
        else { B = C; flags = 8; }
    } else {
        C = B = Util.makeS32Buffer(k);
        flags = 4 | 8;
    }

    /* stage 1: reduce the problem by at least 1/2
        sort all the LMS-substrings */
    getCounts(T, C, n, k);
    getBuckets(C, B, k, true); /* find ends of buckets */
    for (i = 0; i < n; i++) { SA[i] = 0; }
    b = -1; i = n - 1; j = n; m = 0; c0 = T[n - 1];
    do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) >= c1));
    for (; i >= 0 ;) {
        do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) <= c1));
        if ( i >= 0 ) {
            if ( b >= 0 ) { SA[b] = j; }
            b = --B[c1];
            j = i;
            ++m;
            do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) >= c1));
        }
    }

    if (m > 1) {
        LMSsort(T, SA, C, B, n, k);
        name = LMSpostproc(T, SA, n, m);
    } else if (m === 1) {
        SA[b] = j + 1;
        name = 1;
    } else {
        name = 0;
    }

    /* stage 2: solve the reduced problem
        recurse if names are not yet unique */
    if(name < m) {
        if((flags & 4) !== 0) { C = null; B = null; }
        if((flags & 2) !== 0) { B = null; }
        newfs = (n + fs) - (m * 2);
        if((flags & (1 | 4 | 8)) === 0) {
            if((k + name) <= newfs) { newfs -= k; }
            else { flags |= 8; }
        }
        ASSERT( (n >>> 1) <= (newfs + m) );
        for (i = m + (n >>> 1) - 1, j = m * 2 + newfs - 1; m <= i; i--) {
            if(SA[i] !== 0) { SA[j--] = SA[i] - 1; }
        }
        RA = SA.subarray(m + newfs);
        SA_IS(RA, SA, newfs, m, name, false);
        RA = null;

        i = n - 1; j = m * 2 - 1; c0 = T[n - 1];
        do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) >= c1));
        for (; i >= 0 ;) {
            do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) <= c1));
            if ( i >= 0 ) {
                SA[j--] = i + 1;
                do { c1 = c0; } while ((--i >= 0) && ((c0 = T[i]) >= c1));
            }
        }

        for (i = 0; i < m; i++) { SA[i] = SA[m + SA[i]]; }
        if((flags & 4) !== 0) { C = B = Util.makeS32Buffer(k); }
        if((flags & 2) !== 0) { B = Util.makeS32Buffer(k); }
    }

    /* stage 3: induce the result for the original problem */
    if((flags & 8) !== 0) { getCounts(T, C, n, k); }
    /* put all left-most S characters into their buckets */
    if (m > 1) {
        getBuckets(C, B, k, true); /* find ends of buckets */
        i = m - 1; j = n; p = SA[m - 1]; c1 = T[p];
        do {
            q = B[c0 = c1];
            while (q < j) { SA[--j] = 0; }
            do {
                SA[--j] = p;
                if(--i < 0) { break; }
                p = SA[i];
            } while((c1 = T[p]) === c0);
        } while (i >= 0 );
        while ( j > 0 ) { SA[--j] = 0; }
    }
    if (!isbwt) { induceSA(T, SA, C, B, n, k); }
    else { pidx = computeBWT(T, SA, C, B, n, k); }
    C = null; B = null;
    return pidx;
};

var BWT = Object.create(null);
/** SA should be a Int32Array (signed!); T can be any typed array.
 *  alphabetSize is optional if T is an Uint8Array or Uint16Array. */
BWT.suffixsort = function(T, SA, n, alphabetSize) {
    ASSERT( T && SA && T.length >= n && SA.length >= n );
    if (n <= 1) {
        if (n === 1) { SA[0] = 0; }
        return 0;
    }
    if (!alphabetSize) {
        if (T.BYTES_PER_ELEMENT === 1) { alphabetSize = 256; }
        else if (T.BYTES_PER_ELEMENT === 2) { alphabetSize = 65536; }
        else throw new Error('Need to specify alphabetSize');
    }
    ASSERT( alphabetSize > 0 );
    if (T.BYTES_PER_ELEMENT) {
        ASSERT( alphabetSize <= (1 << (T.BYTES_PER_ELEMENT*8) ) );
    }
    return SA_IS(T, SA, 0, n, alphabetSize, false);
};
/** Burrows-Wheeler Transform.
    A should be Int32Array (signed!); T can be any typed array.
    U is the same type as T (it is used for output).
    alphabetSize is optional if T is an Uint8Array or Uint16Array.
    ASSUMES STRING IS TERMINATED WITH AN EOF CHARACTER.
*/
BWT.bwtransform = function(T, U, A, n, alphabetSize) {
    var i, pidx;
    ASSERT( T && U && A );
    ASSERT( T.length >= n && U.length >= n && A.length >= n );
    if (n <= 1) {
        if (n === 1) { U[0] = T[0]; }
        return n;
    }
    if (!alphabetSize) {
        if (T.BYTES_PER_ELEMENT === 1) { alphabetSize = 256; }
        else if (T.BYTES_PER_ELEMENT === 2) { alphabetSize = 65536; }
        else throw new Error('Need to specify alphabetSize');
    }
    ASSERT( alphabetSize > 0 );
    if (T.BYTES_PER_ELEMENT) {
        ASSERT( alphabetSize <= (1 << (T.BYTES_PER_ELEMENT*8) ) );
    }
    pidx = SA_IS(T, A, 0, n, alphabetSize, true);
    U[0] = T[n - 1];
    for (i = 0; i < pidx ; i++) { U[i + 1] = A[i]; }
    for (i += 1; i < n; i++) { U[i] = A[i]; }
    return pidx + 1;
};
/** Reverses transform above. (ASSUMED STRING IS TERMINATED WITH EOF.) */
BWT.unbwtransform = function(T, U, LF, n, pidx) {
    var C = Util.makeU32Buffer(256);
    var i, t;
    for (i=0; i<256; i++) { C[i] = 0; }
    for (i=0; i<n; i++) { LF[i] = C[T[i]]++; }
    for (i=0, t=0; i<256; i++) { t += C[i]; C[i] = t - C[i]; }
    for (i=n-1, t=0; i>=0; i--) {
        t = LF[t] + C[U[i]=T[t]];
        t += (t<pidx) ? 1 : 0;
    }
    C = null;
};

/** Burrows-Wheeler Transform.
    A should be Int32Array (signed!); T can be any typed array.
    U is the same type as T (it is used for output).
    alphabetSize is optional if T is an Uint8Array or Uint16Array.
    ASSUMES STRING IS CYCLIC.
    (XXX: this is twice as inefficient as I'd like! [CSA])
*/
BWT.bwtransform2 = function(T, U, n, alphabetSize) {
    var i, j, pidx = 0;
    ASSERT( T && U );
    ASSERT( T.length >= n && U.length >= n );
    if (n <= 1) {
        if (n === 1) { U[0] = T[0]; }
        return 0;
    }
    if (!alphabetSize) {
        if (T.BYTES_PER_ELEMENT === 1) { alphabetSize = 256; }
        else if (T.BYTES_PER_ELEMENT === 2) { alphabetSize = 65536; }
        else throw new Error('Need to specify alphabetSize');
    }
    ASSERT( alphabetSize > 0 );
    if (T.BYTES_PER_ELEMENT) {
        ASSERT( alphabetSize <= (1 << (T.BYTES_PER_ELEMENT*8) ) );
    }
    // double length of T
    var TT;
    if (T.length >= n*2) {
        TT = T; // do it in place if possible
    } else if (alphabetSize <= 256) {
        TT = Util.makeU8Buffer(n*2);
    } else if (alphabetSize <= 65536) {
        TT = Util.makeU16Buffer(n*2);
    } else {
        TT = Util.makeU32Buffer(n*2);
    }
    if (TT!==T) {
        for (i=0; i<n; i++) { TT[i] = T[i]; }
    }
    for (i=0; i<n; i++) { TT[n+i] = TT[i]; }
    // sort doubled string
    var A = Util.makeS32Buffer(n*2);
    SA_IS(TT, A, 0, n*2, alphabetSize, false);
    for (i=0, j=0; i<2*n; i++) {
        var s = A[i];
        if (s < n) {
            if (s === 0) { pidx = j; }
            if (--s < 0) { s = n-1; }
            U[j++] = T[s];
        }
    }
    ASSERT(j===n);
    return pidx;
};

module.exports = freeze(BWT);

},{"./Util":23,"./freeze":24}],3:[function(require,module,exports){
const freeze = require('./freeze');
const Stream = require('./Stream');
const BWT = require('./BWT');
const DefSumModel = require('./DefSumModel');
const FenwickModel = require('./FenwickModel');
const LogDistanceModel = require('./LogDistanceModel');
const NoModel = require('./NoModel');
const RangeCoder = require('./RangeCoder');
const Util = require('./Util');

/* A simple bzip-like BWT compressor with a range encoder; written as a
 * self-test of the BWT package. */
var EOF = Stream.EOF;

var F_PROB_MAX  = 0xFF00;
var F_PROB_INCR = 0x0100;

BWTC = Object.create(null);
BWTC.MAGIC = "bwtc";
BWTC.compressFile = Util.compressFileHelper(BWTC.MAGIC, function(input, output, size, props, finalByte) {
    var encoder = new RangeCoder(output);
    encoder.encodeStart(finalByte, 1);

    var blockSize = 9;
    if (typeof(props)==='number' && props >= 1 && props <= 9) {
        blockSize = props;
    }
    encoder.encodeByte(blockSize);
    var fast = (blockSize <= 5);
    blockSize *= 100000;

    var block = Util.makeU8Buffer(blockSize);
    var readBlock = function() {
        var pos;
        for (pos=0; pos < blockSize; ) {
            var ch = input.readByte();
            if (ch < 0) { break; }
            block[pos++] = ch;
        }
        return pos;
    };
    var U = Util.makeU8Buffer(blockSize);
    var A = Util.makeS32Buffer(blockSize);
    var M = Util.makeU8Buffer(256); // move to front array
    var bitModelFactory = NoModel.factory(encoder);
    var lenModel = new LogDistanceModel(blockSize, 0,
                                        bitModelFactory,
                                        bitModelFactory);
    var length, b, c, pidx, i, j;
    do {
        length = readBlock();
        if (length === 0) { break; }
        // indicate that there's another block comin'
        // and encode the length of the block if necessary
        if (length === block.length) {
            encoder.encodeFreq(1, 0, 3); // "full size block"
            b = block;
        } else {
            encoder.encodeFreq(1, 1, 3); // "short block"
            lenModel.encode(length);
            b = block.subarray(0, length);
        }
        pidx = BWT.bwtransform(b, U, A, length, 256);
        lenModel.encode(pidx); // starting index
        // encode the alphabet subset used
        var useTree = Util.makeU16Buffer(512);
        for (i=0; i<length; i++) {
            c = U[i];
            useTree[256+c] = 1;
        }
        for (i=255; i>0; i--) { // sum all the way up the tree
            useTree[i] = useTree[2*i] + useTree[2*i + 1];
        }
        useTree[0] = 1; // sentinel
        for (i=1; i<512; i++) {
            var parent = i>>>1;
            var full = 1 << (9-Util.fls(i));
            if (useTree[parent] === 0 || useTree[parent] === (full*2)) {
                /* already known full/empty */
            } else if (i >= 256) {
                encoder.encodeBit(useTree[i]); // leaf node
            } else {
                var v = useTree[i];
                v = (v===0) ? 0 : (v===full) ? 2 : 1;
                encoder.encodeFreq(1, v, 3);
            }
        }
        // remap symbols to this subset
        var alphabetSize = 0;
        for (i=0; i<256; i++) {
            if (useTree[256+i]) { // symbol in use
                M[alphabetSize++] = i;
            }
        }
        useTree = null;
        // MTF encoding of U
        for (i=0; i<length; i++) {
            c = U[i];
            for (j=0; j<alphabetSize; j++) {
                if (M[j] === c) {
                    break;
                }
            }
            console.assert(j<alphabetSize);
            U[i] = j;
            // move to front
            for (; j>0; j--) {
                M[j] = M[j-1];
            }
            M[0] = c;
        }
        // RLE/range encoding
        var model = new FenwickModel(encoder, alphabetSize+1,
                                        F_PROB_MAX, F_PROB_INCR);
        if (fast) { model = new DefSumModel(encoder, alphabetSize+1); }
        var runLength = 0;
        var emitLastRun = function() {
            // binary encode runs of zeros
            while (runLength !== 0) {
                if (runLength&1) {
                    model.encode(0); // RUNA
                    runLength-=1;
                } else {
                    model.encode(1); // RUNB
                    runLength-=2;
                }
                runLength >>>= 1;
            }
        };
        for (i=0; i<length; i++) {
            c = U[i];
            if (c === 0) {
                runLength++;
            } else {
                emitLastRun();
                model.encode(c+1);
                // reset for next
                runLength = 0;
            }
        }
        emitLastRun();
        // done with this block!
    } while (length === block.length);

    encoder.encodeFreq(1, 2, 3); // "no more blocks"
    encoder.encodeFinish();
}, true);

BWTC.decompressFile = Util.decompressFileHelper(BWTC.MAGIC, function(input, output, size) {
    var decoder = new RangeCoder(input);
    decoder.decodeStart(true/* already read the extra byte */);
    var blockSize = decoder.decodeByte();
    console.assert(blockSize >= 1 && blockSize <= 9);
    var fast = (blockSize <= 5);
    blockSize *= 100000;

    var block = Util.makeU8Buffer(blockSize);
    var U = Util.makeU8Buffer(blockSize);
    var A = Util.makeS32Buffer(blockSize);
    var M = Util.makeU8Buffer(256); // move to front array
    var bitModelFactory = NoModel.factory(decoder);
    var lenModel = new LogDistanceModel(blockSize, 0,
                                        bitModelFactory,
                                        bitModelFactory);
    var b, length, i, j, c;
    while (true) {
        var blockIndicator = decoder.decodeCulFreq(3);
        decoder.decodeUpdate(1, blockIndicator, 3);
        if (blockIndicator === 0) { // full-length block
            length = blockSize;
            b = block;
        } else if (blockIndicator === 1) { // short block
            length = lenModel.decode();
            b = block.subarray(0, length);
        } else if (blockIndicator === 2) { // all done, no more blocks
            break;
        }
        // read starting index for unBWT
        var pidx = lenModel.decode();
        // decode the alphabet subset used
        var useTree = Util.makeU16Buffer(512);
        useTree[0] = 1; // sentinel
        for (i=1; i<512; i++) {
            var parent = i>>>1;
            var full = 1 << (9-Util.fls(i));
            if (useTree[parent] === 0 || useTree[parent] === (full*2)) {
                /* already known full/empty */
                useTree[i] = useTree[parent] >>> 1;
            } else if (i >= 256) {
                useTree[i] = decoder.decodeBit(); // leaf node
            } else {
                var v = decoder.decodeCulFreq(3);
                decoder.decodeUpdate(1, v, 3);
                useTree[i] = (v===2) ? full : v;
            }
        }
        // remap symbols to this subset
        var alphabetSize = 0;
        for (i=0; i<256; i++) {
            if (useTree[256+i]) { // symbol in use
                M[alphabetSize++] = i;
            }
        }
        useTree = null;
        // RLE/range decoding
        var model = new FenwickModel(decoder, alphabetSize+1,
                                        F_PROB_MAX, F_PROB_INCR);
        if (fast) { model = new DefSumModel(decoder, alphabetSize+1, true);}
        var val = 1; // repeat count
        for (i=0; i<length; ) {
            c = model.decode();
            if (c===0) {
                for (j=0; j<val; j++) { b[i++] = 0; }
                val *= 2;
            } else if (c===1) {
                for (j=0; j<val; j++) { b[i++] = 0; b[i++] = 0; }
                val *= 2;
            } else {
                val = 1;
                b[i++] = c-1;
            }
        }
        // MTF decode
        for (i=0; i<length; i++) {
            j = b[i];
            b[i] = c = M[j];
            // move to front
            for (; j>0; j--) {
                M[j] = M[j-1];
            }
            M[0] = c;
        }
        // unBWT
        BWT.unbwtransform(block, U, A, length, pidx);
        // emit!
        output.write(U, 0, length);
    }
    decoder.decodeFinish();
});

module.exports = BWTC;

},{"./BWT":2,"./DefSumModel":8,"./FenwickModel":10,"./LogDistanceModel":13,"./NoModel":18,"./RangeCoder":20,"./Stream":22,"./Util":23,"./freeze":24}],4:[function(require,module,exports){
/** Big-Endian Bit Stream, implemented on top of a (normal byte) stream. */
const Stream = require('./Stream');

var BitStream = function(stream) {
    (function() {
        var bufferByte = 0x100; // private var for readers
        this.readBit = function() {
            if ((bufferByte & 0xFF) === 0) {
                var ch = stream.readByte();
                if (ch === Stream.EOF) {
                    this._eof = true;
                    return ch; /* !!! */
                }
                bufferByte = (ch << 1) | 1;
            }
            var bit = (bufferByte & 0x100) ? 1 : 0;
            bufferByte <<= 1;
            return bit;
        };
        // seekable iff the provided stream is
        this.seekBit = function(pos) {
            var n_byte = pos >>> 3;
            var n_bit = pos - (n_byte*8);
            this.seek(n_byte);
            this._eof = false;
            this.readBits(n_bit);
        };
        this.tellBit = function() {
            var pos = stream.tell() * 8;
            var b = bufferByte;
            while ((b & 0xFF) !== 0) {
                pos--;
                b <<= 1;
            }
            return pos;
        };
        // implement byte stream interface as well.
        this.readByte = function() {
            if ((bufferByte & 0xFF) === 0) {
                return stream.readByte();
            }
            return this.readBits(8);
        };
        this.seek = function(pos) {
            stream.seek(pos);
            bufferByte = 0x100;
        };
    }).call(this);
    (function() {
        var bufferByte = 1; // private var for writers
        this.writeBit = function(b) {
            bufferByte <<= 1;
            if (b) { bufferByte |= 1; }
            if (bufferByte & 0x100) {
                stream.writeByte(bufferByte & 0xFF);
                bufferByte = 1;
            }
        };
        // implement byte stream interface as well
        this.writeByte = function(_byte) {
            if (bufferByte===1) {
                stream.writeByte(_byte);
            } else {
                stream.writeBits(8, _byte);
            }
        };
        this.flush = function() {
            while (bufferByte !== 1) {
                this.writeBit(0);
            }
            if (stream.flush) { stream.flush(); }
        };
    }).call(this);
};
// inherit read/write methods from Stream.
BitStream.EOF = Stream.EOF;
BitStream.prototype = Object.create(Stream.prototype);
// bit chunk read/write
BitStream.prototype.readBits = function(n) {
    var i, r = 0, b;
    if (n > 31) {
        r = this.readBits(n-16)*0x10000; // fp multiply, not shift
        return r + this.readBits(16);
    }
    for (i = 0; i < n; i++) {
        r <<= 1; // this could make a negative value if n>31
        // bits read past EOF are all zeros!
        if (this.readBit() > 0) { r++; }
    }
    return r;
};
BitStream.prototype.writeBits = function(n, value) {
    if (n > 32) {
        var low = (value & 0xFFFF);
        var high = (value - low) / (0x10000); // fp division, not shift
        this.writeBits(n-16, high);
        this.writeBits(16, low);
        return;
    }
    var i;
    for (i = n-1; i >= 0; i--) {
        this.writeBit( (value >>> i) & 1 );
    }
};

module.exports = BitStream;

},{"./Stream":22}],5:[function(require,module,exports){
/*
An implementation of Bzip2 de/compression, including the ability to
seek within bzip2 data.

Copyright (C) 2013 C. Scott Ananian
Copyright (C) 2012 Eli Skeggs
Copyright (C) 2011 Kevin Kwok

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, see
http://www.gnu.org/licenses/lgpl-2.1.html

Adapted from node-bzip, copyright 2012 Eli Skeggs.
Adapted from bzip2.js, copyright 2011 Kevin Kwok (antimatter15@gmail.com).

Based on micro-bunzip by Rob Landley (rob@landley.net).

Based on bzip2 decompression code by Julian R Seward (jseward@acm.org),
which also acknowledges contributions by Mike Burrows, David Wheeler,
Peter Fenwick, Alistair Moffat, Radford Neal, Ian H. Witten,
Robert Sedgewick, and Jon L. Bentley.

BWT implementation based on work by Yuta Mori; see BWT.js for details.

bzip2 compression code inspired by https://code.google.com/p/jbzip2
*/
const freeze = require('./freeze');
const BitStream = require('./BitStream');
const BWT = require('./BWT');
const CRC32 = require('./CRC32');
const HuffmanAllocator = require('./HuffmanAllocator');
const Stream = require('./Stream');
const Util = require('./Util');

var MAX_HUFCODE_BITS = 20;
var MAX_SYMBOLS = 258;
var SYMBOL_RUNA = 0;
var SYMBOL_RUNB = 1;
var MIN_GROUPS = 2;
var MAX_GROUPS = 6;
var GROUP_SIZE = 50;

var WHOLEPI = 0x314159265359; // 48-bit integer
var SQRTPI =  0x177245385090; // 48-bit integer

var EOF = Stream.EOF;

var mtf = function(array, index) {
  var src = array[index], i;
  for (i = index; i > 0; i--) {
    array[i] = array[i-1];
  }
  array[0] = src;
  return src;
};

var Err = {
  OK: 0,
  LAST_BLOCK: -1,
  NOT_BZIP_DATA: -2,
  UNEXPECTED_INPUT_EOF: -3,
  UNEXPECTED_OUTPUT_EOF: -4,
  DATA_ERROR: -5,
  OUT_OF_MEMORY: -6,
  OBSOLETE_INPUT: -7,
  END_OF_BLOCK: -8
};
var ErrorMessages = {};
ErrorMessages[Err.LAST_BLOCK] =            "Bad file checksum";
ErrorMessages[Err.NOT_BZIP_DATA] =         "Not bzip data";
ErrorMessages[Err.UNEXPECTED_INPUT_EOF] =  "Unexpected input EOF";
ErrorMessages[Err.UNEXPECTED_OUTPUT_EOF] = "Unexpected output EOF";
ErrorMessages[Err.DATA_ERROR] =            "Data error";
ErrorMessages[Err.OUT_OF_MEMORY] =         "Out of memory";
ErrorMessages[Err.OBSOLETE_INPUT] = "Obsolete (pre 0.9.5) bzip format not supported.";

var _throw = function(status, optDetail) {
  var msg = ErrorMessages[status] || 'unknown error';
  if (optDetail) { msg += ': '+optDetail; }
  var e = new TypeError(msg);
  e.errorCode = status;
  throw e;
};

var Bunzip = function(inputStream, outputStream) {
  this.writePos = this.writeCurrent = this.writeCount = 0;

  this._start_bunzip(inputStream, outputStream);
};
Bunzip.prototype._init_block = function() {
  var moreBlocks = this._get_next_block();
  if ( !moreBlocks ) {
    this.writeCount = -1;
    return false; /* no more blocks */
  }
  this.blockCRC = new CRC32();
  return true;
};
/* XXX micro-bunzip uses (inputStream, inputBuffer, len) as arguments */
Bunzip.prototype._start_bunzip = function(inputStream, outputStream) {
  /* Ensure that file starts with "BZh['1'-'9']." */
  var buf = Util.makeU8Buffer(4);
  if (inputStream.read(buf, 0, 4) !== 4 ||
      String.fromCharCode(buf[0], buf[1], buf[2]) !== 'BZh')
    _throw(Err.NOT_BZIP_DATA, 'bad magic');

  var level = buf[3] - 0x30;
  if (level < 1 || level > 9)
    _throw(Err.NOT_BZIP_DATA, 'level out of range');

  this.reader = new BitStream(inputStream);

  /* Fourth byte (ascii '1'-'9'), indicates block size in units of 100k of
     uncompressed data.  Allocate intermediate buffer for block. */
  this.dbufSize = 100000 * level;
  this.nextoutput = 0;
  this.outputStream = outputStream;
  this.streamCRC = 0;
};
Bunzip.prototype._get_next_block = function() {
  var i, j, k;
  var reader = this.reader;
  // this is get_next_block() function from micro-bunzip:
  /* Read in header signature and CRC, then validate signature.
     (last block signature means CRC is for whole file, return now) */
  var h = reader.readBits(48);
  if (h === SQRTPI) { // last block
    return false; /* no more blocks */
  }
  if (h !== WHOLEPI)
    _throw(Err.NOT_BZIP_DATA);
  this.targetBlockCRC = reader.readBits(32);
  this.streamCRC = (this.targetBlockCRC ^
                    ((this.streamCRC << 1) | (this.streamCRC>>>31))) >>> 0;
  /* We can add support for blockRandomised if anybody complains.  There was
     some code for this in busybox 1.0.0-pre3, but nobody ever noticed that
     it didn't actually work. */
  if (reader.readBits(1))
    _throw(Err.OBSOLETE_INPUT);
  var origPointer = reader.readBits(24);
  if (origPointer > this.dbufSize)
    _throw(Err.DATA_ERROR, 'initial position out of bounds');
  /* mapping table: if some byte values are never used (encoding things
     like ASCII text), the compression code removes the gaps to have fewer
     symbols to deal with, and writes a sparse bitfield indicating which
     values were present.  We make a translation table to convert the symbols
     back to the corresponding bytes. */
  var t = reader.readBits(16);
  var symToByte = Util.makeU8Buffer(256), symTotal = 0;
  for (i = 0; i < 16; i++) {
    if (t & (1 << (0xF - i))) {
      var o = i * 16;
      k = reader.readBits(16);
      for (j = 0; j < 16; j++)
        if (k & (1 << (0xF - j)))
          symToByte[symTotal++] = o + j;
    }
  }

  /* How many different Huffman coding groups does this block use? */
  var groupCount = reader.readBits(3);
  if (groupCount < MIN_GROUPS || groupCount > MAX_GROUPS)
    _throw(Err.DATA_ERROR);
  /* nSelectors: Every GROUP_SIZE many symbols we select a new Huffman coding
     group.  Read in the group selector list, which is stored as MTF encoded
     bit runs.  (MTF=Move To Front, as each value is used it's moved to the
     start of the list.) */
  var nSelectors = reader.readBits(15);
  if (nSelectors === 0)
    _throw(Err.DATA_ERROR);

  var mtfSymbol = Util.makeU8Buffer(256);
  for (i = 0; i < groupCount; i++)
    mtfSymbol[i] = i;

  var selectors = Util.makeU8Buffer(nSelectors); // was 32768...

  for (i = 0; i < nSelectors; i++) {
    /* Get next value */
    for (j = 0; reader.readBits(1); j++)
      if (j >= groupCount) _throw(Err.DATA_ERROR);
    /* Decode MTF to get the next selector */
    selectors[i] = mtf(mtfSymbol, j);
  }

  /* Read the Huffman coding tables for each group, which code for symTotal
     literal symbols, plus two run symbols (RUNA, RUNB) */
  var symCount = symTotal + 2;
  var groups = [], hufGroup;
  for (j = 0; j < groupCount; j++) {
    var length = Util.makeU8Buffer(symCount), temp = Util.makeU16Buffer(MAX_HUFCODE_BITS + 1);
    /* Read Huffman code lengths for each symbol.  They're stored in
       a way similar to MTF; record a starting value for the first symbol,
       and an offset from the previous value for every symbol after that. */
    t = reader.readBits(5); // lengths
    for (i = 0; i < symCount; i++) {
      for (;;) {
        if (t < 1 || t > MAX_HUFCODE_BITS) _throw(Err.DATA_ERROR);
        /* If first bit is 0, stop.  Else second bit indicates whether
           to increment or decrement the value. */
        if(!reader.readBits(1))
          break;
        if(!reader.readBits(1))
          t++;
        else
          t--;
      }
      length[i] = t;
    }

    /* Find largest and smallest lengths in this group */
    var minLen,  maxLen;
    minLen = maxLen = length[0];
    for (i = 1; i < symCount; i++) {
      if (length[i] > maxLen)
        maxLen = length[i];
      else if (length[i] < minLen)
        minLen = length[i];
    }

    /* Calculate permute[], base[], and limit[] tables from length[].
     *
     * permute[] is the lookup table for converting Huffman coded symbols
     * into decoded symbols.  base[] is the amount to subtract from the
     * value of a Huffman symbol of a given length when using permute[].
     *
     * limit[] indicates the largest numerical value a symbol with a given
     * number of bits can have.  This is how the Huffman codes can vary in
     * length: each code with a value>limit[length] needs another bit.
     */
    hufGroup = {};
    groups.push(hufGroup);
    hufGroup.permute = Util.makeU16Buffer(MAX_SYMBOLS);
    hufGroup.limit = Util.makeU32Buffer(MAX_HUFCODE_BITS + 2);
    hufGroup.base = Util.makeU32Buffer(MAX_HUFCODE_BITS + 1);
    hufGroup.minLen = minLen;
    hufGroup.maxLen = maxLen;
    /* Calculate permute[].  Concurrently, initialize temp[] and limit[]. */
    var pp = 0;
    for (i = minLen; i <= maxLen; i++) {
      temp[i] = hufGroup.limit[i] = 0;
      for (t = 0; t < symCount; t++)
        if (length[t] === i)
          hufGroup.permute[pp++] = t;
    }
    /* Count symbols coded for at each bit length */
    for (i = 0; i < symCount; i++)
      temp[length[i]]++;
    /* Calculate limit[] (the largest symbol-coding value at each bit
     * length, which is (previous limit<<1)+symbols at this level), and
     * base[] (number of symbols to ignore at each bit length, which is
     * limit minus the cumulative count of symbols coded for already). */
    pp = t = 0;
    for (i = minLen; i < maxLen; i++) {
      pp += temp[i];
      /* We read the largest possible symbol size and then unget bits
         after determining how many we need, and those extra bits could
         be set to anything.  (They're noise from future symbols.)  At
         each level we're really only interested in the first few bits,
         so here we set all the trailing to-be-ignored bits to 1 so they
         don't affect the value>limit[length] comparison. */
      hufGroup.limit[i] = pp - 1;
      pp <<= 1;
      t += temp[i];
      hufGroup.base[i + 1] = pp - t;
    }
    hufGroup.limit[maxLen + 1] = Number.MAX_VALUE; /* Sentinel value for reading next sym. */
    hufGroup.limit[maxLen] = pp + temp[maxLen] - 1;
    hufGroup.base[minLen] = 0;
  }
  /* We've finished reading and digesting the block header.  Now read this
     block's Huffman coded symbols from the file and undo the Huffman coding
     and run length encoding, saving the result into dbuf[dbufCount++]=uc */

  /* Initialize symbol occurrence counters and symbol Move To Front table */
  var byteCount = Util.makeU32Buffer(256);
  for (i = 0; i < 256; i++)
    mtfSymbol[i] = i;
  /* Loop through compressed symbols. */
  var runPos = 0, dbufCount = 0, selector = 0, uc;
  var dbuf = this.dbuf = Util.makeU32Buffer(this.dbufSize);
  symCount = 0;
  for (;;) {
    /* Determine which Huffman coding group to use. */
    if (!(symCount--)) {
      symCount = GROUP_SIZE - 1;
      if (selector >= nSelectors) { _throw(Err.DATA_ERROR); }
      hufGroup = groups[selectors[selector++]];
    }
    /* Read next Huffman-coded symbol. */
    i = hufGroup.minLen;
    j = reader.readBits(i);
    for (;;i++) {
      if (i > hufGroup.maxLen) { _throw(Err.DATA_ERROR); }
      if (j <= hufGroup.limit[i])
        break;
      j = (j << 1) | reader.readBits(1);
    }
    /* Huffman decode value to get nextSym (with bounds checking) */
    j -= hufGroup.base[i];
    if (j < 0 || j >= MAX_SYMBOLS) { _throw(Err.DATA_ERROR); }
    var nextSym = hufGroup.permute[j];
    /* We have now decoded the symbol, which indicates either a new literal
       byte, or a repeated run of the most recent literal byte.  First,
       check if nextSym indicates a repeated run, and if so loop collecting
       how many times to repeat the last literal. */
    if (nextSym === SYMBOL_RUNA || nextSym === SYMBOL_RUNB) {
      /* If this is the start of a new run, zero out counter */
      if (!runPos){
        runPos = 1;
        t = 0;
      }
      /* Neat trick that saves 1 symbol: instead of or-ing 0 or 1 at
         each bit position, add 1 or 2 instead.  For example,
         1011 is 1<<0 + 1<<1 + 2<<2.  1010 is 2<<0 + 2<<1 + 1<<2.
         You can make any bit pattern that way using 1 less symbol than
         the basic or 0/1 method (except all bits 0, which would use no
         symbols, but a run of length 0 doesn't mean anything in this
         context).  Thus space is saved. */
      if (nextSym === SYMBOL_RUNA)
        t += runPos;
      else
        t += 2 * runPos;
      runPos <<= 1;
      continue;
    }
    /* When we hit the first non-run symbol after a run, we now know
       how many times to repeat the last literal, so append that many
       copies to our buffer of decoded symbols (dbuf) now.  (The last
       literal used is the one at the head of the mtfSymbol array.) */
    if (runPos){
      runPos = 0;
      if (dbufCount + t > this.dbufSize) { _throw(Err.DATA_ERROR); }
      uc = symToByte[mtfSymbol[0]];
      byteCount[uc] += t;
      while (t--)
        dbuf[dbufCount++] = uc;
    }
    /* Is this the terminating symbol? */
    if (nextSym > symTotal)
      break;
    /* At this point, nextSym indicates a new literal character.  Subtract
       one to get the position in the MTF array at which this literal is
       currently to be found.  (Note that the result can't be -1 or 0,
       because 0 and 1 are RUNA and RUNB.  But another instance of the
       first symbol in the MTF array, position 0, would have been handled
       as part of a run above.  Therefore 1 unused MTF position minus
       2 non-literal nextSym values equals -1.) */
    if (dbufCount >= this.dbufSize) { _throw(Err.DATA_ERROR); }
    i = nextSym - 1;
    uc = mtf(mtfSymbol, i);
    uc = symToByte[uc];
    /* We have our literal byte.  Save it into dbuf. */
    byteCount[uc]++;
    dbuf[dbufCount++] = uc;
  }
  /* At this point, we've read all the Huffman-coded symbols (and repeated
     runs) for this block from the input stream, and decoded them into the
     intermediate buffer.  There are dbufCount many decoded bytes in dbuf[].
     Now undo the Burrows-Wheeler transform on dbuf.
     See http://dogma.net/markn/articles/bwt/bwt.htm
  */
  if (origPointer < 0 || origPointer >= dbufCount) { _throw(Err.DATA_ERROR); }
  /* Turn byteCount into cumulative occurrence counts of 0 to n-1. */
  j = 0;
  for (i = 0; i < 256; i++) {
    k = j + byteCount[i];
    byteCount[i] = j;
    j = k;
  }
  /* Figure out what order dbuf would be in if we sorted it. */
  for (i = 0; i < dbufCount; i++) {
    uc = dbuf[i] & 0xff;
    dbuf[byteCount[uc]] |= (i << 8);
    byteCount[uc]++;
  }
  /* Decode first byte by hand to initialize "previous" byte.  Note that it
     doesn't get output, and if the first three characters are identical
     it doesn't qualify as a run (hence writeRunCountdown=5). */
  var pos = 0, current = 0, run = 0;
  if (dbufCount) {
    pos = dbuf[origPointer];
    current = (pos & 0xff);
    pos >>= 8;
    run = -1;
  }
  this.writePos = pos;
  this.writeCurrent = current;
  this.writeCount = dbufCount;
  this.writeRun = run;

  return true; /* more blocks to come */
};
/* Undo burrows-wheeler transform on intermediate buffer to produce output.
   If start_bunzip was initialized with out_fd=-1, then up to len bytes of
   data are written to outbuf.  Return value is number of bytes written or
   error (all errors are negative numbers).  If out_fd!=-1, outbuf and len
   are ignored, data is written to out_fd and return is RETVAL_OK or error.
*/
Bunzip.prototype._read_bunzip = function(outputBuffer, len) {
    var copies, previous, outbyte;
    /* james@jamestaylor.org: writeCount goes to -1 when the buffer is fully
       decoded, which results in this returning RETVAL_LAST_BLOCK, also
       equal to -1... Confusing, I'm returning 0 here to indicate no
       bytes written into the buffer */
  if (this.writeCount < 0) { return 0; }

  var gotcount = 0;
  var dbuf = this.dbuf, pos = this.writePos, current = this.writeCurrent;
  var dbufCount = this.writeCount, outputsize = this.outputsize;
  var run = this.writeRun;

  while (dbufCount) {
    dbufCount--;
    previous = current;
    pos = dbuf[pos];
    current = pos & 0xff;
    pos >>= 8;
    if (run++ === 3){
      copies = current;
      outbyte = previous;
      current = -1;
    } else {
      copies = 1;
      outbyte = current;
    }
    this.blockCRC.updateCRCRun(outbyte, copies);
    while (copies--) {
      this.outputStream.writeByte(outbyte);
      this.nextoutput++;
    }
    if (current != previous)
      run = 0;
  }
  this.writeCount = dbufCount;
  // check CRC
  if (this.blockCRC.getCRC() !== this.targetBlockCRC) {
    _throw(Err.DATA_ERROR, "Bad block CRC "+
           "(got "+this.blockCRC.getCRC().toString(16)+
           " expected "+this.targetBlockCRC.toString(16)+")");
  }
  return this.nextoutput;
};

/* Static helper functions */
Bunzip.Err = Err;
// 'input' can be a stream or a buffer
// 'output' can be a stream or a buffer or a number (buffer size)
Bunzip.decode = function(input, output, multistream) {
  // make a stream from a buffer, if necessary
  var inputStream = Util.coerceInputStream(input);
  var o = Util.coerceOutputStream(output, output);
  var outputStream = o.stream;

  var bz = new Bunzip(inputStream, outputStream);
  while (true) {
    if ('eof' in inputStream && inputStream.eof()) break;
    if (bz._init_block()) {
      bz._read_bunzip();
    } else {
      var targetStreamCRC = bz.reader.readBits(32);
      if (targetStreamCRC !== bz.streamCRC) {
        _throw(Err.DATA_ERROR, "Bad stream CRC "+
               "(got "+bz.streamCRC.toString(16)+
               " expected "+targetStreamCRC.toString(16)+")");
      }
      if (multistream &&
          'eof' in inputStream &&
          !inputStream.eof()) {
        // note that start_bunzip will also resync the bit reader to next byte
        bz._start_bunzip(inputStream, outputStream);
      } else break;
    }
  }
  return o.retval;
};
Bunzip.decodeBlock = function(input, pos, output) {
  // make a stream from a buffer, if necessary
  var inputStream = Util.coerceInputStream(input);
  var o = Util.coerceOutputStream(output, output);
  var outputStream = o.stream;
  var bz = new Bunzip(inputStream, outputStream);
  bz.reader.seekBit(pos);
  /* Fill the decode buffer for the block */
  var moreBlocks = bz._get_next_block();
  if (moreBlocks) {
    /* Init the CRC for writing */
    bz.blockCRC = new CRC32();

    /* Zero this so the current byte from before the seek is not written */
    bz.writeCopies = 0;

    /* Decompress the block and write to stdout */
    bz._read_bunzip();
    // XXX keep writing?
  }
  return o.retval;
};
/* Reads bzip2 file from stream or buffer `input`, and invoke
 * `callback(position, size)` once for each bzip2 block,
 * where position gives the starting position (in *bits*)
 * and size gives uncompressed size of the block (in *bytes*). */
Bunzip.table = function(input, callback, multistream) {
  // make a stream from a buffer, if necessary
  var inputStream = new Stream();
  inputStream.delegate = Util.coerceInputStream(input);
  inputStream.pos = 0;
  inputStream.readByte = function() {
    this.pos++;
    return this.delegate.readByte();
  };
  inputStream.tell = function() { return this.pos; };
  if (inputStream.delegate.eof) {
    inputStream.eof = inputStream.delegate.eof.bind(inputStream.delegate);
  }
  var outputStream = new Stream();
  outputStream.pos = 0;
  outputStream.writeByte = function() { this.pos++; };

  var bz = new Bunzip(inputStream, outputStream);
  var blockSize = bz.dbufSize;
  while (true) {
    if ('eof' in inputStream && inputStream.eof()) break;

    var position = bz.reader.tellBit();

    if (bz._init_block()) {
      var start = outputStream.pos;
      bz._read_bunzip();
      callback(position, outputStream.pos - start);
    } else {
      var crc = bz.reader.readBits(32); // (but we ignore the crc)
      if (multistream &&
          'eof' in inputStream &&
          !inputStream.eof()) {
        // note that start_bunzip will also resync the bit reader to next byte
        bz._start_bunzip(inputStream, outputStream);
        console.assert(bz.dbufSize === blockSize,
                       "shouldn't change block size within multistream file");
      } else break;
    }
  }
};

// create a Huffman tree from the table of frequencies
var StaticHuffman = function(freq, alphabetSize) {
  // As in BZip2HuffmanStageEncoder.java (from jbzip2):
  // The Huffman allocator needs its input symbol frequencies to be
  // sorted, but we need to return code lengths in the same order as
  // the corresponding frequencies are passed in.
  // The symbol frequency and index are merged into a single array of
  // integers - frequency in the high 23 bits, index in the low 9
  // bits.
  //     2^23 = 8,388,608 which is higher than the maximum possible
  //            frequency for one symbol in a block
  //     2^9 = 512 which is higher than the maximum possible
  //            alphabet size (== 258)
  // Sorting this array simultaneously sorts the frequencies and
  // leaves a lookup that can be used to cheaply invert the sort
  var i, mergedFreq = [];
  for (i=0; i<alphabetSize; i++) {
    mergedFreq[i] = (freq[i] << 9) | i;
  }
  mergedFreq.sort(function(a,b) { return a-b; });
  var sortedFreq = mergedFreq.map(function(v) { return v>>>9; });
  // allocate code lengths in place. (result in sortedFreq array)
  HuffmanAllocator.allocateHuffmanCodeLengths(sortedFreq, MAX_HUFCODE_BITS);
  // reverse the sort to put codes & code lengths in order of input symbols
  this.codeLengths = Util.makeU8Buffer(alphabetSize);
  for (i=0; i<alphabetSize; i++) {
    var sym = mergedFreq[i] & 0x1FF;
    this.codeLengths[sym] = sortedFreq[i];
  }
};
// compute canonical Huffman codes, given code lengths
StaticHuffman.prototype.computeCanonical = function() {
  var alphabetSize = this.codeLengths.length;
  // merge arrays; sort first by length then by symbol.
  var i, merged = [];
  for (i=0; i<alphabetSize; i++) {
    merged[i] = (this.codeLengths[i] << 9) | i;
  }
  merged.sort(function(a,b) { return a-b; });
  // use sorted lengths to assign codes
  this.code = Util.makeU32Buffer(alphabetSize);
  var code = 0, prevLen = 0;
  for (i=0; i<alphabetSize; i++) {
    var curLen = merged[i] >>> 9;
    var sym = merged[i] & 0x1FF;
    console.assert(prevLen <= curLen);
    code <<= (curLen - prevLen);
    this.code[sym] = code++;
    prevLen = curLen;
  }
};
// compute the cost of encoding the given range of symbols w/ this Huffman code
StaticHuffman.prototype.cost = function(array, offset, length) {
  var i, cost = 0;
  for (i=0; i<length; i++) {
    cost += this.codeLengths[array[offset+i]];
  }
  return cost;
};
// emit the bit lengths used by this Huffman code
StaticHuffman.prototype.emit = function(outStream) {
  // write the starting length
  var i, currentLength = this.codeLengths[0];
  outStream.writeBits(5, currentLength);
  for (i=0; i<this.codeLengths.length; i++) {
    var codeLength = this.codeLengths[i];
    var value, delta;
    console.assert(codeLength > 0 && codeLength <= MAX_HUFCODE_BITS);
    if (currentLength < codeLength) {
      value = 2; delta = codeLength - currentLength;
    } else {
      value = 3; delta = currentLength - codeLength;
    }
    while (delta-- > 0) {
      outStream.writeBits(2, value);
    }
    outStream.writeBit(0);
    currentLength = codeLength;
  }
};
// encode the given symbol with this Huffman code
StaticHuffman.prototype.encode = function(outStream, symbol) {
  outStream.writeBits(this.codeLengths[symbol], this.code[symbol]);
};

// read a block for bzip2 compression.
var readBlock = function(inStream, block, length, crc) {
  var pos = 0;
  var lastChar = -1;
  var runLength = 0;
  while (pos < length) {
    if (runLength===4) {
      block[pos++] = 0;
      if (pos >= length) { break; }
    }
    var ch = inStream.readByte();
    if (ch === EOF) {
      break;
    }
    crc.updateCRC(ch);
    if (ch !== lastChar) {
      lastChar = ch;
      runLength = 1;
    } else {
      runLength++;
      if (runLength > 4) {
        if (runLength < 256) {
          block[pos-1]++;
          continue;
        } else {
          runLength = 1;
        }
      }
    }
    block[pos++] = ch;
  }
  return pos;
};

// divide the input into groups at most GROUP_SIZE symbols long.
// assign each group to the Huffman table which compresses it best.
var assignSelectors = function(selectors, groups, input) {
  var i, j, k;
  for (i=0, k=0; i<input.length; i+=GROUP_SIZE) {
    var groupSize = Math.min(GROUP_SIZE, input.length - i);
    var best = 0, bestCost = groups[0].cost(input, i, groupSize);
    for (j=1; j<groups.length; j++) {
      var groupCost = groups[j].cost(input, i, groupSize);
      if (groupCost < bestCost) {
        best = j; bestCost = groupCost;
      }
    }
    selectors[k++] = best;
  }
};
var optimizeHuffmanGroups = function(groups, targetGroups, input,
                                     selectors, alphabetSize) {
  // until we've got "targetGroups" Huffman codes, pick the Huffman code which
  // matches the largest # of groups and split it by picking the groups
  // which require more than the median number of bits to encode.
  // then recompute frequencies and reassign Huffman codes.
  var i, j, k, groupCounts = [];
  while (groups.length < targetGroups) {
    assignSelectors(selectors, groups, input);
    // which code gets used the most?
    for (i=0; i<groups.length; i++) { groupCounts[i] = 0; }
    for (i=0; i<selectors.length; i++) {
      groupCounts[selectors[i]]++;
    }
    var which = groupCounts.indexOf(Math.max.apply(Math, groupCounts));
    // ok, let's look at the size of those blocks
    var splits = [];
    for (i=0, j=0; i<selectors.length; i++) {
      if (selectors[i] !== which) { continue; }
      var start = i*GROUP_SIZE;
      var end = Math.min(start + GROUP_SIZE, input.length);
      splits.push({index: i, cost:groups[which].cost(input, start, end-start)});
    }
    // find the median.  there are O(n) algorithms to do this, but we'll
    // be lazy and use a full O(n ln n) sort.
    splits.sort(function(s1, s2) { return s1.cost - s2.cost; });
    // assign the groups in the top half to the "new" selector
    for (i=(splits.length>>>1); i<splits.length; i++) {
      selectors[splits[i].index] = groups.length;
    }
    groups.push(null);
    // recompute frequencies
    var freq = [], f;
    for (i=0; i<groups.length; i++) {
      f = freq[i] = [];
      for (j=0; j<alphabetSize; j++) { f[j] = 0; }
    }
    for (i=0, j=0; i<input.length; ) {
      f = freq[selectors[j++]];
      for (k=0; k<GROUP_SIZE && i<input.length; k++) {
        f[input[i++]]++;
      }
    }
    // reconstruct Huffman codes
    for (i=0; i<groups.length; i++) {
      groups[i] = new StaticHuffman(freq[i], alphabetSize);
    }
  }
};

var compressBlock = function(block, length, outStream) {
  var c, i, j, k;
  // do BWT transform
  var U = Util.makeU8Buffer(length);
  var pidx = BWT.bwtransform2(block, U, length, 256);
  outStream.writeBit(0); // not randomized
  outStream.writeBits(24, pidx);
  // track values used; write bitmap
  var used = [], compact = [];
  for (i=0; i<length; i++) {
    c = block[i];
    used[c] = true;
    compact[c>>>4] = true;
  }
  for (i=0; i<16; i++) {
    outStream.writeBit(!!compact[i]);
  }
  for (i=0; i<16; i++) {
    if (compact[i]) {
      for (j=0; j<16; j++) {
        outStream.writeBit(!!used[(i<<4)|j]);
      }
    }
  }
  var alphabetSize = 0;
  for (i=0; i<256; i++) {
    if (used[i]) {
      alphabetSize++;
    }
  }
  // now MTF and RLE/2 encoding, while tracking symbol statistics.
  // output can be one longer than length, because we include the
  // end-of-block character at the end. Similarly, we need a U16
  // array because the end-of-block character can be 256.
  var A = Util.makeU16Buffer(length+1);
  var endOfBlock = alphabetSize + 1;
  var freq = [];
  for (i=0; i<=endOfBlock; i++) { freq[i] = 0; }
  var M = Util.makeU8Buffer(alphabetSize);
  for (i=0, j=0; i<256; i++) {
    if (used[i]) { M[j++] = i; }
  }
  used = null; compact = null;
  var pos = 0, runLength = 0;
  var emit = function(c) {
    A[pos++] = c;
    freq[c]++;
  };
  var emitLastRun = function() {
    while (runLength !== 0) {
      if (runLength & 1) {
        emit(0); // RUNA
        runLength -= 1;
      } else {
        emit(1); // RUNB
        runLength -= 2;
      }
      runLength >>>= 1;
    }
  };
  for (i=0; i<U.length; i++) {
    c = U[i];
    // look for C in M
    for (j=0; j<alphabetSize; j++) {
      if (M[j]===c) { break; }
    }
    console.assert(j!==alphabetSize);
    // shift MTF array
    mtf(M, j);
    // emit j
    if (j===0) {
      runLength++;
    } else {
      emitLastRun();
      emit(j+1);
      runLength = 0;
    }
  }
  emitLastRun();
  emit(endOfBlock); // end of block symbol
  A = A.subarray(0, pos);
  // now A[0...pos) has the encoded output, and freq[0-alphabetSize] has the
  // frequencies.  Use these to construct Huffman tables.
  // the canonical bzip2 encoder does some complicated optimization
  // to attempt to select the best tables.  We're going to simplify things:
  // (unless the block is very short) we're always going to create MAX_GROUPS
  // tables; 1 based on global frequencies, and the rest based on dividing the
  // block into MAX_GROUPS-1 pieces.
  var groups = [];
  var targetGroups; // how many Huffman groups should we create?
  // look at length of MTF-encoded block to pick a good number of groups
  if (pos >= 2400) { targetGroups = 6; }
  else if (pos >= 1200) { targetGroups = 5; }
  else if (pos >= 600) { targetGroups = 4; }
  else if (pos >= 200) { targetGroups = 3; }
  else { targetGroups = 2; }
  // start with two Huffman groups: one with the global frequencies, and
  // a second with a flat frequency distribution (which is also the smallest
  // possible Huffman table to encode, which is handy to prevent excessive
  // bloat if the input file size is very small)
  groups.push(new StaticHuffman(freq, endOfBlock+1));
  for (i=0; i<=endOfBlock; i++) { freq[i] = 1; }
  groups.push(new StaticHuffman(freq, endOfBlock+1));
  freq = null;
  // Now optimize the Huffman groups!  this is a black art.
  // we probably don't want to waste too much time on it, though.
  var selectors = Util.makeU8Buffer(Math.ceil(pos / GROUP_SIZE));
  optimizeHuffmanGroups(groups, targetGroups, A, selectors, endOfBlock+1);
  assignSelectors(selectors, groups, A);

  // okay, let's start writing out our Huffman tables
  console.assert(groups.length >= MIN_GROUPS && groups.length <= MAX_GROUPS);
  outStream.writeBits(3, groups.length);
  // and write out the best selector for each group
  outStream.writeBits(15, selectors.length);
  for (i=0; i<groups.length; i++) { M[i] = i; } // initialize MTF table.
  for (i=0; i<selectors.length; i++) {
    var s = selectors[i];
    // find selector in MTF list
    for (j=0; j<groups.length; j++) { if (M[j]===s) { break; } }
    console.assert(j<groups.length);
    mtf(M, j);
    // emit 'j' as a unary number
    for (;j>0; j--) {
      outStream.writeBit(1);
    }
    outStream.writeBit(0);
  }
  // okay, now emit the Huffman tables in order.
  for (i=0; i<groups.length; i++) {
    groups[i].emit(outStream);
    groups[i].computeCanonical(); // get ready for next step while we're at it
  }
  // okay, now (finally!) emit the actual data!
  for (i=0, k=0; i<pos; ) {
    var huff = groups[selectors[k++]];
    for (j=0; j<GROUP_SIZE && i<pos; j++) {
      huff.encode(outStream, A[i++]);
    }
  }
  // done.
};

var Bzip2 = Object.create(null);
Bzip2.compressFile = function(inStream, outStream, props) {
  inStream = Util.coerceInputStream(inStream);
  var o = Util.coerceOutputStream(outStream, outStream);
  outStream = new BitStream(o.stream);

  var blockSizeMultiplier = 9;
  if (typeof(props)==='number') {
    blockSizeMultiplier = props;
  }
  if (blockSizeMultiplier < 1 || blockSizeMultiplier > 9) {
    throw new Error('Invalid block size multiplier');
  }

  var blockSize = blockSizeMultiplier * 100000;
  // the C implementation always writes at least length-19 characters,
  // but it reads ahead enough that if the last character written was part
  // of a run, it writes out the full run.
  // That's really annoying to implement.
  // So instead just subtract 19 from the blockSize; in most cases (unless
  // there's a run at the end of the block) this will yield block divisions
  // matching the C implementation.
  blockSize -= 19;

  // write file magic
  outStream.writeByte('B'.charCodeAt(0));
  outStream.writeByte('Z'.charCodeAt(0));
  outStream.writeByte('h'.charCodeAt(0)); // Huffman-coded bzip
  outStream.writeByte('0'.charCodeAt(0) + blockSizeMultiplier);

  // allocate a buffer for the block
  var block = Util.makeU8Buffer(blockSize);
  var streamCRC = 0;
  var length;

  do {
    var crc = new CRC32();
    length = readBlock(inStream, block, blockSize, crc);
    if (length > 0) {
      streamCRC = (((streamCRC << 1) | (streamCRC>>>31)) ^ crc.getCRC()) >>> 0;
      outStream.writeBits(48, WHOLEPI);
      outStream.writeBits(32, crc.getCRC());
      compressBlock(block, length, outStream);
    }
  } while (length === blockSize);

  // finish up
  outStream.writeBits(48, SQRTPI);
  outStream.writeBits(32, streamCRC);
  outStream.flush(); // get the last bits flushed out
  return o.retval;
};

Bzip2.decompressFile = Bunzip.decode;
Bzip2.decompressBlock = Bunzip.decodeBlock;
Bzip2.table = Bunzip.table;

module.exports = Bzip2;

},{"./BWT":2,"./BitStream":4,"./CRC32":6,"./HuffmanAllocator":12,"./Stream":22,"./Util":23,"./freeze":24}],6:[function(require,module,exports){
/* CRC32, used in Bzip2 implementation.
 * This is a port of CRC32.java from the jbzip2 implementation at
 *   https://code.google.com/p/jbzip2
 * which is:
 *   Copyright (c) 2011 Matthew Francis
 *
 *   Permission is hereby granted, free of charge, to any person
 *   obtaining a copy of this software and associated documentation
 *   files (the "Software"), to deal in the Software without
 *   restriction, including without limitation the rights to use,
 *   copy, modify, merge, publish, distribute, sublicense, and/or sell
 *   copies of the Software, and to permit persons to whom the
 *   Software is furnished to do so, subject to the following
 *   conditions:
 *
 *   The above copyright notice and this permission notice shall be
 *   included in all copies or substantial portions of the Software.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 *   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 *   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 *   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 *   OTHER DEALINGS IN THE SOFTWARE.
 * This JavaScript implementation is:
 *   Copyright (c) 2013 C. Scott Ananian
 * with the same licensing terms as Matthew Francis' original implementation.
 */
const Util = require('./Util');

/**
 * A static CRC lookup table
 */
  var crc32Lookup = Util.arraycopy(Util.makeU32Buffer(256), [
  0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,
  0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61, 0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
  0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
  0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,
  0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039, 0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
  0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
  0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
  0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1, 0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,
  0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
  0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,
  0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde, 0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,
  0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
  0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,
  0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6, 0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,
  0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
  0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,
  0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637, 0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
  0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
  0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,
  0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff, 0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,
  0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
  0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
  0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7, 0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,
  0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
  0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,
  0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8, 0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,
  0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
  0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,
  0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0, 0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,
  0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
  0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,
  0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668, 0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
]);

var CRC32 = function() {
  /**
   * The current CRC
   */
  var crc = 0xffffffff;

  /**
   * @return The current CRC
   */
  this.getCRC = function() {
    return (~crc) >>> 0; // return an unsigned value
  };

  /**
   * Update the CRC with a single byte
   * @param value The value to update the CRC with
   */
  this.updateCRC = function(value) {
    crc = (crc << 8) ^ crc32Lookup[((crc >>> 24) ^ value) & 0xff];
  };

  /**
   * Update the CRC with a sequence of identical bytes
   * @param value The value to update the CRC with
   * @param count The number of bytes
   */
  this.updateCRCRun = function(value, count) {
    while (count-- > 0) {
      crc = (crc << 8) ^ crc32Lookup[((crc >>> 24) ^ value) & 0xff];
    }
  };
};
module.exports = CRC32;

},{"./Util":23}],7:[function(require,module,exports){
/** A simple context-1 model. */
const BitStream = require('./BitStream');
const Huffman = require('./Huffman');
const Util = require('./Util');

var Context1Model = function(modelFactory, contextSize, alphabetSize) {
  var i;
  this.literalModel = [];
  // even if there's an EOF symbol, we don't need a context for it!
  for (i=0; i<contextSize; i++) {
    this.literalModel[i] = modelFactory(alphabetSize);
  }
};
Context1Model.prototype.encode = function(ch, context) {
  this.literalModel[context].encode(ch);
};
Context1Model.prototype.decode = function(context) {
  return this.literalModel[context].decode();
};

/** Simple self-test. */
Context1Model.MAGIC='ctx1';
Context1Model.compressFile = Util.compressFileHelper(Context1Model.MAGIC, function(inStream, outStream, fileSize, props) {
  var bitstream = new BitStream(outStream);
  var alphabetSize = 256;
  if (fileSize < 0) { alphabetSize++; }
  var coder = Huffman.factory(bitstream, 8191);
  var model = new Context1Model(coder, 256, alphabetSize);
  var lastchar = 0x20;
  var modelp = {
    encode: function(symbol) {
      model.encode(symbol, lastchar);
      lastchar = symbol;
    }
  };
  Util.compressWithModel(inStream, fileSize, modelp);
  bitstream.flush();
});
Context1Model.decompressFile = Util.decompressFileHelper(Context1Model.MAGIC, function(inStream, outStream, fileSize) {
  var bitstream = new BitStream(inStream);
  var alphabetSize = 256;
  if (fileSize < 0) { alphabetSize++; }
  var coder = Huffman.factory(bitstream, 8191);
  var model = new Context1Model(coder, 256, alphabetSize);
  var lastchar = 0x20;
  var modelp = {
    decode: function() {
      var symbol = model.decode(lastchar);
      lastchar = symbol;
      return symbol;
    }
  };
  Util.decompressWithModel(outStream, fileSize, modelp);
});

module.exports = Context1Model;

},{"./BitStream":4,"./Huffman":11,"./Util":23}],8:[function(require,module,exports){
/** Deferred-sum model, suitable for small ( ~ 256 ) ranges. */
// See http://cbloom.com/src/defsum.zip
//     http://cbloom.com/papers/context.pdf
const RangeCoder = require('./RangeCoder');
const Stream = require('./Stream');
const Util = require('./Util');

var LOG_PROB_TOTAL = 8;
var PROB_TOTAL = 1 << LOG_PROB_TOTAL;
var MAX_ESCAPE_COUNT = 40;

var DefSumModel = function(coder, size, isDecoder) {
  var i;
  console.assert(size < 300); // not meant for sparse
  var ESCAPE = this.numSyms = size;
  this.coder = coder;
  this.prob = Util.makeU16Buffer(size+2); /* size + ESC + 1 */
  this.escape = Util.makeU16Buffer(size+1);  /* size + 1*/
  this.update = Util.makeU16Buffer(size+1); /* size + ESC */
  this.prob[ESCAPE+1] = PROB_TOTAL;
  for (i=0; i<=this.numSyms; i++) {
    this.escape[i] = i;
  }
  this.updateCount = 0;
  this.updateThresh = PROB_TOTAL - Math.floor(PROB_TOTAL / 2);
  if (!isDecoder) { return; }
  // extra tables for fast decoding
  this.probToSym = Util.makeU16Buffer(PROB_TOTAL);
  this.escProbToSym = Util.makeU16Buffer(this.numSyms);
  for (i=0; i<PROB_TOTAL; i++) {
    this.probToSym[i] = ESCAPE;
  }
  for (i=0; i<this.numSyms; i++) {
    this.escProbToSym[i] = i;
  }
};
DefSumModel.factory = function(coder, isDecoder) {
  return function(size) { return new DefSumModel(coder, size, isDecoder); };
};
DefSumModel.prototype._update = function(symbol, isDecoder) {
  if (symbol === this.numSyms) {
    // some special cases for the escape character
    if (this.update[symbol] >= MAX_ESCAPE_COUNT) { return; } // hard limit
    // don't let an escape character trigger an update, because then the
    // escaped character might find itself unescaped after the tables have
    // been updated!
    if (this.updateCount >= (this.updateThresh - 1)) { return; }
  }
  this.update[symbol]++;
  this.updateCount++;
  // is it time to transfer the updated probabilities?
  if (this.updateCount < this.updateThresh) {
    return; //defer update
  }
  var cumProb, cumEscProb, odd, i, j, k;
  this.escape[0] = this.prob[0] = cumProb = cumEscProb = odd = 0;
  for (i=0; i < this.numSyms+1; i++) {
    var newProb = ((this.prob[i+1]-this.prob[i]) >>> 1) + this.update[i];
    if (newProb) {
      // live 'un
      this.prob[i] = cumProb;
      cumProb += newProb;
      if (newProb & 1) { odd++; }
      this.escape[i] = cumEscProb;
    } else {
      // this symbol will escape
      this.prob[i] = cumProb;
      this.escape[i] = cumEscProb;
      cumEscProb++;
    }
  }
  this.prob[i] = cumProb;
  console.assert(cumProb === PROB_TOTAL);
  /* how many updates will be required after current probs are halved? */
  this.updateThresh = PROB_TOTAL - Math.floor((cumProb-odd) / 2);
  /* reset the update table */
  for (i=0; i < (this.numSyms + 1); i++) {
    this.update[i] = 0;
  }
  this.update[this.numSyms] = 1; // ensure that escape never goes away
  this.updateCount = 1;
  /* compute decode table, if this is a decoder */
  if (!isDecoder) { return; }
  for (i=0, j=0, k=0; i<(this.numSyms+1); i++) {
    var probLimit = this.prob[i+1];
    for (; j<probLimit; j++) {
      this.probToSym[j] = i;
    }
    var escProbLimit = this.escape[i+1];
    for (; k<escProbLimit; k++) {
      this.escProbToSym[k] = i;
    }
  }
};
DefSumModel.prototype.encode = function(symbol) {
  var lt_f = this.prob[symbol];
  var sy_f = this.prob[symbol+1] - lt_f;
  console.assert(this.prob[this.numSyms+1] === PROB_TOTAL);
  if (sy_f) {
    this.coder.encodeShift(sy_f, lt_f, LOG_PROB_TOTAL);
    return this._update(symbol);
  }
  // escape!
  console.assert(symbol !== this.numSyms); // catch infinite recursion
  this.encode(this.numSyms); // guaranteed non-zero probability
  // code symbol as literal, taking advantage of reduced escape range.
  lt_f = this.escape[symbol];
  sy_f = this.escape[symbol+1] - lt_f;
  var tot_f = this.escape[this.numSyms];
  this.coder.encodeFreq(sy_f, lt_f, tot_f);
  return this._update(symbol);
};
DefSumModel.prototype.decode = function() {
  var prob = this.coder.decodeCulShift(LOG_PROB_TOTAL);
  var symbol = this.probToSym[prob];
  var lt_f = this.prob[symbol];
  var sy_f = this.prob[symbol+1] - lt_f;
  this.coder.decodeUpdate(sy_f, lt_f, PROB_TOTAL);
  this._update(symbol, true);
  if (symbol !== this.numSyms) {
    return symbol;
  }
  // escape!
  var tot_f = this.escape[this.numSyms];
  prob = this.coder.decodeCulFreq(tot_f);
  symbol = this.escProbToSym[prob];
  lt_f = this.escape[symbol];
  sy_f = this.escape[symbol+1] - lt_f;
  this.coder.decodeUpdate(sy_f, lt_f, tot_f);
  this._update(symbol, true);
  return symbol;
};

DefSumModel.MAGIC='dfsm';
/** Simple order-0 compressor, as self-test. */
DefSumModel.compressFile = Util.compressFileHelper(DefSumModel.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {
  var range = new RangeCoder(outStream);
  range.encodeStart(finalByte, 1);
  var model = new DefSumModel(range, (fileSize<0) ? 257 : 256);
  Util.compressWithModel(inStream, fileSize, model);
  range.encodeFinish();
},true);
/** Simple order-0 decompresser, as self-test. */
DefSumModel.decompressFile = Util.decompressFileHelper(DefSumModel.MAGIC, function(inStream, outStream, fileSize) {
  var range = new RangeCoder(inStream);
  range.decodeStart(true/*already read the final byte*/);
  var model = new DefSumModel(range, (fileSize<0) ? 257 : 256, true);
  Util.decompressWithModel(outStream, fileSize, model);
  range.decodeFinish();
});

module.exports = DefSumModel;

},{"./RangeCoder":20,"./Stream":22,"./Util":23}],9:[function(require,module,exports){
/**
 * Implementation of Dynamic Markov Compression, using byte-oriented
 * nodes/transitions.
 *
 * Currently no model-shrinking is done, so be careful trying to use
 * this on large inputs!
 *
 * Notes for the future / TO DO:
 *
 * Add node merging to Dmc:
 *  - once (total states traversed / total node count) exceeds a certain value
 *    - find the median node w/rt total visits
 *    - combine all nodes w/ less visits into a single node, with transitions
 *      to node[0] - node[255] (initial context-1 states)
 *      - initially transition counts are zero?  or summed from components?
 *        needs to be summed so kirchoff principle holds
 *    - halve the edge counts of all nodes, to provide for adaptation
 *      - enforce property that all nodes point "higher" except for
 *        links to nodes 0-255.  So we can resum all nodes in one pass,
 *        after resetting all node.sum to zero. X YES because we know
 *        what the total sum must be, so we can arrange to scale to maintain
 *        proper sum. XXX what about node 0-255? XXX maybe just clear all
 *        edge counts XXX
 *
 * Fix buglet: ensure that kirchoff principle *exactly* holds by
 * paying attention to rounding when we distribute edge counts.  track
 * highest edge and give (desiredSum - newSum) extra counts to that
 * outgoing edge? add one to each nonzero edge until all gone?
 *
 * Split 'to' nodes when to.sum grows too high -- only if we're
 * highest incoming edge?  Fix bug again here with saturating counts;
 * we can't ignore counts w/o violating kirchoff principle, so we need
 * to clone it.  Maybe start trying to clone early (before our counter
 * saturates) so we have a better chance of cloning on the high
 * incoming edge? XXX we don't track incoming edges.  XXX so just
 * clone when we visit.
 */
const MTFModel = require('./MTFModel');
const RangeCoder = require('./RangeCoder');
const Stream = require('./Stream');
const Util = require('./Util');

// nm = no model cloning, MAX_TRANS_CNT=0xFF, MAX_MODEL_PROB=0xFFFF
// nm2 = "                            0xFFFF                 0xFFFF
// nm3 = "                             0xFFF                 0x0FFF
// nm4 = "                            0xFFFF                   0xFF
// cl1 = model cloning, MAX_TRANS_CNT=0xFFFF  MAX_MODEL_PROB=0xFF
// cl2 = model cloning, MAX_TRANS_CNT=  0xFF  MAX_MODEL_PROB=0xFF
// cl3 = model cloning, MAX_TRANS_CNT=0xFFFF  MAX_MODEL_PROB=0xFFFF
var MAX_TRANS_CNT = 0xFFFF;
var DEFAULT_MIN_CNT1 = 8;
var DEFAULT_MIN_CNT2 = 128;
var MODEL_PROB_MAX = 0xFF00;
var MODEL_PROB_INCR= 0x0100;
var CLONE_MODELS=false;
var PRINT_STATS=false; // for quick benchmarking

// XXX need to limit growth of model (throw away and retrain if model
//     gets too large)

var Dmc = Object.create(null);
Dmc.MAGIC = 'dmc!';

var MarkovNode = function(coder, size, optModel) {
  this.out = [];
  this.model = optModel ? optModel.clone() :
    new MTFModel(coder, size, MODEL_PROB_MAX, MODEL_PROB_INCR);
  this.count = Util.makeU16Buffer(size);
  this.sum = 0;
};
MarkovNode.prototype.clone = function(coder, size) {
  var i;
  var newNode = new MarkovNode(coder, size, CLONE_MODELS ? this.model : null);
  for (i=0; i<size; i++) {
    newNode.out[i] = this.out[i];
  }
  return newNode;
};

var MarkovModel = function(coder, size, MIN_CNT1, MIN_CNT2) {
  var i, j;
  // initial model is 'size' states, completely linked.
  this.coder = coder;
  this.size = size;
  this.MIN_CNT1 = MIN_CNT1 || DEFAULT_MIN_CNT1;
  this.MIN_CNT2 = MIN_CNT2 || DEFAULT_MIN_CNT2;
  this.nodes = [];
  for (i=0; i<size; i++) {
    this.nodes[i] = new MarkovNode(coder, size);
  }
  // now link nodes
  for (i=0; i<size; i++) {
    for (j=0; j<size; j++) {
      this.nodes[i].out[j] = this.nodes[j];
    }
  }
  // select an arbitrary node as the start state.
  this.current = this.nodes[0];
};
MarkovModel.prototype.maybeSplit = function(from, symbol, to) {
  var trans_cnt = from.count[symbol];
  var next_cnt = to.sum;
  var i;
  if ( (trans_cnt <= this.MIN_CNT1) ||
       (next_cnt - trans_cnt <= this.MIN_CNT2) ) {
    return to; // no split
  }

  // split this guy!
  var newNode = to.clone(this.coder, this.size);
  this.nodes.push(newNode);
  from.out[symbol] = newNode;
  // distribute transition counts among new and cloned node
  newNode.sum = to.sum = 0;
  for (i=0; i<this.size; i++) {
    newNode.count[i] = to.count[i] * trans_cnt / next_cnt;
    newNode.sum += newNode.count[i];
    to.count[i] -= newNode.count[i];
    to.sum += to.count[i];
  }

  return newNode;
};
MarkovModel.prototype.encode = function(symbol) {
  var from = this.current;
  from.model.encode(symbol);
  var to = from.out[symbol];
  if (from.count[symbol] !== MAX_TRANS_CNT) {
      from.count[symbol]++;
      from.sum++;
  }
  this.current = this.maybeSplit(from, symbol, to);
};
MarkovModel.prototype.decode = function() {
  var from = this.current;
  var symbol = from.model.decode();
  var to = from.out[symbol];
  if (from.count[symbol] !== MAX_TRANS_CNT) {
      from.count[symbol]++;
      from.sum++;
  }
  this.current = this.maybeSplit(from, symbol, to);
  return symbol;
};

Dmc.compressFile = Util.compressFileHelper(Dmc.MAGIC, function(inStream, outStream, fileSize, props) {

  props = props || {};
  var MIN_CNT1 = (+props.m) || DEFAULT_MIN_CNT1;
  var MIN_CNT2 = (+props.n) || DEFAULT_MIN_CNT2;
  Util.writeUnsignedNumber(outStream, MIN_CNT1);
  Util.writeUnsignedNumber(outStream, MIN_CNT2);

  var range = new RangeCoder(outStream);
  range.encodeStart(0xCA, 0);

  var mm = new MarkovModel(range, (fileSize<0) ? 257 : 256,
                           MIN_CNT1, MIN_CNT2);
  var inSize = 0;
  while (inSize !== fileSize) {
    var ch = inStream.readByte();
    if (ch===Stream.EOF) {
      mm.encode(256); // end of stream
      break;
    }
    mm.encode(ch);
    inSize++;
  }
  var outSize = range.encodeFinish();
  if (PRINT_STATS) {
    console.log('M1', mm.MIN_CNT1, 'M2', mm.MIN_CNT2,
                'states', mm.nodes.length, 'size', outSize);
  }
});

Dmc.decompressFile = Util.decompressFileHelper(Dmc.MAGIC, function(inStream, outStream, fileSize) {

  var MIN_CNT1 = Util.readUnsignedNumber(inStream);
  var MIN_CNT2 = Util.readUnsignedNumber(inStream);

  var range = new RangeCoder(inStream);
  range.decodeStart();

  var mm = new MarkovModel(range, (fileSize<0) ? 257 : 256,
                           MIN_CNT1, MIN_CNT2);
  var outSize = 0;
  while (outSize !== fileSize) {
    var ch = mm.decode();
    if (ch===256) {
      break; // EOF
    }
    outStream.writeByte(ch);
    outSize++;
  }
  range.decodeFinish();
});

module.exports = Dmc;

},{"./MTFModel":17,"./RangeCoder":20,"./Stream":22,"./Util":23}],10:[function(require,module,exports){
/** Range coding model based on Fenwick trees for O(ln N) query/update. */
const RangeCoder = require('./RangeCoder');
const Stream = require('./Stream');
const Util = require('./Util');

/** We store two probabilities in a U32, so max prob is going to be 0xFFFF */
var DEFAULT_MAX_PROB = 0xFF00;
var DEFAULT_INCREMENT= 0x0100;

var ESC_MASK = 0x0000FFFF, ESC_SHIFT = 0;
var SYM_MASK = 0xFFFF0000, SYM_SHIFT = 16;
var SCALE_MASK=0xFFFEFFFE;

var FenwickModel = function(coder, size, max_prob, increment) {
    this.coder = coder;
    this.numSyms = size + 1; // save space for an escape symbol
    this.tree = Util.makeU32Buffer(this.numSyms*2);
    this.increment = (+increment) || DEFAULT_INCREMENT;
    this.max_prob = (+max_prob) || DEFAULT_MAX_PROB;
    // sanity-check to prevent overflow.
    console.assert((this.max_prob + (this.increment-1)) <= 0xFFFF);
    console.assert(size <= 0xFFFF);
    // record escape probability as 1.
    var i;
    for (i=0; i<size; i++) {
        this.tree[this.numSyms + i] = // escape prob=1, sym prob = 0
            (1 << ESC_SHIFT) | (0 << SYM_SHIFT);
    }
    this.tree[this.numSyms + i] = // escape prob = 0, sym prob = 1
        (0 << ESC_SHIFT) | (this.increment << SYM_SHIFT);
    this._sumTree();
    // probability sums are in this.tree[1].  this.tree[0] is unused.
};
FenwickModel.factory = function(coder, max_prob, increment) {
    return function(size) {
        return new FenwickModel(coder, size, max_prob, increment);
    };
};
FenwickModel.prototype.clone = function() {
    var newModel = new FenwickModel(this.coder, this.size,
                                    this.max_prob, this.increment);
    var i;
    for (i=1; i<this.tree.length; i++) {
        newModel.tree[i] = this.tree[i];
    }
    return newModel;
};
FenwickModel.prototype.encode = function(symbol) {
    var i = this.numSyms + symbol;
    var sy_f = this.tree[i];
    var mask = SYM_MASK, shift = SYM_SHIFT;
    var update = (this.increment << SYM_SHIFT);

    if ((sy_f & SYM_MASK) === 0) { // escape!
        this.encode(this.numSyms-1);
        mask = ESC_MASK;
        update -= (1<<ESC_SHIFT); // not going to escape no mo'
        shift = ESC_SHIFT;
    } else if (symbol === (this.numSyms-1) &&
            ((this.tree[1] & ESC_MASK) >>> ESC_SHIFT) === 1) {
        // this is the last escape, zero it out
        update = -this.tree[i];
    }
    // sum up the proper lt_f
    var lt_f = 0;
    while (i > 1) {
        var isRight = (i & 1);
        var parent = (i >>> 1);
        // if we're the right child, we need to
        // add the prob from the left child
        if (isRight) {
            lt_f += this.tree[2*parent];
        }
        // update sums
        this.tree[i] += update; // increase sym / decrease esc
        i = parent;
    }
    var tot_f = this.tree[1];
    this.tree[1] += update; // update prob in root
    sy_f = (sy_f & mask) >>> shift;
    lt_f = (lt_f & mask) >>> shift;
    tot_f =(tot_f& mask) >>> shift;
    this.coder.encodeFreq(sy_f, lt_f, tot_f);
    // rescale?
    if ((( this.tree[1] & SYM_MASK ) >>> SYM_SHIFT) >= this.max_prob) {
        this._rescale();
    }
};
FenwickModel.prototype._decode = function(isEscape) {
    var mask = SYM_MASK, shift = SYM_SHIFT;
    var update = (this.increment << SYM_SHIFT);
    if (isEscape) {
        mask = ESC_MASK;
        update -= (1 << ESC_SHIFT);
        shift = ESC_SHIFT;
    }
    var tot_f = (this.tree[1] & mask) >>> shift;
    var prob = this.coder.decodeCulFreq(tot_f);
    // travel down the tree looking for this
    var i = 1, lt_f = 0;
    while (i < this.numSyms) {
        this.tree[i] += update;
        // look at probability in left child.
        var leftProb = (this.tree[2*i] & mask) >>> shift;
        i *= 2;
        if ((prob-lt_f) >= leftProb) {
            lt_f += leftProb;
            i++; // take the right child.
        }
    }
    var symbol = i - this.numSyms;
    var sy_f = (this.tree[i] & mask) >>> shift;
    this.tree[i] += update;
    this.coder.decodeUpdate(sy_f, lt_f, tot_f);
    // was this the last escape?
    if (symbol === (this.numSyms-1) &&
        ((this.tree[1] & ESC_MASK) >>> ESC_SHIFT) === 1) {
        update = -this.tree[i]; // zero it out
        while (i >= 1) {
            this.tree[i] += update;
            i = (i >>> 1); // parent
        }
    }
    // rescale?
    if ((( this.tree[1] & SYM_MASK ) >>> SYM_SHIFT) >= this.max_prob) {
        this._rescale();
    }
    return symbol;
};
FenwickModel.prototype.decode = function() {
    var symbol = this._decode(false); // not escape
    if (symbol === (this.numSyms-1)) {
        // this was an escape!
        symbol = this._decode(true); // an escape!
    }
    return symbol;
};
FenwickModel.prototype._rescale = function() {
    var i, prob, noEscape = true;
    // scale symbols (possible causing them to escape)
    for (i=0; i < this.numSyms-1; i++) {
        prob = this.tree[this.numSyms + i];
        if ((prob & ESC_MASK) !== 0) {
            // this symbol escapes
            noEscape = false;
            continue;
        }
        prob = (prob & SCALE_MASK) >>> 1;
        if (prob === 0) {
            // this symbol newly escapes
            prob = (1 << ESC_SHIFT);
            noEscape = false;
        }
        this.tree[this.numSyms + i] = prob;
    }
    // scale the escape symbol
    prob = this.tree[this.numSyms + i];
    prob = (prob & SCALE_MASK) >>> 1;
    // prob should be zero if there are no escaping symbols, otherwise
    // it must be at least 1.
    if (noEscape) { prob = 0; }
    else if (prob === 0) { prob = (1 << SYM_SHIFT); }
    this.tree[this.numSyms + i] = prob;
    // sum it all up afresh
    this._sumTree();
};
FenwickModel.prototype._sumTree = function() {
    var i;
    // sum it all. (we know we won't overflow)
    for (i=this.numSyms - 1; i > 0; i--) {
        this.tree[i] = this.tree[2*i] + this.tree[2*i + 1];
    }
};

FenwickModel.MAGIC = 'fenw';
/** Simple order-0 compressor, as self-test. */
FenwickModel.compressFile = Util.compressFileHelper(FenwickModel.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {
    var range = new RangeCoder(outStream);
    range.encodeStart(finalByte, 1);
    var model = new FenwickModel(range, (fileSize<0) ? 257 : 256);
    Util.compressWithModel(inStream, fileSize, model);
    range.encodeFinish();
}, true);

/** Simple order-0 decompresser, as self-test. */
FenwickModel.decompressFile = Util.decompressFileHelper(FenwickModel.MAGIC, function(inStream, outStream, fileSize) {
    var range = new RangeCoder(inStream);
    range.decodeStart(true/*already read the final byte*/);
    var model = new FenwickModel(range, (fileSize<0) ? 257 : 256);
    Util.decompressWithModel(outStream, fileSize, model);
    range.decodeFinish();
});

module.exports = FenwickModel;

},{"./RangeCoder":20,"./Stream":22,"./Util":23}],11:[function(require,module,exports){
/* Adaptive Huffman code, using Vitter's algorithm ported from
 * vitter.c at http://code.google.com/p/compression-code/downloads/list
 * The original code was placed in the public domain, and so I
 * also place this JavaScript port in the public domain.
 *   -- C. Scott Ananian <cscott@cscott.net>, 2013
 * ps. some truly grotty C code in the originally, faithfully ported to
 *     evil comma-operator-using, assignment-in-if-condition JavaScript.
 */
const BitStream = require('./BitStream');
const Util = require('./Util');

//  This code is adapted from Professor Vitter's
//  article, Design and Analysis of Dynamic Huffman Codes,
//  which appeared in JACM October 1987

//  A design trade-off has been made to simplify the
//  code:  a node's block is determined dynamically,
//  and the implicit tree structure is maintained,
//  e.g. explicit node numbers are also implicit.

//  Dynamic Huffman table weight ranking
//  is maintained per Professor Vitter's
//  invariant (*) for algorithm FGK:

//  leaves precede internal nodes of the
//  same weight in a non-decreasing ranking
//  of weights using implicit node numbers:

//  1) leaves slide over internal nodes, internal nodes
//  swap over groups of leaves, leaves are swapped
//  into group leader position, but two internal
//  nodes never change positions relative
//  to one another.

//  2) weights are incremented by 2:
//  leaves always have even weight values;
//  internal nodes always have odd values.

//  3) even node numbers are always right children;
//  odd numbers are left children in the tree.

//  node 2 * HuffSize - 1 is always the tree root;
//  node HuffEsc is the escape node;

//  the tree is initialized by creating an
//  escape node as the root.

//  each new leaf symbol is paired with a new escape
//  node into the previous escape node in the tree,
//  until the last symbol which takes over the
//  tree position of the escape node, and
//  HuffEsc is left at zero.

//  overall table size: 2 * HuffSize

//  huff_init(alphabet_size, potential symbols used)
//  huff_encode(next_symbol)
//  next_symbol = huff_decode()

//  huff_scale(by_bits) -- scale weights and re-balance tree

var HTable = function(up, down, symbol, weight) {
    this.up = up; // next node up the tree
    this.down = down; // pair of down nodes
    this.symbol = symbol;       // node symbol value
    this.weight = weight;       // node weight
};
HTable.prototype.clone = function() {
  return new HTable(this.up, this.down, this.symbol, this.weight);
};
HTable.prototype.set = function(htable) {
  this.up = htable.up;
  this.down = htable.down;
  this.symbol = htable.symbol;
  this.weight = htable.weight;
};

//  initialize an adaptive coder
//  for alphabet size, and count
//  of nodes to be used
var Huffman = function(size, root, bitstream, max_weight) {
  var i;
  //  default: all alphabet symbols are used

  console.assert(size && typeof(size)==='number');
  if( !root || root > size )
      root = size;

  //  create the initial escape node
  //  at the tree root

  if ( root <<= 1 ) {
      root--;
  }

  // create root+1 htables (coding table)
  // XXX this could be views on a backing Uint32 array?
  this.table = [];
  for (i=0; i<=root; i++) {
    this.table[i] = new HTable(0,0,0,0);
  }

  // this.map => mapping for symbols to nodes
  this.map = [];
  // this.size => the alphabet size
  if( this.size = size ) {
    for (i=0; i<size; i++) {
      this.map[i] = 0;
    }
  }

  // this.esc  => the current tree height
  // this.root => the root of the tree
  this.esc = this.root = root;

  if (bitstream) {
    this.readBit = bitstream.readBit.bind(bitstream);
    this.writeBit = bitstream.writeBit.bind(bitstream);
  }
  this.max_weight = max_weight; // may be null or undefined
}
// factory interface
Huffman.factory = function(bitstream, max_weight) {
  return function(size) {
    return new Huffman(size, size, bitstream, max_weight);
  };
};


// split escape node to incorporate new symbol

Huffman.prototype.split = function(symbol) {
  var pair, node;

  //  is the tree already full???

  if( pair = this.esc ) {
    this.esc--;
  } else {
    console.assert(false);
    return 0;
  }

  //  if this is the last symbol, it moves into
  //  the escape node's old position, and
  //  this.esc is set to zero.

  //  otherwise, the escape node is promoted to
  //  parent a new escape node and the new symbol.

  if( node = this.esc ) {
    this.table[pair].down = node;
    this.table[pair].weight = 1;
    this.table[node].up = pair;
    this.esc--;
  } else {
    pair = 0;
    node = 1;
  }

  //  initialize the new symbol node

  this.table[node].symbol = symbol;
  this.table[node].weight = 0;
  this.table[node].down = 0;
  this.map[symbol] = node;

  //  initialize a new escape node.

  this.table[this.esc].weight = 0;
  this.table[this.esc].down = 0;
  this.table[this.esc].up = pair;
  return node;
};

//  swap leaf to group leader position
//  return symbol's new node

Huffman.prototype.leader = function(node) {
  var weight = this.table[node].weight;
  var leader = node, prev, symbol;

  while( weight === this.table[leader + 1].weight ) {
    leader++;
  }

  if( leader === node ) {
    return node;
  }

  // swap the leaf nodes

  symbol = this.table[node].symbol;
  prev = this.table[leader].symbol;

  this.table[leader].symbol = symbol;
  this.table[node].symbol = prev;
  this.map[symbol] = leader;
  this.map[prev] = node;
  return leader;
};

//  slide internal node up over all leaves of equal weight;
//  or exchange leaf with next smaller weight internal node

//  return node's new position

Huffman.prototype.slide = function(node) {
  var next = node;
  var swap;

  swap = this.table[next++].clone();

  // if we're sliding an internal node, find the
  // highest possible leaf to exchange with

  if( swap.weight & 1 ) {
    while( swap.weight > this.table[next + 1].weight ) {
      next++;
    }
  }

  //  swap the two nodes

  this.table[node].set(this.table[next]);
  this.table[next].set(swap);

  this.table[next].up = this.table[node].up;
  this.table[node].up = swap.up;

  //  repair the symbol map and tree structure

  if( swap.weight & 1 ) {
    this.table[swap.down].up = next;
    this.table[swap.down - 1].up = next;
    this.map[this.table[node].symbol] = node;
  } else {
    this.table[this.table[node].down - 1].up = node;
    this.table[this.table[node].down].up = node;
    this.map[swap.symbol] = next;
  }

  return next;
};

//  increment symbol weight and re balance the tree.

Huffman.prototype.increment = function(node) {
  var up;

  //  obviate swapping a parent with its child:
  //    increment the leaf and proceed
  //    directly to its parent.

  //  otherwise, promote leaf to group leader position in the tree

  if( this.table[node].up === node + 1 ) {
    this.table[node].weight += 2;
    node++;
  } else {
    node = this.leader (node);
  }

  //  increase the weight of each node and slide
  //  over any smaller weights ahead of it
  //  until reaching the root

  //  internal nodes work upwards from
  //  their initial positions; while
  //  symbol nodes slide over first,
  //  then work up from their final
  //  positions.

  while( this.table[node].weight += 2, up = this.table[node].up ) {
    while( this.table[node].weight > this.table[node + 1].weight ) {
        node = this.slide (node);
    }

    if( this.table[node].weight & 1 ) {
        node = up;
    } else {
        node = this.table[node].up;
    }
  }

  /* Re-scale if necessary. */
  if (this.max_weight) {
    if (this.table[this.root].weight >= this.max_weight) {
      this.scale(1);
    }
  }
};

//  scale all weights and re-balance the tree

//  zero weight nodes are removed from the tree
//  by sliding them out the left of the rank list

Huffman.prototype.scale = function(bits) {
  var node = this.esc, weight, prev;

  //  work up the tree from the escape node
  //  scaling weights by the value of bits

  while( ++node <= this.root ) {
    //  recompute the weight of internal nodes;
    //  slide down and out any unused ones

    if( this.table[node].weight & 1 ) {
      if( weight = this.table[this.table[node].down].weight & ~1 ) {
        weight += this.table[this.table[node].down - 1].weight | 1;
      }

      //  remove zero weight leaves by incrementing HuffEsc
      //  and removing them from the symbol map.  take care

    } else if( !(weight = this.table[node].weight >> bits & ~1) ) {
      if( this.map[this.table[node].symbol] = 0, this.esc++ ) {
        this.esc++;
      }
    }

    // slide the scaled node back down over any
    // previous nodes with larger weights

    this.table[node].weight = weight;
    prev = node;

    while( weight < this.table[--prev].weight ) {
      this.slide(prev);
    }
  }

  // prepare a new escape node

  this.table[this.esc].down = 0;
};

//  send the bits for an escaped symbol

Huffman.prototype.sendid = function(symbol) {
  var empty = 0, max;

  //  count the number of empty symbols
  //  before the symbol in the table

  while( symbol-- ) {
    if( !this.map[symbol] ) {
      empty++;
    }
  }

  //  send LSB of this count first, using
  //  as many bits as are required for
  //  the maximum possible count

  if( max = this.size - Math.floor((this.root - this.esc) / 2) - 1 ) {
    do {
      this.writeBit(empty & 1);
      empty >>= 1;
    } while( max >>= 1 );
  }
};

//  encode the next symbol

Huffman.prototype.encode = function(symbol) {
  var emit = 1, bit;
  var up, idx, node;

  if( symbol < this.size ) {
    node = this.map[symbol];
  } else {
    console.assert(false);
    return;
  }

  //  for a new symbol, direct the receiver to the escape node
  //  but refuse input if table is already full.

  if( !(idx = node) ) {
    if( !(idx = this.esc) ) {
      return;
    }
  }

  //  accumulate the code bits by
  //  working up the tree from
  //  the node to the root

  while( up = this.table[idx].up ) {
    emit <<= 1; emit |= idx & 1; idx = up;
  }

  //  send the code, root selector bit first

  while( bit = emit & 1, emit >>= 1 ) {
    this.writeBit(bit);
  }

  //  send identification and incorporate
  //  new symbols into the tree

  if( !node ) {
    this.sendid(symbol);
    node = this.split(symbol);
  }

  //  adjust and re-balance the tree

  this.increment(node);
};

//  read the identification bits
//  for an escaped symbol

Huffman.prototype.readid = function() {
  var empty = 0, bit = 1, max, symbol;

  //  receive the symbol, LSB first, reading
  //  only the number of bits necessary to
  //  transmit the maximum possible symbol value

  if( max = this.size - Math.floor((this.root - this.esc) / 2) - 1 ) {
    do {
      empty |= this.readBit() ? bit : 0;
      bit <<= 1;
    } while( max >>= 1 );
  }

  //  the count is of unmapped symbols
  //  in the table before the new one

  for( symbol = 0; symbol < this.size; symbol++ ) {
    if( !this.map[symbol] ) {
      if( !empty-- ) {
        return symbol;
      }
    }
  }

  //  oops!  our count is too big, either due
  //  to a bit error, or a short node count
  //  given to huff_init.

  console.assert(false);
  return 0;
};

//  decode the next symbol

Huffman.prototype.decode = function() {
  var node = this.root;
  var symbol, down;

  //  work down the tree from the root
  //  until reaching either a leaf
  //  or the escape node.  A one
  //  bit means go left, a zero
  //  means go right.

  while( down = this.table[node].down ) {
    if( this.readBit() ) {
      node = down - 1;  // the left child precedes the right child
    } else {
      node = down;
    }
  }

  //  sent to the escape node???
  //  refuse to add to a full tree

  if( node === this.esc ) {
    if( this.esc ) {
      symbol = this.readid ();
      node = this.split (symbol);
    } else {
      console.assert(false);
      return 0;
    }
  } else {
    symbol = this.table[node].symbol;
  }

  //  increment weights and re-balance
  //  the coding tree

  this.increment (node);
  return symbol;
};

// stand alone compressor, mostly for testing
Huffman.MAGIC = 'huff';
Huffman.compressFile = Util.compressFileHelper(Huffman.MAGIC, function(input, output, size, props) {
  var bitstream = new BitStream(output);

  var alphabetSize = 256;
  if (size < 0) { alphabetSize++; }
  var huff = new Huffman(257, alphabetSize, bitstream, 8191);
  Util.compressWithModel(input, size, huff);
  bitstream.flush();
});

// stand alone decompresser, again for testing
Huffman.decompressFile = Util.decompressFileHelper(Huffman.MAGIC, function(input, output, size) {
  var bitstream = new BitStream(input);

  var alphabetSize = 256;
  if (size < 0) { alphabetSize++; }
  var huff = new Huffman(257, alphabetSize, bitstream, 8191);
  Util.decompressWithModel(output, size, huff);
});

module.exports = Huffman;

},{"./BitStream":4,"./Util":23}],12:[function(require,module,exports){
/**
 * An in-place, length restricted Canonical Huffman code length allocator
 *
 * Based on the algorithm proposed by R. L. Milidiú, A. A. Pessoa and
 * E. S. Laber in "In-place Length-Restricted Prefix Coding" (see:
 * http://www-di.inf.puc-rio.br/~laber/public/spire98.ps) and
 * incorporating additional ideas from the implementation of "shcodec"
 * by Simakov Alexander (see: http://webcenter.ru/~xander/)
 *
 * This JavaScript implementation ported from HuffmanAllocator.java from
 *   https://code.google.com/p/jbzip2
 * which is:
 *
 *   Copyright (c) 2011 Matthew Francis
 *
 *   Permission is hereby granted, free of charge, to any person
 *   obtaining a copy of this software and associated documentation
 *   files (the "Software"), to deal in the Software without
 *   restriction, including without limitation the rights to use,
 *   copy, modify, merge, publish, distribute, sublicense, and/or sell
 *   copies of the Software, and to permit persons to whom the
 *   Software is furnished to do so, subject to the following
 *   conditions:
 *
 *   The above copyright notice and this permission notice shall be
 *   included in all copies or substantial portions of the Software.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 *   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 *   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 *   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 *   OTHER DEALINGS IN THE SOFTWARE.
 *
 * This JavaScript implementation is:
 *   Copyright (c) 2013 C. Scott Ananian
 * with the same licensing terms as Matthew Francis' original implementation.
 */
const freeze = require('./freeze');
const Util = require('./Util');

/**
 * FIRST() function
 * @param array The code length array
 * @param i The input position
 * @param nodesToMove The number of internal nodes to be relocated
 * @return The smallest {@code k} such that {@code nodesToMove <= k <= i} and
 *         {@code i <= (array[k] % array.length)}
 */
var first = function(array, i, nodesToMove) {
var length = array.length;
var limit = i;
var k = array.length - 2;

while ((i >= nodesToMove) && ((array[i] % length) > limit)) {
    k = i;
    i -= (limit - i + 1);
}
i = Math.max (nodesToMove - 1, i);

while (k > (i + 1)) {
    var temp = (i + k) >> 1;
    if ((array[temp] % length) > limit) {
    k = temp;
    } else {
    i = temp;
    }
}

return k;
};

/**
 * Fills the code array with extended parent pointers
 * @param array The code length array
 */
var setExtendedParentPointers = function(array) {
var length = array.length;

array[0] += array[1];

var headNode, tailNode, topNode, temp;
for (headNode = 0, tailNode = 1, topNode = 2;
        tailNode < (length - 1);
        tailNode++) {
    if ((topNode >= length) || (array[headNode] < array[topNode])) {
    temp = array[headNode];
    array[headNode++] = tailNode;
    } else {
    temp = array[topNode++];
    }

    if ((topNode >= length) ||
        ((headNode < tailNode) && (array[headNode] < array[topNode]))) {
    temp += array[headNode];
    array[headNode++] = tailNode + length;
    } else {
    temp += array[topNode++];
    }

    array[tailNode] = temp;
}
};

/**
 * Finds the number of nodes to relocate in order to achieve a given code
 * length limit
 * @param array The code length array
 * @param maximumLength The maximum bit length for the generated codes
 * @return The number of nodes to relocate
 */
var findNodesToRelocate = function(array, maximumLength) {
var currentNode = array.length - 2;
var currentDepth;
for (currentDepth = 1;
        (currentDepth < (maximumLength - 1)) && (currentNode > 1);
        currentDepth++) {
    currentNode =  first (array, currentNode - 1, 0);
}

return currentNode;
};


/**
 * A final allocation pass with no code length limit
 * @param array The code length array
 */
var allocateNodeLengths = function(array) {
var firstNode = array.length - 2;
var nextNode = array.length - 1;
var currentDepth, availableNodes, lastNode, i;

for (currentDepth = 1, availableNodes = 2;
        availableNodes > 0;
        currentDepth++) {
    lastNode = firstNode;
    firstNode = first (array, lastNode - 1, 0);

    for (i = availableNodes - (lastNode - firstNode); i > 0; i--) {
    array[nextNode--] = currentDepth;
    }

    availableNodes = (lastNode - firstNode) << 1;
}
};

/**
 * A final allocation pass that relocates nodes in order to achieve a
 * maximum code length limit
 * @param array The code length array
 * @param nodesToMove The number of internal nodes to be relocated
 * @param insertDepth The depth at which to insert relocated nodes
 */
var allocateNodeLengthsWithRelocation = function(array, nodesToMove,
                                                insertDepth) {
var firstNode = array.length - 2;
var nextNode = array.length - 1;
var currentDepth = (insertDepth == 1) ? 2 : 1;
var nodesLeftToMove = (insertDepth == 1) ? nodesToMove - 2 : nodesToMove;
var availableNodes, lastNode, offset, i;

for (availableNodes = currentDepth << 1;
        availableNodes > 0;
        currentDepth++) {
    lastNode = firstNode;
    firstNode = (firstNode <= nodesToMove) ? firstNode : first (array, lastNode - 1, nodesToMove);

    offset = 0;
    if (currentDepth >= insertDepth) {
    offset = Math.min (nodesLeftToMove, 1 << (currentDepth - insertDepth));
    } else if (currentDepth == (insertDepth - 1)) {
    offset = 1;
    if ((array[firstNode]) == lastNode) {
        firstNode++;
    }
    }

    for (i = availableNodes - (lastNode - firstNode + offset); i > 0; i--) {
    array[nextNode--] = currentDepth;
    }

    nodesLeftToMove -= offset;
    availableNodes = (lastNode - firstNode + offset) << 1;
}
};

/**
 * Allocates Canonical Huffman code lengths in place based on a sorted
 * frequency array
 * @param array On input, a sorted array of symbol frequencies; On output,
 *              an array of Canonical Huffman code lengths
 * @param maximumLength The maximum code length. Must be at least
 *                      {@code ceil(log2(array.length))}
 */
// public
var allocateHuffmanCodeLengths = function(array, maximumLength) {
switch (array.length) {
case 2:
    array[1] = 1;
case 1:
    array[0] = 1;
    return;
}

/* Pass 1 : Set extended parent pointers */
setExtendedParentPointers (array);

/* Pass 2 : Find number of nodes to relocate in order to achieve
    *          maximum code length */
var nodesToRelocate = findNodesToRelocate (array, maximumLength);

/* Pass 3 : Generate code lengths */
if ((array[0] % array.length) >= nodesToRelocate) {
    allocateNodeLengths (array);
} else {
    var insertDepth = maximumLength - (Util.fls(nodesToRelocate - 1));
    allocateNodeLengthsWithRelocation (array, nodesToRelocate, insertDepth);
}
};

module.exports = freeze({
    allocateHuffmanCodeLengths: allocateHuffmanCodeLengths
});

},{"./Util":23,"./freeze":24}],13:[function(require,module,exports){
/** Simple (log n)(n) distance model. */
const Util = require('./Util');

// lengthBitsModelFactory will be called with arguments 2, 4, 8, 16, etc
// and must return an appropriate model or coder.
var LogDistanceModel = function(size, extraStates,
                                lgDistanceModelFactory,
                                lengthBitsModelFactory) {
    var i;
    var bits = Util.fls(size-1);
    this.extraStates = +extraStates || 0;
    this.lgDistanceModel = lgDistanceModelFactory(1 + bits + extraStates);
    // this.distanceModel[n] used for distances which are n-bits long,
    // but only n-1 bits are encoded: the top bit is known to be one.
    this.distanceModel = [];
    for (i=2 ; i <= bits; i++) {
        var numBits = i - 1;
        this.distanceModel[i] = lengthBitsModelFactory(1<<numBits);
    }
};
/* you can give this model arguments between 0 and (size-1), or else
    a negative argument which is one of the 'extra states'. */
LogDistanceModel.prototype.encode = function(distance) {
    if (distance < 2) { // small distance or an 'extra state'
        this.lgDistanceModel.encode(distance + this.extraStates);
        return;
    }
    var lgDistance = Util.fls(distance);
    console.assert(distance & (1<<(lgDistance-1))); // top bit is set
    console.assert(lgDistance >= 2);
    this.lgDistanceModel.encode(lgDistance + this.extraStates);
    // now encode the rest of the bits.
    var rest = distance & ((1 << (lgDistance-1)) - 1);
    this.distanceModel[lgDistance].encode(rest);
};
LogDistanceModel.prototype.decode = function() {
    var lgDistance = this.lgDistanceModel.decode() - this.extraStates;
    if (lgDistance < 2) {
        return lgDistance; // this is a small distance or an 'extra state'
    }
    var rest = this.distanceModel[lgDistance].decode();
    return (1 << (lgDistance-1)) + rest;
};
module.exports = LogDistanceModel;

},{"./Util":23}],14:[function(require,module,exports){
/* LZJB compression: http://en.wikipedia.org/wiki/LZJB */
const Stream = require('./Stream');
const Util = require('./Util');

/**
$Id: Iuppiter.js 3026 2010-06-23 10:03:13Z Bear $

Copyright (c) 2010 Nuwa Information Co., Ltd, and individual contributors.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

  1. Redistributions of source code must retain the above copyright notice,
     this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the distribution.

  3. Neither the name of Nuwa Information nor the names of its contributors
     may be used to endorse or promote products derived from this software
     without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

$Author: Bear $
$Date: 2010-06-23 18:03:13 +0800 (星期三, 23 六月 2010) $
$Revision: 3026 $
*/

var Lzjb = Object.create(null);
Lzjb.MAGIC = 'lzjb';

// Constants was used for compress/decompress function.
var NBBY = 8,
    MATCH_BITS = 6,
    MATCH_MIN = 3,
    MATCH_MAX = ((1 << MATCH_BITS) + (MATCH_MIN - 1)),
    OFFSET_MASK = ((1 << (16 - MATCH_BITS)) - 1),
    LEMPEL_SIZE_BASE = 1024;
var EOF = Stream.EOF;

// set C_COMPAT to true if you need to decompress with the (untweaked) C lzjb
// implementation, which breaks if offset==0; the javascript
// implementation uses 0 to indicate an offset of OFFSET_MASK+1.
var C_COMPAT = true;

/**
 * Compress string or byte array using fast and efficient algorithm.
 *
 * Because of weak of javascript's natural, many compression algorithm
 * become useless in javascript implementation. The main problem is
 * performance, even the simple Huffman, LZ77/78 algorithm will take many
 * many time to operate. We use LZJB algorithm to do that, it suprisingly
 * fulfills our requirement to compress string fastly and efficiently.
 *
 * Our implementation is based on
 * http://src.opensolaris.org/source/raw/onnv/onnv-gate/usr/src/uts/common/fs/zfs/lzjb.c
 * and
 * http://src.opensolaris.org/source/raw/onnv/onnv-gate/usr/src/uts/common/os/compress.c
 * It is licensed under CDDL.
 *
 * @param {Array|Uint8Array|Buffer|stream} input The stream or byte array
 *        that you want to compress.
 * @param {stream} output Optional output stream.
 * @return {Array|Uint8Array|Buffer} Compressed byte array, or 'output'
 */
Lzjb.compressFile = Util.compressFileHelper(Lzjb.MAGIC, function(inStream, outStream, fileSize, props) {
    var sstart, dstart = [], slen,
        src = 0, dst = 0,
        cpy, copymap,
        mlen, offset,
        hash, hp,
        lempel,
        i, j;
    var retval;

    // in an improvement over the original C implementation, we expand
    // the hash table to track a number of potential matches, not just the
    // most recent.  This doesn't require any changes to the decoder.
    // Sample impact on compression size (on wikipedia data):
    //  EXPAND  Time     Size      Option
    //    1   0m20.321s  50185613    -1
    //    2   0m22.437s  46503301    -2
    //    3   0m23.773s  45744564    -3
    //    4   0m25.666s  45199866    -4
    //    5   0m35.810s  44821413    -5
    //    6   0m40.947s  44666638    -6
    //    8   0m49.639s  44413865    -7
    //   12   0m49.927s  44124825    -8
    //   16   1m01.180s  43972515    -9
    //   32   1m30.530s  43554099
    //   64   2m14.504s  43005530
    //  128   3m43.570s  42361718
    //  256   6m38.681s  41684853
    var LEMPEL_SIZE = LEMPEL_SIZE_BASE;
    var EXPAND = 1; // default to original C impl
    if (typeof(props)==='number') {
        LEMPEL_SIZE *= 2;
        props = Math.max(1, Math.min(9, props)) - 1;
        EXPAND = 1<<Math.floor(props/2);
        if (props&1) EXPAND = Math.round(EXPAND * 1.5);
        if (props >=2 && props <= 4) EXPAND++;
    }

    // use Uint16Array if available (zero-filled)
    lempel = Util.makeU16Buffer(LEMPEL_SIZE * EXPAND);

    var window = Util.makeU8Buffer(OFFSET_MASK+1);
    var windowpos = 0;
    var winput = function(_byte) {
        window[windowpos++] = _byte;
        if (windowpos >= window.length) {
            windowpos = 0;
        }
        return _byte;
    };

    var outwindow = Util.makeU8Buffer(17);
    var outpos = 0;
    var dumpout = function() {
        var i;
        for (i=0; i<outpos; i++) {
            outStream.writeByte(outwindow[i]);
        }
        outpos = 0;
    };

    var unbuffer = [];
    var get = function() {
        if (unbuffer.length)
            return unbuffer.pop();
        return inStream.readByte();
    };
    var unget = function(_byte) {
        unbuffer.push(_byte);
    };

    var copymask = 1 << (NBBY - 1);
    var matchpossibility = [];
    while (true) {
        var c1 = get();
        if (c1 === EOF) break;

        if ((copymask <<= 1) == (1 << NBBY)) {
            dumpout();
            copymask = 1;
            outwindow[0] = 0;
            outpos = 1;
        }

        var c2 = get();
        if (c2 === EOF) {
            outwindow[outpos++] = winput(c1);
            break;
        }
        var c3 = get();
        if (c3 === EOF) {
            outwindow[outpos++] = winput(c1);
            unget(c2);
            continue;
        }

        hash = (c1 << 16) + (c2 << 8) + c3;
        hash ^= (hash >> 9);
        hash += (hash >> 5);
        hash ^= c1;
        hp = (hash & (LEMPEL_SIZE - 1)) * EXPAND;
        matchpossibility.length = 0;
        for (j=0; j<EXPAND; j++) {
            offset = (windowpos - lempel[hp+j]) & OFFSET_MASK;
            cpy = window.length + windowpos - offset;
            var w1 = window[cpy & OFFSET_MASK];
            var w2 = window[(cpy+1) & OFFSET_MASK];
            var w3 = window[(cpy+2) & OFFSET_MASK];
            // if offset is small, we might not have copied the tentative
            // bytes into the window yet.  (Note that offset=0 really means
            // offset=(OFFSET_MASK+1).)
            if (C_COMPAT && offset===0) {
                w1 = c1 ^ 1; // ensure match will fail
            } else if (offset==1) { w2 = c1; w3 = c2; }
            else if (offset==2) { w3 = c1; }
            if (c1 === w1 && c2 === w2 && c3 === w3) {
                matchpossibility.push(offset);
            }
        }
        // store this location in the hash, move the others over to make room
        // oldest match drops off
        for (j=EXPAND-1; j>0; j--)
            lempel[hp+j] = lempel[hp+j-1];
        lempel[hp] = windowpos;
        // did we find any matches?
        if (matchpossibility.length === 0) {
            outwindow[outpos++] = winput(c1);
            unget(c3);
            unget(c2);
        } else {
            // find the longest of the possible matches
            outwindow[0] |= copymask;
            winput(c1); winput(c2); winput(c3);
            var c4 = get(), last = matchpossibility[0];
            var base = window.length + windowpos;
            for (mlen = MATCH_MIN; mlen < MATCH_MAX; mlen++, base++) {
                if (c4 === EOF) break;
                for (j=0; j < matchpossibility.length; ) {
                    var w4 = window[(base - matchpossibility[j]) & OFFSET_MASK];
                    if (c4 !== w4) {
                        last = matchpossibility[j];
                        matchpossibility.splice(j, 1);
                    } else {
                        j++;
                    }
                }
                if (matchpossibility.length===0) break; // no more matches
                winput(c4);
                c4 = get();
            }
            if (matchpossibility.length !== 0) {
                // maximum length match, rock on!
                last = matchpossibility[0];
            }
            unget(c4);

            outwindow[outpos++] = ((mlen - MATCH_MIN) << (NBBY - MATCH_BITS)) |
                (last >> NBBY);
            outwindow[outpos++] = last & 0xFF;
        }
    }
    dumpout();
});

/**
 * Decompress string or byte array using fast and efficient algorithm.
 *
 * Our implementation is based on
 * http://src.opensolaris.org/source/raw/onnv/onnv-gate/usr/src/uts/common/fs/zfs/lzjb.c
 * and
 * http://src.opensolaris.org/source/raw/onnv/onnv-gate/usr/src/uts/common/os/compress.c
 * It is licensed under CDDL.
 *
 * @param {Array|Uint8Array|Buffer|stream} input The stream or byte array
 *        that you want to decompress.
 * @param {stream} output Optional output stream.
 * @return {Array|Uint8Array|Buffer} Decompressed byte array, or 'output'
 */
Lzjb.decompressFile = Util.decompressFileHelper(Lzjb.MAGIC, function(inStream, outStream, outSize) {
    var sstart, dstart = [], slen,
        src = 0, dst = 0,
        cpy, copymap,
        mlen, offset,
        i, c;
    var retval;

    var window = Util.makeU8Buffer(OFFSET_MASK+1);
    var windowpos = 0;

    var copymask = 1 << (NBBY - 1);

    while (outSize !== 0) {
        c = inStream.readByte();
        if (c === EOF) break;

        if ((copymask <<= 1) == (1 << NBBY)) {
            copymask = 1;
            copymap = c;
            c = inStream.readByte();
        }
        if (copymap & copymask) {
            mlen = (c >> (NBBY - MATCH_BITS)) + MATCH_MIN;
            offset = ((c << NBBY) | inStream.readByte()) & OFFSET_MASK;
            cpy = windowpos - offset;
            if (cpy < 0) cpy += window.length;
            if (outSize >= 0) outSize -= mlen;
            while (--mlen >= 0) {
                c = window[windowpos++] = window[cpy++];
                outStream.writeByte(c);
                if (windowpos >= window.length) { windowpos=0; }
                if (cpy >= window.length) { cpy = 0; }
            }
        } else {
            outStream.writeByte(c);
            window[windowpos++] = c;
            if (windowpos >= window.length) { windowpos=0; }
            if (outSize >= 0) outSize--;
        }
    }
});

module.exports = Lzjb;

},{"./Stream":22,"./Util":23}],15:[function(require,module,exports){
/* Tweaked version of LZJB, using range coder. */
const Context1Model = require('./Context1Model');
const FenwickModel = require('./FenwickModel');
const LogDistanceModel = require('./LogDistanceModel');
const NoModel = require('./NoModel');
const RangeCoder = require('./RangeCoder');
const Stream = require('./Stream');
const Util = require('./Util');

var LzjbR = Object.create(null);
LzjbR.MAGIC = 'lzjR';

// Constants was used for compress/decompress function.
var NBBY = 8,
    MATCH_BITS = 6,
    MATCH_MIN = 3,
    MATCH_MAX = ((1 << MATCH_BITS) + (MATCH_MIN - 1)),
    OFFSET_MASK = ((1 << (16 - MATCH_BITS)) - 1),
    LEMPEL_SIZE_BASE = 1024;
var LENGTH_MODEL_CUTOFF = 32;


/**
 * Compress using modified LZJB algorithm.  Instead of using the simple
 * 9-bit literal / 17-bit match format of the original, use a range
 * coder for the literal/match bit and for the offset and length.
 */
LzjbR.compressFile = Util.compressFileHelper(LzjbR.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {
    var sstart, dstart = [], slen,
        src = 0, dst = 0,
        cpy, copymap,
        mlen, offset,
        hash, hp,
        lempel,
        i, j;

    // in an improvement over the original C implementation of LZJB, we expand
    // the hash table to track a number of potential matches, not just the
    // most recent.  This doesn't require any changes to the decoder.
    var LEMPEL_SIZE = LEMPEL_SIZE_BASE;
    var EXPAND = 1; // default to original C impl
    if (typeof(props)==='number') {
        LEMPEL_SIZE *= 2;
        props = Math.max(1, Math.min(9, props)) - 1;
        EXPAND = 1<<Math.floor(props/2);
        if (props&1) EXPAND = Math.round(EXPAND * 1.5);
        if (props >=2 && props <= 4) EXPAND++;
    }

    var encoder = new RangeCoder(outStream);
    encoder.encodeStart(finalByte, 1);

    // use Uint16Array if available (zero-filled)
    lempel = Util.makeU16Buffer(LEMPEL_SIZE * EXPAND);

    var window = Util.makeU8Buffer(OFFSET_MASK+1);
    var windowpos = 0;
    var winput = function(_byte) {
        window[windowpos++] = _byte;
        if (windowpos >= window.length) {
            windowpos = 0;
        }
        return _byte;
    };

    var unbuffer = [];
    var get = function() {
        if (unbuffer.length)
            return unbuffer.pop();
        return inStream.readByte();
    };
    var unget = function(_byte) {
        unbuffer.push(_byte);
    };

    var matchpossibility = [];
    var MATCH = 256;
    var EOF_SYM = 257;
    var noModelFactory = NoModel.factory(encoder);
    var modelFactory = FenwickModel.factory(encoder, 0xFF00, 0x100);
    var literalModel = new Context1Model(modelFactory, 256,
                                         ((fileSize<0) ? EOF_SYM : MATCH) + 1);
    var sparseModelFactory = function(size) {
        if (size <= LENGTH_MODEL_CUTOFF) { return modelFactory(size); }
        return noModelFactory(size);
    };
    var lenModel = new LogDistanceModel((MATCH_MAX-MATCH_MIN)+1, 0,
                                        modelFactory, sparseModelFactory);
    var posModel = new LogDistanceModel(OFFSET_MASK+1, 1,
                                        modelFactory, sparseModelFactory);
    var lastChar = 0x20, lastOffset = 0;
    while (true) {
        var initialPos = windowpos;
        var c1 = get();
        if (c1 === Stream.EOF) break;

        var c2 = get();
        if (c2 === Stream.EOF) {
            literalModel.encode(winput(c1), lastChar); // literal, not a match
            break;
        }
        var c3 = get();
        if (c3 === Stream.EOF) {
            literalModel.encode(winput(c1), lastChar); // literal, not a match
            unget(c2); lastChar = c1;
            continue;
        }

        hash = (c1 << 16) + (c2 << 8) + c3;
        hash ^= (hash >> 9);
        hash += (hash >> 5);
        hash ^= c1;
        hp = (hash & (LEMPEL_SIZE - 1)) * EXPAND;
        matchpossibility.length = 0;
        for (j=0; j<EXPAND; j++) {
            offset = (windowpos - lempel[hp+j]) & OFFSET_MASK;
            cpy = window.length + windowpos - offset;
            var w1 = window[cpy & OFFSET_MASK];
            var w2 = window[(cpy+1) & OFFSET_MASK];
            var w3 = window[(cpy+2) & OFFSET_MASK];
            // if offset is small, we might not have copied the tentative
            // bytes into the window yet.  (Note that offset=0 really means
            // offset=(OFFSET_MASK+1).)
            if (offset==1) { w2 = c1; w3 = c2; }
            else if (offset==2) { w3 = c1; }
            if (c1 === w1 && c2 === w2 && c3 === w3) {
                matchpossibility.push(offset);
            }
        }
        // store this location in the hash, move the others over to make room
        // oldest match drops off
        for (j=EXPAND-1; j>0; j--)
            lempel[hp+j] = lempel[hp+j-1];
        lempel[hp] = windowpos;
        // did we find any matches?
        if (matchpossibility.length === 0) {
            literalModel.encode(winput(c1), lastChar); // literal, not a match
            unget(c3);
            unget(c2);
            lastChar = c1;
        } else {
            literalModel.encode(MATCH, lastChar); // a match!
            // find the longest of the possible matches
            winput(c1); winput(c2); winput(c3); lastChar = c3;
            var c4 = get(), last = matchpossibility[0];
            var base = window.length + windowpos;
            for (mlen = MATCH_MIN; mlen < MATCH_MAX; mlen++, base++) {
                if (c4 === Stream.EOF) break;
                for (j=0; j < matchpossibility.length; ) {
                    var w4 = window[(base - matchpossibility[j]) & OFFSET_MASK];
                    if (c4 !== w4) {
                        last = matchpossibility[j];
                        matchpossibility.splice(j, 1);
                    } else {
                        j++;
                    }
                }
                if (matchpossibility.length===0) break; // no more matches
                winput(c4); lastChar = c4;
                c4 = get();
            }
            if (matchpossibility.length !== 0) {
                // maximum length match, rock on!
                last = matchpossibility[0];
            }
            unget(c4);

            // encode match length
            // XXX we could get a bit more compression if we allowed
            // the length to predict the offset (or vice-versa)
            lenModel.encode(mlen - MATCH_MIN);
            offset = (initialPos - last) & OFFSET_MASK;
            if (offset === lastOffset) {
                posModel.encode(-1); // common case!
            } else {
                posModel.encode(offset);
                lastOffset = offset;
            }
        }
    }
    if (fileSize < 0) {
        literalModel.encode(EOF_SYM, lastChar); // end of file (streaming)
    }
    encoder.encodeFinish();
}, true);

/**
 * Decompress using modified LZJB algorithm.
 */
LzjbR.decompressFile = Util.decompressFileHelper(LzjbR.MAGIC, function(inStream, outStream, outSize) {
    var sstart, dstart = [], slen,
        src = 0, dst = 0,
        cpy, copymap,
        mlen, offset,
        i, c;

    var window = Util.makeU8Buffer(OFFSET_MASK+1);
    var windowpos = 0;

    var decoder = new RangeCoder(inStream);
    decoder.decodeStart(true/* we already read the 'free' byte*/);

    var MATCH = 256;
    var EOF_SYM = 257;
    var noModelFactory = NoModel.factory(decoder);
    var modelFactory = FenwickModel.factory(decoder, 0xFF00, 0x100);
    var literalModel = new Context1Model(modelFactory, 256,
                                         ((outSize<0) ? EOF_SYM : MATCH) + 1);
    var sparseModelFactory = function(size) {
        if (size <= LENGTH_MODEL_CUTOFF) { return modelFactory(size); }
        return noModelFactory(size);
    };
    var lenModel = new LogDistanceModel((MATCH_MAX-MATCH_MIN)+1, 0,
                                        modelFactory, sparseModelFactory);
    var posModel = new LogDistanceModel(OFFSET_MASK+1, 1,
                                        modelFactory, sparseModelFactory);
    var lastChar = 0x20, lastOffset = 0;
    while (outSize !== 0) {
        c = literalModel.decode(lastChar);
        if (c === EOF_SYM) {
            break;
        } else if (c === MATCH) {
            mlen = lenModel.decode() + MATCH_MIN;
            cpy = posModel.decode();
            if (cpy<0) { cpy = lastOffset; }
            else       { lastOffset = cpy; }
            if (outSize >= 0) outSize -= mlen;
            while (--mlen >= 0) {
                c = lastChar = window[windowpos++] = window[cpy++];
                outStream.writeByte(c);
                if (windowpos >= window.length) { windowpos=0; }
                if (cpy >= window.length) { cpy = 0; }
            }
        } else {
            outStream.writeByte(c);
            window[windowpos++] = lastChar = c;
            if (windowpos >= window.length) { windowpos=0; }
            if (outSize >= 0) outSize--;
        }
    }
    decoder.decodeFinish();
});

module.exports = LzjbR;

},{"./Context1Model":7,"./FenwickModel":10,"./LogDistanceModel":13,"./NoModel":18,"./RangeCoder":20,"./Stream":22,"./Util":23}],16:[function(require,module,exports){
/* Implementation of LZP3(ish), with an adaptive Huffman code or a range
 * coder (instead of LZP3's original static Huffman code).
 * See: http://www.cbloom.com/papers/lzp.pdf
 */
const BitStream = require('./BitStream');
const Context1Model = require('./Context1Model');
const DefSumModel = require('./DefSumModel');
const FenwickModel = require('./FenwickModel');
const Huffman = require('./Huffman');
const LogDistanceModel = require('./LogDistanceModel');
const NoModel = require('./NoModel');
const RangeCoder = require('./RangeCoder');
const Stream = require('./Stream');
const Util = require('./Util');

var Lzp3 = Object.create(null);
Lzp3.MAGIC = 'lzp3';

// use Huffman coder (fast) or else use range coder (slow)
var USE_HUFFMAN_CODE = false;
// use deferred-sum model, which is supposed to be faster (but compresses worse)
var USE_DEFSUM = false;
// when to give up attempting to model the length
var LENGTH_MODEL_CUTOFF = 256;
var MODEL_MAX_PROB = 0xFF00;
var MODEL_INCREMENT = 0x100;

// Constants was used for compress/decompress function.
var CTXT4_TABLE_SIZE = 1 << 16;
var CTXT3_TABLE_SIZE = 1 << 12;
var CTXT2_TABLE_SIZE = 1 << 16;
var CONTEXT_LEN = 4;
var LOG_WINDOW_SIZE = 20;
var WINDOW_SIZE = 1 << LOG_WINDOW_SIZE;
var MAX_MATCH_LEN = WINDOW_SIZE-1;
var MATCH_LEN_CONTEXTS = 16;

var MAX32 = 0xFFFFFFFF;
var MAX24 = 0x00FFFFFF;
var MAX16 = 0x0000FFFF;
var MAX8  = 0x000000FF;


var Window = function(maxSize) {
  this.buffer = Util.makeU8Buffer(Math.min(maxSize+4, WINDOW_SIZE));
  this.pos = 0;
  // context-4 hash table.
  this.ctxt4 = Util.makeU32Buffer(CTXT4_TABLE_SIZE);
  // context-3 hash table
  this.ctxt3 = Util.makeU32Buffer(CTXT3_TABLE_SIZE);
  // context-2 table (not really a hash any more)
  this.ctxt2 = Util.makeU32Buffer(CTXT2_TABLE_SIZE);
  // initial context
  this.put(0x63); this.put(0x53); this.put(0x61); this.put(0x20);
};
Window.prototype.put = function(_byte) {
  this.buffer[this.pos++] = _byte;
  if (this.pos >= WINDOW_SIZE) { this.pos = 0; }
  return _byte;
};
Window.prototype.get = function(pos) {
  return this.buffer[pos & (WINDOW_SIZE-1)];
};
Window.prototype.context = function(pos, n) {
  var c = 0, i;
  pos = (pos - n) & (WINDOW_SIZE-1);
  for (i=0; i<n; i++) {
    c = (c << 8) | this.buffer[pos++];
    if (pos >= WINDOW_SIZE) { pos = 0; }
  }
  return c;
};
// if matchLen !== 0, update the index; otherwise get index value.
Window.prototype.getIndex = function(s, matchLen) {
  var c = this.context(s, 4);
  // compute context hashes
  var h4 = ((c>>>15) ^ c) & (CTXT4_TABLE_SIZE-1);
  var h3 = ((c>>>11) ^ c) & (CTXT3_TABLE_SIZE-1);
  var h2 = c & MAX16;
  // check order-4 context
  var p = 0, checkc;
  // only do context confirmation if matchLen==0 (that is, if we're not just
  // doing an update)
  if (matchLen===0) {
    p = this.ctxt4[h4];
    if (p !== 0 && c !== this.context(p-1, 4)) {
      p = 0; // context confirmation failed
    }
    if (p === 0) {
      // check order-3 context
      p = this.ctxt3[h3];
      if (p !== 0 && (c & MAX24) !== this.context(p-1, 3)) {
        p = 0; // context confirmation failed
      }
      if (p === 0) {
        // check order-2 context
        p = this.ctxt2[h2];
        if (p !== 0 && (c && MAX16) !== this.context(p-1, 2)) {
          p = 0; // context confirmation failed
        }
      }
    }
  }
  // update context index
  if (matchLen) { matchLen--; }
  this.ctxt4[h4] = this.ctxt3[h3] = this.ctxt2[h2] =
    (s | (matchLen << LOG_WINDOW_SIZE)) + 1;
  // return lookup result.
  return p;
};

/**
 * Compress using modified LZP3 algorithm.  Instead of using static
 * Huffman coding, we use an adaptive Huffman code or range encoding.
 */
Lzp3.compressFile = Util.compressFileHelper(Lzp3.MAGIC, function(inStream, outStream, fileSize, props) {
  // sliding window & hash table
  var window = new Window( (fileSize>=0) ? fileSize : WINDOW_SIZE );

  var coderFactory, sparseCoderFactory, flush;

  if (USE_HUFFMAN_CODE) {
    // Huffman contexts
    outStream.writeByte(0x80); // mark that this is Huffman coded.
    var bitstream = new BitStream(outStream);
    flush = bitstream.flush.bind(bitstream);
    coderFactory = Huffman.factory(bitstream, MAX16);
    sparseCoderFactory = NoModel.factory(bitstream);

  } else { // range encoder
    var range = new RangeCoder(outStream);
    range.encodeStart(0x00, 0); // 0x00 == range encoded

    coderFactory = FenwickModel.factory(range, MODEL_MAX_PROB, MODEL_INCREMENT);
    if (USE_DEFSUM) {
      coderFactory = DefSumModel.factory(range, false /* encoder */);
    }
    // switch sparseCoderFactory to a NoModel when size > cutoff
    var noCoderFactory = NoModel.factory(range);
    sparseCoderFactory = function(size) {
      if (size > LENGTH_MODEL_CUTOFF) {
        return noCoderFactory(size);
      }
      return coderFactory(size);
    };
    flush = function() { range.encodeFinish(); };
  }

  var huffLiteral= new Context1Model(coderFactory, 256,
                                     (fileSize<0) ? 257 : 256);
  var huffLen = [], i;
  for (i=0; i<MATCH_LEN_CONTEXTS; i++) {
    huffLen[i] = new LogDistanceModel(MAX_MATCH_LEN+1, 1,
                                      coderFactory, sparseCoderFactory);
  }

  var inSize = 0, s, matchContext = 0;
  while (inSize !== fileSize) {
    var ch = inStream.readByte();
    s = window.pos;
    var p = window.getIndex(s, 0);
    if (p !== 0) {
      // great, a match! how long is it?
      p--; // p=0 is used for 'not here'. p=1 really means WINDOW_SIZE
      var prevMatchLen = (p >>> LOG_WINDOW_SIZE) + 1;
      var matchLen = 0;
      while (window.get(p + matchLen) === ch && matchLen < MAX_MATCH_LEN) {
        matchLen++;
        window.put(ch);
        ch = inStream.readByte();
      }
      // code match length; match len = 0 means "literal"
      // use "extra state" -1 to mean "same as previous match length"
      if (prevMatchLen===matchLen) {
        huffLen[matchContext&(MATCH_LEN_CONTEXTS-1)].encode(-1);
      } else {
        huffLen[matchContext&(MATCH_LEN_CONTEXTS-1)].encode(matchLen);
      }
      // update hash with this match
      window.getIndex(s, matchLen);
      inSize += matchLen;
      matchContext <<= 1;
      if (matchLen > 0) { matchContext |= 1; }
      // XXX: LZMA uses a special "delta match" context here if matchLen==0
      // XXX: it also uses the offset as context for the length (or vice-versa)
    }
    // always encode a literal after a match
    var context1 = window.get(window.pos-1);
    if (ch===Stream.EOF) {
      if (fileSize < 0) {
        huffLiteral.encode(256, context1);
      }
      break;
    }
    huffLiteral.encode(ch, context1);
    window.put(ch);
    inSize++;
  }
  if (flush) flush();
});

/**
 * Decompress using modified LZP3 algorithm.
 */
Lzp3.decompressFile = Util.decompressFileHelper(Lzp3.MAGIC, function(inStream, outStream, fileSize) {
  var flags = inStream.readByte();
  var use_huffman_code = !!(flags & 0x80);

  // sliding window & hash table
  var window = new Window( (fileSize>=0) ? fileSize : WINDOW_SIZE );

  var coderFactory, sparseCoderFactory, finish;

  if (use_huffman_code) {
    // Huffman contexts
    var bitstream = new BitStream(inStream);
    coderFactory = Huffman.factory(bitstream, MAX16);
    sparseCoderFactory = NoModel.factory(bitstream);
  } else { // range encoder
    var range = new RangeCoder(inStream);
    range.decodeStart(true/* skip initial read */);
    coderFactory = FenwickModel.factory(range, MODEL_MAX_PROB, MODEL_INCREMENT);
    if (USE_DEFSUM) {
      coderFactory = DefSumModel.factory(range, true /* decoder */);
    }
    // switch sparseCoderFactory to a NoModel when size > cutoff
    var noCoderFactory = NoModel.factory(range);
    sparseCoderFactory = function(size) {
      if (size > LENGTH_MODEL_CUTOFF) {
        return noCoderFactory(size);
      }
      return coderFactory(size);
    };
    finish = function() { range.decodeFinish(); };
  }

  var huffLiteral= new Context1Model(coderFactory, 256,
                                     (fileSize<0) ? 257 : 256);
  var huffLen = [], i;
  for (i=0; i<MATCH_LEN_CONTEXTS; i++) {
    huffLen[i] = new LogDistanceModel(MAX_MATCH_LEN+1, 1,
                                      coderFactory, sparseCoderFactory);
  }

  var s, ch, outSize = 0, matchContext = 0;
  while (outSize !== fileSize) {
    s = window.pos;
    var p = window.getIndex(s, 0);
    if (p !== 0) {
      p--; // p=0 is used for 'not here'. p=1 really means WINDOW_SIZE
      var prevMatchLen = (p >>> LOG_WINDOW_SIZE) + 1;
      var matchLen = huffLen[matchContext&(MATCH_LEN_CONTEXTS-1)].decode();
      if (matchLen < 0) { matchLen = prevMatchLen; }
      // copy characters!
      for (i=0; i<matchLen; i++) {
        ch = window.get(p + i);
        outStream.writeByte(window.put(ch));
      }
      window.getIndex(s, matchLen);
      outSize += matchLen;
      matchContext <<= 1;
      if (matchLen > 0) matchContext |= 1;
    }
    // literal always follows match (or failed match)
    if (outSize === fileSize) {
      break; // EOF
    }
    var context1 = window.get(window.pos-1);
    ch = huffLiteral.decode(context1);
    if (ch === 256) {
      break; // EOF
    }
    outStream.writeByte(window.put(ch));
    outSize++;
  }
  if (finish) finish();
});


module.exports = Lzp3;

},{"./BitStream":4,"./Context1Model":7,"./DefSumModel":8,"./FenwickModel":10,"./Huffman":11,"./LogDistanceModel":13,"./NoModel":18,"./RangeCoder":20,"./Stream":22,"./Util":23}],17:[function(require,module,exports){
/** Simple range coding model w/ escape, suitable for sparse symbol sets.
 *  Uses a move-to-front list, which is simple and relatively performant,
 *  but slows down a lot if you want to try to model escapes more precisely
 *  (which is why this feature is disabled by default).
 */
const RangeCoder = require('./RangeCoder');
const Stream = require('./Stream');
const Util = require('./Util');

var DEFAULT_MAX_PROB = 0xFF00;
var DEFAULT_INCREMENT= 0x0100;

var NUMERIC_SORT = function(a, b) { return a - b; };

var MTFModel = function(coder, size, max_prob, increment, betterEscape) {
    this.coder = coder;
    this.increment = (+increment) || DEFAULT_INCREMENT;
    this.max_prob = (+max_prob) || DEFAULT_MAX_PROB;
    console.assert((this.max_prob + (this.increment-1)) <= 0xFFFF);
    this.sym = Util.makeU16Buffer(size+1);
    this.prob= Util.makeU16Buffer(size+2);
    this.sym[0] = size; // escape code
    this.prob[0]= 0;
    this.seenSyms = 1;
    // total probability always found in this.prob[this.seenSyms]
    this.prob[this.seenSyms] = this.increment;
    this.numSyms = size;
    if (betterEscape) {
        this.sortedSeen = [size];
    }
};
MTFModel.factory = function(coder, max_prob, increment, betterEscape) {
    return function(size) {
        return new MTFModel(coder, size, max_prob, increment, betterEscape);
    };
};
MTFModel.prototype.clone = function() {
    var newModel = new MTFModel(this.coder, this.numSyms, this.max_prob,
                                this.increment, !!this.sortedSeen);
    var i;
    for (i=0; i<this.seenSyms; i++) {
        newModel.sym[i] = this.sym[i];
        newModel.prob[i] = this.prob[i];
    }
    newModel.prob[i] = this.prob[i]; // total probability
    newModel.seenSyms = this.seenSyms;
    if (this.sortedSeen) {
        newModel.sortedSeen = this.sortedSeen.slice(0);
    }
    return newModel;
};
MTFModel.prototype._update = function(symbol, index, sy_f) {
    var j, tot_f;
    // move this symbol to the end
    for (j=index; j<this.seenSyms-1; j++) {
        this.sym[j] = this.sym[j+1];
        this.prob[j] = this.prob[j+1] - sy_f;
    }
    if (index < this.seenSyms) {
        this.sym[j] = symbol;
        this.prob[j] = this.prob[j+1] - sy_f;
        // increase frequency for this symbol, and total freq at same time
        this.prob[this.seenSyms] = tot_f =
            this.prob[this.seenSyms] + this.increment;
        if (symbol === this.numSyms && this.seenSyms >= this.numSyms) {
            // this is the last time we'll see an escape! remove it.
            tot_f = this.prob[--this.seenSyms];
            if (this.sortedSeen) { this.sortedSeen.length--; }
        }
    } else { // add to the end
        tot_f = this.prob[this.seenSyms];
        this.sym[index] = symbol;
        this.prob[index] = tot_f;
        tot_f += this.increment;
        this.prob[++this.seenSyms] = tot_f;
        if (this.sortedSeen) {
            this.sortedSeen.push(symbol);
            // hopefully sort is very fast on a mostly-sorted array
            this.sortedSeen.sort(NUMERIC_SORT);
        }
    }
    if (tot_f >= this.max_prob) { this._rescale(); }
    return;
};
MTFModel.prototype._rescale = function() {
    var i, j, total=0;
    var noEscape = true;
    if (this.sortedSeen) { this.sortedSeen.length = 0; }
    for(i=0, j=0; i<this.seenSyms; i++) {
        var sym = this.sym[i];
        var sy_f = this.prob[i+1] - this.prob[i];
        sy_f >>>= 1;
        if (sy_f > 0) {
            if (sym === this.numSyms) {
                noEscape = false;
            }
            this.sym[j] = sym;
            this.prob[j++] = total;
            total += sy_f;
            if (this.sortedSeen) { this.sortedSeen.push(sym); }
        }
    }
    this.prob[j] = total;
    this.seenSyms = j;
    if (this.sortedSeen) {
        this.sortedSeen.sort(NUMERIC_SORT);
    }
    // don't allow escape to go to zero prob if we still need it
    if (noEscape && this.seenSyms < this.numSyms) {
        // NOTE this adds this.increment to escape freq; the FenwickModel
        //      just adds one.
        this._update(this.numSyms/*escape*/, this.seenSyms/*at end*/);
    }
};
MTFModel.prototype.decode = function() {
    var tot_f = this.prob[this.seenSyms];
    var prob = this.coder.decodeCulFreq(tot_f);
    // we're expecting to find the probability near the "most recent" side
    // of our array
    var i;
    for (i=this.seenSyms-1; i>=0; i--) {
        if (this.prob[i] <= prob /*&& prob < this.prob[i+1]*/)
            break;
    }
    console.assert(i>=0);
    var symbol = this.sym[i];
    var lt_f = this.prob[i];
    var sy_f = this.prob[i + 1] - lt_f;
    this.coder.decodeUpdate(sy_f, lt_f, tot_f);
    this._update(symbol, i, sy_f);
    if (symbol === this.numSyms) {
        /* this is an escape */
        /* decode the literal */
        sy_f = 1;
        tot_f = this.numSyms;
        if (this.sortedSeen) {
            // do a slower, but more precise decoding of the literal
            // by excluding the already-seen symbols.
            var seen = this.sortedSeen;
            tot_f = this.numSyms - this.seenSyms;
            if (seen[seen.length-1] === this.numSyms) { tot_f++; }
            symbol = lt_f = this.coder.decodeCulFreq(tot_f);
            for (i=0; i < seen.length && seen[i] <= symbol ; i++) {
                symbol++;
            }
        } else {
            symbol = lt_f = this.coder.decodeCulFreq(tot_f);
        }
        this.coder.decodeUpdate(sy_f, lt_f, tot_f);
        this._update(symbol, this.seenSyms);
    }
    return symbol;
};
MTFModel.prototype.encode = function(symbol) {
    // look for symbol, from most-recent to oldest
    var i, sy_f, lt_f, tot_f;
    for (i=this.seenSyms-1; i>=0; i--) {
        if (symbol === this.sym[i]) {
            // ok, found it.
            lt_f = this.prob[i];
            sy_f = this.prob[i + 1] - lt_f;
            tot_f = this.prob[this.seenSyms];
            this.coder.encodeFreq(sy_f, lt_f, tot_f);
            return this._update(symbol, i, sy_f);
        }
    }
    // couldn't find this symbol.  encode as escape.
    console.assert(symbol !== this.numSyms); // catch infinite recursion
    this.encode(this.numSyms); // guaranteed to be found in the table.
    // code symbol as literal
    sy_f = 1;
    lt_f = symbol;
    tot_f = this.numSyms;
    if (this.sortedSeen) {
        // do a slower, but more precise encoding of the literal
        // by excluding the already-seen symbols.
        var seen = this.sortedSeen;
        tot_f -= this.seenSyms;
        if (seen[seen.length-1] === this.numSyms) { tot_f++; }
        for (i=0; i < seen.length && seen[i] < symbol; i++) {
            lt_f--;
        }
    }
    this.coder.encodeFreq(sy_f, lt_f, tot_f);
    // now add symbol to the end.
    return this._update(symbol, this.seenSyms);
};

MTFModel.MAGIC = 'mtfm';
/** Simple order-0 compressor, as self-test. */
MTFModel.compressFile = Util.compressFileHelper(MTFModel.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {
  var range = new RangeCoder(outStream);
  range.encodeStart(finalByte, 1);
  var model = new MTFModel(range, (fileSize<0) ? 257 : 256);
  Util.compressWithModel(inStream, fileSize, model);
  range.encodeFinish();
}, true);

/** Simple order-0 decompresser, as self-test. */
MTFModel.decompressFile = Util.decompressFileHelper(MTFModel.MAGIC, function(inStream, outStream, fileSize) {
  var range = new RangeCoder(inStream);
  range.decodeStart(true/*we already read the 'free' byte*/);
  var model = new MTFModel(range, (fileSize<0) ? 257 : 256);
  Util.decompressWithModel(outStream, fileSize, model);
  range.decodeFinish();
});

module.exports = MTFModel;

},{"./RangeCoder":20,"./Stream":22,"./Util":23}],18:[function(require,module,exports){
/** Simple "lack of model" -- just encode the bits directly.
 *  Useful especially with sparse spaces or Huffman coders where there's
 *  no obvious prediction to be made that will pay for itself.
 */
const BitStream = require('./BitStream');
const Util = require('./Util');

var NoModel = function(bitstream, size) {
  this.bitstream = bitstream;
  this.bits = Util.fls(size-1);
};
NoModel.factory = function(bitstream) {
  return function(size) { return new NoModel(bitstream, size); };
};
NoModel.prototype.encode = function(symbol) {
  var i;
  for (i=this.bits-1; i>=0; i--) {
    var b = (symbol >>> i) & 1;
    this.bitstream.writeBit(b);
  }
};
NoModel.prototype.decode = function() {
  var i, r = 0;
  for (i=this.bits-1; i>=0; i--) {
    r <<= 1;
    if (this.bitstream.readBit()) r++;
  }
  return r;
};

/** Brain-dead self-test. */
NoModel.MAGIC = 'nomo';
NoModel.compressFile = Util.compressFileHelper(NoModel.MAGIC, function(inStream, outStream, fileSize, props) {
    var bitstream = new BitStream(outStream);
    var model = new NoModel(bitstream, (fileSize<0) ? 257 : 256);
    Util.compressWithModel(inStream, fileSize, model);
    bitstream.flush();
});
NoModel.decompressFile = Util.decompressFileHelper(NoModel.MAGIC, function(inStream, outStream, fileSize) {
    var bitstream = new BitStream(inStream);
    var model = new NoModel(bitstream, (fileSize<0) ? 257 : 256);
    Util.decompressWithModel(outStream, fileSize, model);
});

module.exports = NoModel;

},{"./BitStream":4,"./Util":23}],19:[function(require,module,exports){
/** Particularly simple-minded implementation of PPM compression. */
const RangeCoder = require('./RangeCoder');
const Util = require('./Util');

var MAX_CONTEXT = 5;
var LOG_WINDOW_SIZE = 18;
var WINDOW_SIZE = 1 << LOG_WINDOW_SIZE;

var Window = function() {
  this.buffer = Util.makeU8Buffer(WINDOW_SIZE);
  this.pos = 0;
  this.firstPass = true;
  for (var i=0; i<MAX_CONTEXT; i++) {
    this.put('cSaCsA'.charCodeAt(i%6));
  }
};
Window.prototype.put = function(_byte) {
  this.buffer[this.pos++] = _byte;
  if (this.pos >= WINDOW_SIZE) { this.pos = 0; this.firstPass = false; }
  return _byte;
};
Window.prototype.get = function(pos) {
  return this.buffer[pos & (WINDOW_SIZE-1)];
};
// the context ending just before 'pos'
Window.prototype.context = function(pos, n) {
  var c = [], i;
  pos = (pos - n) & (WINDOW_SIZE-1);
  for (i=0; i<n; i++) {
    c.push(this.buffer[pos++]);
    if (pos >= WINDOW_SIZE) { pos = 0; }
  }
  return String.fromCharCode.apply(String, c);
};

var DMM_INCREMENT = 0x100, DMM_MAX_PROB = 0xFF00;

var PPM = function(coder, size) {
  this.window = new Window();
  this.contexts = Object.create(null);
  // brain-dead '-1' context, using full exclusion
  var Cm1Context = function() { };
  Cm1Context.prototype.encode = function(symbol, exclude) {
    var i, lt_f = 0;
    for (i=0; i<symbol; i++) {
      if (!exclude[i]) {
        lt_f++;
      }
    }
    var tot_f = size - exclude.total;
    coder.encodeFreq(1, lt_f, tot_f);
  };
  Cm1Context.prototype.decode = function(exclude) {
    var i, symbol, lt_f;
    var tot_f = size - exclude.total;
    symbol = lt_f = coder.decodeCulFreq(tot_f);
    for (i=0; i<=symbol; i++) {
      if (exclude[i]) {
        symbol++;
      }
    }
    coder.decodeUpdate(1, lt_f, tot_f);
    return symbol;
  };
  this.cm1coder = new Cm1Context();

  var DenseMTFModel = function() {
    this.sym = [size];
    this.prob= [0, DMM_INCREMENT];
    this.refcount = 0;
  };
  DenseMTFModel.prototype._rescale = function() {
    var seenSyms = this.sym.length;
    var i, j, total=0;
    var noEscape = true;
    for(i=0, j=0; i<seenSyms; i++) {
      var sym = this.sym[i];
      var sy_f = this.prob[i+1] - this.prob[i];
      sy_f >>>= 1;
      if (sy_f > 0) {
        if (sym === size) {
          noEscape = false;
        }
        this.sym[j] = sym;
        this.prob[j++] = total;
        total += sy_f;
      }
    }
    this.prob[j] = total;
    seenSyms = this.sym.length = j;
    this.prob.length = seenSyms + 1;
    // don't allow escape to go to zero prob if we still need it
    if (noEscape && seenSyms < size) {
      total = this._update(size/*escape*/, seenSyms/*at end*/, 0, 1);
    }
    return total;
  };
  DenseMTFModel.prototype.update = function(symbol, incr) {
    // find symbol
    var i=0;
    for (i=0; i<this.sym.length; i++) {
      if (this.sym[i] === symbol) {
        return this._update(symbol, i, this.prob[i+1] - this.prob[i], incr);
      }
    }
    // symbol escaped
    return this._update(symbol, i, 0, incr);
  };
  DenseMTFModel.prototype._update = function(symbol, index, sy_f, incr) {
    var seenSyms = this.sym.length;
    var i, j, tot_f;
    // move this symbol to the end
    for (j=index; j<seenSyms-1; j++) {
      this.sym[j] = this.sym[j+1];
      this.prob[j] = this.prob[j+1] - sy_f;
    }
    // "method D" -- if we add a new escaped symbol, escape & the symbol
    // both increase by 1/2.
    if (index < seenSyms) {
      this.sym[j] = symbol;
      this.prob[j] = this.prob[j+1] - sy_f;
      // increase frequency for this symbol, and total freq at same time
      this.prob[seenSyms] = tot_f =
        this.prob[seenSyms] + incr;
    } else { // add to the end
      tot_f = this.prob[seenSyms];
      this.sym[index] = symbol;
      this.prob[index] = tot_f;
      tot_f += incr;
      this.prob[++seenSyms] = tot_f;
      // remove probability of escape if table just filled up
      if (this.sym.length > size) {
        for (i=0; i<seenSyms; i++) {
          if (size === this.sym[i]) {
            // found it.
            this._update(size, i, this.prob[i+1] - this.prob[i], -1);
            this.sym.length--;
            this.prob.length--;
            tot_f = this.prob[this.prob.length-1];
          }
        }
      }
    }
    if (tot_f >= DMM_MAX_PROB) { tot_f = this._rescale(); }
    return tot_f;
  };
  DenseMTFModel.prototype.encode = function(symbol, exclude) {
    // look for symbol, from most-recent to oldest
    var i, j, sy_f, lt_f, tot_f, seenSyms = this.sym.length;
    var ex_seen = 0, ex_lt_f = 0, ex_tot_f = 0, ex_sy_f;
    for (i=seenSyms-1; i>=0; i--) {
      lt_f = this.prob[i];
      sy_f = this.prob[i + 1] - lt_f;
      if (symbol === this.sym[i]) {
        // ok, found it.
        // count up the rest of the probabilities
        for (j=i-1; j>=0 && ex_seen < exclude.total; j--) {
          if (exclude[this.sym[j]]) {
            ex_seen += 1;
            ex_sy_f = this.prob[j+1] - this.prob[j];
            ex_lt_f += ex_sy_f;
            ex_tot_f += ex_sy_f;
          }
        }
        tot_f = this.prob[seenSyms];
        // adjust by excluded symbols
        lt_f -= ex_lt_f;
        tot_f -= ex_tot_f;
        coder.encodeFreq(sy_f, lt_f, tot_f);
        if (symbol === size) { // only update table for escapes
          this._update(symbol, i, sy_f, DMM_INCREMENT/2);
          return false; // escape.
        } // otherwise we'll do update later
        return true; // encoded character!
      } else if (exclude[this.sym[i]]) {
        ex_seen += 1;
        ex_tot_f += sy_f;
      }
    }
    // couldn't find this symbol.  encode as escape.
    this.encode(size, exclude);
    // add symbols to exclusion table
    console.assert(this.sym[this.sym.length-1] === size);//escape
    for (i=0; i<this.sym.length-1; i++) {
      if (!exclude[this.sym[i]]) {
        exclude[this.sym[i]] = true;
        exclude.total++;
      }
    }
  };
  DenseMTFModel.prototype.decode = function(exclude) {
    var seenSyms = this.sym.length;
    var tot_f = this.prob[seenSyms];
    var ex_seen = 0, ex_lt_f = 0, ex_tot_f = 0, ex_sy_f;
    var i;
    for (i=seenSyms-1; i>=0 && ex_seen < exclude.total; i--) {
      if (exclude[this.sym[i]]) {
        ex_seen += 1;
        ex_tot_f += this.prob[i+1] - this.prob[i];
      }
    }
    var prob = coder.decodeCulFreq(tot_f - ex_tot_f) + ex_tot_f;
    // we're expecting to find the probability near the "most recent" side
    // of our array
    ex_lt_f = ex_tot_f;
    for (i=seenSyms-1; i>=0; i--) {
      if (exclude[this.sym[i]]) {
        ex_sy_f = this.prob[i+1] - this.prob[i];
        ex_lt_f -= ex_sy_f;
        prob -= ex_sy_f;
      } else if (this.prob[i] <= prob /*&& prob < this.prob[i+1]*/)
        break;
    }
    console.assert(i>=0);
    var symbol = this.sym[i];
    var lt_f = this.prob[i];
    var sy_f = this.prob[i + 1] - lt_f;
    coder.decodeUpdate(sy_f, lt_f - ex_lt_f, tot_f - ex_tot_f);
    // defer update
    if (symbol < size) { return symbol; }
    // an escape
    this._update(symbol, i, sy_f, DMM_INCREMENT/2);
    // add symbols to exclusion table
    console.assert(this.sym[this.sym.length-1] === size);//escape
    for (i=0; i<this.sym.length-1; i++) {
      if (!exclude[this.sym[i]]) {
        exclude[this.sym[i]] = true;
        exclude.total++;
      }
    }
    return -1;
  };
  this.newContext = function(initialSymbol) {
    return new DenseMTFModel();
  };
  this.newExclude = function() {
    var result = Object.create(null);
    result.total = 0; // no excluded symbols (yet)
    return result;
  };
  // set up some initial contexts
  (function() {
    var i, j;
    for (i=0; i<MAX_CONTEXT; i++) {
      for (j=0; j<=i; j++) {
        var cc = this.window.context(j+((MAX_CONTEXT-1)-i), j);
        if (!this.contexts[cc]) { this.contexts[cc] = this.newContext(); }
        this.contexts[cc].refcount++;
      }
    }
  }).call(this);
};
PPM.prototype.update = function(symbol, contextString, matchLevel) {
  // slide up the contexts, updating them
  var model, c, cc;
  for (c=0; c <= MAX_CONTEXT; c++) {
    cc = contextString.slice(MAX_CONTEXT - c);
    model = this.contexts[cc];
    if (!model) {
      model = this.contexts[cc] = this.newContext();
    }
    if (c >= matchLevel) {
      // only update useful contexts
      model.update(symbol, DMM_INCREMENT / 2);
    }
    // refcount all contexts, whether used/updated or not
    model.refcount++;
  }
  // now garbage-collect old contexts
  contextString = this.window.context(this.window.pos + MAX_CONTEXT,
                                      MAX_CONTEXT);
  var firstPass = this.window.firstPass;
  for (c=MAX_CONTEXT; c>=0 && !firstPass; c--) {
    cc = contextString.slice(0, c);
    model = this.contexts[cc];
    console.assert(model);
    if ((--model.refcount) <= 0) {
      console.assert(cc !== ''); // don't allow context-0 to be gc'ed!
      delete this.contexts[cc];
    }
  }
  // ok, advance window.
  this.window.put(symbol);
};
PPM.prototype.decode = function() {
  var contextString = this.window.context(this.window.pos, MAX_CONTEXT);
  var exclude = this.newExclude();
  var model, c, cc, symbol;
  for (c=MAX_CONTEXT; c>=0; c--) {
    cc = contextString.slice(MAX_CONTEXT - c);
    model = this.contexts[cc];
    if (model) {
      symbol = model.decode(exclude);
      if (symbol >= 0) {
        this.update(symbol, contextString, c);
        return symbol;
      }
    }
  }
  // still no match, fall back to context -1
  symbol = this.cm1coder.decode(exclude);
  this.update(symbol, contextString, c);
  return symbol;
};
PPM.prototype.encode = function(symbol) {
  var contextString = this.window.context(this.window.pos, MAX_CONTEXT);
  var exclude = this.newExclude();
  var c;
  for (c=MAX_CONTEXT; c>=0; c--) {
    var cc = contextString.slice(MAX_CONTEXT - c);
    var model = this.contexts[cc];
    if (model) {
      var success = model.encode(symbol, exclude);
      if (success) {
        this.update(symbol, contextString, c);
        return;
      }
    }
  }
  // fall back to context -1 (but still use exclusion table)
  this.cm1coder.encode(symbol, exclude);
  this.update(symbol, contextString, c);
  return;
};

PPM.MAGIC = 'ppm2';
PPM.compressFile = Util.compressFileHelper(PPM.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {
  var range = new RangeCoder(outStream);
  range.encodeStart(finalByte, 1);
  var model = new PPM(range, (fileSize<0) ? 257 : 256);
  Util.compressWithModel(inStream, fileSize, model);
  range.encodeFinish();
}, true);
PPM.decompressFile = Util.decompressFileHelper(PPM.MAGIC, function(inStream, outStream, fileSize) {
  var range = new RangeCoder(inStream);
  range.decodeStart(true/*we already read the 'free' byte*/);
  var model = new PPM(range, (fileSize<0) ? 257 : 256);
  Util.decompressWithModel(outStream, fileSize, model);
  range.decodeFinish();
});

module.exports = PPM;

},{"./RangeCoder":20,"./Util":23}],20:[function(require,module,exports){
/* Range Coder.  Inspired by rangecod.c from rngcod13.zip from
 *    http://www.compressconsult.com/rangecoder/
 * This JavaScript version is:
 *    Copyright (c) 2013 C. Scott Ananian.
 */

// Uses 32-bit integer math.  Hopefully the JavaScript runtime figures
// that out. ;)
// see https://github.com/kripken/emscripten/wiki/LLVM-Types-in-JavaScript
// for some hints on doing 32-bit unsigned match in JavaScript.
// One key is the use of ">>>0" to change a signed result to unsigned.
var CODE_BITS = 32;
var Top_value = Math.pow(2, CODE_BITS-1);
var SHIFT_BITS = (CODE_BITS - 9);
var EXTRA_BITS = ((CODE_BITS-2) % 8 + 1);
var Bottom_value = (Top_value >>> 8);

var MAX_INT = Math.pow(2, CODE_BITS) - 1;

/* it is highly recommended that the total frequency count is less  */
/* than 1 << 19 to minimize rounding effects.                       */
/* the total frequency count MUST be less than 1<<23                */


var RangeCoder = function(stream) {
    this.low = 0; /* low end of interval */
    this.range = Top_value; /* length of interval */
    this.buffer = 0; /* buffer for input/output */
    this.help = 0; /* bytes_to_follow / intermediate value */
    this.bytecount = 0; /* counter for output bytes */
    this.stream = stream;
};

/* Do the normalization before we need a defined state, instead of
    * after messing it up.  This simplifies starting and ending. */
var enc_normalize = function(rc, outputStream) {
    while (rc.range <= Bottom_value) { /* do we need renormalization? */
        if (rc.low < (0xFF << SHIFT_BITS)) {//no carry possible, so output
            outputStream.writeByte(rc.buffer);
            for (; rc.help; rc.help--)
                outputStream.writeByte(0xFF);
            rc.buffer = (rc.low >>> SHIFT_BITS) & 0xFF;
        } else if (rc.low & Top_value) { /* carry now, no future carry */
            outputStream.writeByte(rc.buffer+1);
            for (; rc.help; rc.help--)
                outputStream.writeByte(0x00);
            rc.buffer = (rc.low >>> SHIFT_BITS) & 0xFF;
        } else {
            rc.help++;
            if (rc.help > MAX_INT)
                throw new Error("Too many bytes outstanding, "+
                                "file too large!");
        }
        rc.range = (rc.range << 8) >>> 0;/*ensure result remains positive*/
        rc.low = ((rc.low << 8) & (Top_value - 1)) >>> 0; /* unsigned */
        rc.bytecount++;
    }
};

/* Start the encoder                                         */
/* c is written as the first byte in the datastream.
    * one could do w/o, but then you have an additional if per output byte */
RangeCoder.prototype.encodeStart = function(c, initlength) {
    this.low = 0;
    this.range = Top_value;
    this.buffer = c;
    this.help = 0;
    this.bytecount = initlength;
};

/* Encode a symbol using frequencies                         */
/* rc is the range coder to be used                          */
/* sy_f is the interval length (frequency of the symbol)     */
/* lt_f is the lower end (frequency sum of < symbols)        */
/* tot_f is the total interval length (total frequency sum)  */
/* or (faster): tot_f = (code_value)1<<shift                             */
RangeCoder.prototype.encodeFreq = function(sy_f, lt_f, tot_f) {
    enc_normalize(this, this.stream);
    var r = (this.range / tot_f) >>> 0; // note coercion to integer
    var tmp = r * lt_f;
    this.low += tmp;
    if ((lt_f + sy_f) < tot_f) {
        this.range = r * sy_f;
    } else {
        this.range -= tmp;
    }
};
RangeCoder.prototype.encodeShift = function(sy_f, lt_f, shift) {
    enc_normalize(this, this.stream);
    var r = this.range >>> shift;
    var tmp = r * lt_f;
    this.low += tmp;
    if ((lt_f + sy_f) >>> shift) {
        this.range -= tmp;
    } else {
        this.range = r * sy_f;
    }
};
/* Encode a bit w/o modelling. */
RangeCoder.prototype.encodeBit = function(b) {
    this.encodeShift(1, b?1:0, 1);
};
/* Encode a byte w/o modelling. */
RangeCoder.prototype.encodeByte = function(b) {
    this.encodeShift(1, b, 8);
};
/* Encode a short w/o modelling. */
RangeCoder.prototype.encodeShort = function(s) {
    this.encodeShift(1, s, 16);
};

/* Finish encoding                                           */
/* returns number of bytes written                           */
RangeCoder.prototype.encodeFinish = function() {
    var outputStream = this.stream;
    enc_normalize(this, outputStream);
    this.bytecount += 5;
    var tmp = this.low >>> SHIFT_BITS;
    if ((this.low & (Bottom_value-1)) >= ((this.bytecount&0xFFFFFF)>>>1)) {
        tmp++;
    }
    if (tmp > 0xFF) { /* we have a carry */
        outputStream.writeByte(this.buffer + 1);
        for (; this.help; this.help--)
            outputStream.writeByte(0x00);
    } else { /* no carry */
        outputStream.writeByte(this.buffer);
        for (; this.help; this.help--)
            outputStream.writeByte(0xFF);
    }
    outputStream.writeByte(tmp & 0xFF);
    // XXX: i'm pretty sure these could be three arbitrary bytes
    //      they are consumed by the decoder at the end
    outputStream.writeByte((this.bytecount >>> 16) & 0xFF);
    outputStream.writeByte((this.bytecount >>>  8) & 0xFF);
    outputStream.writeByte((this.bytecount       ) & 0xFF);
    return this.bytecount;
};

/* Start the decoder; you need to provide the *second* byte from the
    * datastream. (The first byte was provided to startEncoding and is
    * ignored by the decoder.)
    */
RangeCoder.prototype.decodeStart = function(skipInitialRead) {
    var c = skipInitialRead ? 0 : this.stream.readByte();
    if (typeof(c) !== 'number' || c < 0) {
        return c; // EOF
    }
    this.buffer = this.stream.readByte();
    this.low = this.buffer >>> (8 - EXTRA_BITS);
    this.range = 1 << EXTRA_BITS;
    return c;
};

var dec_normalize = function(rc, inputStream) {
    while (rc.range <= Bottom_value) {
        rc.low = (rc.low << 8) | ((rc.buffer << EXTRA_BITS) & 0xFF);
        /* rc.low could be negative here; don't fix it quite yet */
        rc.buffer = inputStream.readByte();
        rc.low |= rc.buffer >>> (8-EXTRA_BITS);
        rc.low = rc.low >>> 0; /* fix it now */
        rc.range = (rc.range << 8) >>> 0; /* ensure stays positive */
    }
};

/* Calculate cumulative frequency for next symbol. Does NO update!*/
/* rc is the range coder to be used                          */
/* tot_f is the total frequency                              */
/* or: totf is (code_value)1<<shift                                      */
/* returns the <= cumulative frequency                         */
RangeCoder.prototype.decodeCulFreq = function(tot_f) {
    dec_normalize(this, this.stream);
    this.help = (this.range / tot_f) >>> 0; // note coercion to integer
    var tmp = (this.low / this.help) >>> 0; // again
    return (tmp >= tot_f ? tot_f-1 : tmp);
};
RangeCoder.prototype.decodeCulShift = function(shift) {
    dec_normalize(this, this.stream);
    this.help = this.range >>> shift;
    var tmp = (this.low / this.help) >>> 0; // coercion to unsigned
    // shift is less than 31, so shift below will remain positive
    return ((tmp>>>shift) ? (1<<shift)-1 : tmp);
};

/* Update decoding state                                     */
/* rc is the range coder to be used                          */
/* sy_f is the interval length (frequency of the symbol)     */
/* lt_f is the lower end (frequency sum of < symbols)        */
/* tot_f is the total interval length (total frequency sum)  */
RangeCoder.prototype.decodeUpdate = function(sy_f, lt_f, tot_f) {
    var tmp = this.help * lt_f; // should not overflow!
    this.low -= tmp;
    if (lt_f + sy_f < tot_f) {
        this.range = (this.help * sy_f);
    } else {
        this.range -= tmp;
    }
};

/* Decode a bit w/o modelling. */
RangeCoder.prototype.decodeBit = function() {
    var tmp = this.decodeCulShift(1);
    this.decodeUpdate(1, tmp, 1<<1);
    return tmp;
};
/* decode a byte w/o modelling */
RangeCoder.prototype.decodeByte = function() {
    var tmp = this.decodeCulShift(8);
    this.decodeUpdate(1, tmp, 1<<8);
    return tmp;
};
/* decode a short w/o modelling */
RangeCoder.prototype.decodeShort = function() {
    var tmp = this.decodeCulShift(16);
    this.decodeUpdate(1, tmp, 1<<16);
    return tmp;
};

/* Finish decoding */
RangeCoder.prototype.decodeFinish = function() {
    /* normalize to use up all bytes */
    dec_normalize(this, this.stream);
};

/** Utility functions */

// bitstream interface
RangeCoder.prototype.writeBit = RangeCoder.prototype.encodeBit;
RangeCoder.prototype.readBit = RangeCoder.prototype.decodeBit;

// stream interface
RangeCoder.prototype.writeByte = RangeCoder.prototype.encodeByte;
RangeCoder.prototype.readByte = RangeCoder.prototype.decodeByte;

module.exports = RangeCoder;

},{}],21:[function(require,module,exports){
/* *Very* simple de/compression utility, based on simple_c and simple_d from
 * rngcod13.zip at http://www.compressconsult.com/rangecoder/
 * Really just a demonstration/test of the rangecoder.
 */
const RangeCoder = require('./RangeCoder');
const Stream = require('./Stream');
const Util = require('./Util');

var MAX_BLOCK_SIZE = 1<<17;

var Simple = Object.create(null);
Simple.MAGIC = 'smpl';
Simple.compressFile = Util.compressFileHelper(Simple.MAGIC, function(input, output, size, props, finalByte) {
    var encoder = new RangeCoder(output);
    encoder.encodeStart(finalByte, 1);

    // read a block
    var block = Util.makeU8Buffer(MAX_BLOCK_SIZE);
    var counts = [];
    var blockLength = 0, sawEOF = false;

    var readBlock = function() {
        var pos = 0;
        // initialize counts
        for (pos=0; pos < 256; pos++) {
            counts[pos] = 0;
        }
        if (sawEOF) {
            blockLength = 0;
            return;
        }
        for (pos=0; pos < MAX_BLOCK_SIZE; ) {
            var c = input.readByte();
            if (c===Stream.EOF) {
                sawEOF = true;
                break;
            }
            block[pos++] = c;
            counts[c]++;
            // bail if some count reaches maximum
            if (counts[c]===0xFFFF) {
                break;
            }
        }
        blockLength = pos;
    };

    while (true) {
        var i;
        readBlock();
        if (sawEOF && blockLength===0) {
            break;
        }
        // indicate that there's another block comin'
        encoder.encodeBit(true);
        // write all the statistics
        for (i=0; i<256; i++) {
            encoder.encodeShort(counts[i]);
        }
        // convert counts to cumulative counts
        counts[256] = blockLength;
        for (i=256; i; i--) {
            counts[i-1] = counts[i] - counts[i-1];
        }
        // encode the symbols using the probability table.
        for (i=0; i<blockLength; i++) {
            var ch = block[i];
            encoder.encodeFreq(counts[ch+1]-counts[ch], counts[ch],
                                counts[256]);
        }
    }
    // write a stop bit
    encoder.encodeBit(false);
    // done!
    encoder.encodeFinish();
}, true);
Simple.decompressFile = Util.decompressFileHelper(Simple.MAGIC, function(input, output, size) {
    var decoder = new RangeCoder(input);
    decoder.decodeStart(true/*we already read the 'free' byte*/);
    while (decoder.decodeBit()) {
        var i, counts = [];
        // read all the statistics
        for (i=0; i<256; i++) {
            counts[i] = decoder.decodeShort();
        }
        // compute cumulative stats & total block size
        var blocksize = 0;
        for (i=0; i<256; i++) {
            var tmp = counts[i];
            counts[i] = blocksize;
            blocksize += tmp;
        }
        counts[256] = blocksize;

        for (i=0; i<blocksize; i++) {
            var cf = decoder.decodeCulFreq(blocksize);
            // inefficient way to look up the symbol.
            var symbol;
            for (symbol=0; symbol<256; symbol++)
                // careful, there are length-0 ranges
                // (where counts[symbol]===counts[symbol+1])
                if (counts[symbol]<=cf && cf < counts[symbol+1])
                    break;
            var ch = symbol;
            decoder.decodeUpdate(counts[symbol+1] - counts[symbol],
                                    counts[symbol], blocksize);
            output.writeByte(symbol);
        }
    }
    decoder.decodeFinish();
});
module.exports = Simple;

},{"./RangeCoder":20,"./Stream":22,"./Util":23}],22:[function(require,module,exports){
/** Abstract Stream interface, for byte-oriented i/o. */
const freeze = require('./freeze');

var EOF = -1;

var Stream = function() {
    /* ABSTRACT */
};
// you must define one of read / readByte for a readable stream
Stream.prototype.readByte = function() {
    var buf = [ 0 ];
    var len = this.read(buf, 0, 1);
    if (len===0) { this._eof = true; return EOF; }
    return buf[0];
};
Stream.prototype.read = function(buf, bufOffset, length) {
    var ch, bytesRead = 0;
    while (bytesRead < length) {
        ch = this.readByte();
        if (ch === EOF) { this._eof = true; break; }
        buf[bufOffset+(bytesRead++)] = ch;
    }
    return bytesRead;
};
// reasonable default implementation of 'eof'
Stream.prototype.eof = function() { return !!this._eof; };
// not all readable streams are seekable
Stream.prototype.seek = function(pos) {
    throw new Error('Stream is not seekable.');
};
Stream.prototype.tell = function() {
    throw new Error('Stream is not seekable.');
};
// you must define one of write / writeByte for a writable stream
Stream.prototype.writeByte = function(_byte) {
    var buf = [ _byte ];
    this.write(buf, 0, 1);
};
Stream.prototype.write = function(buf, bufOffset, length) {
    var i;
    for (i=0; i<length; i++) {
        this.writeByte(buf[bufOffset + i]);
    }
    return length;
};
// flush will happily do nothing if you don't override it.
Stream.prototype.flush = function() { };

// export EOF as a constant.
Stream.EOF = EOF;

module.exports = freeze(Stream);

},{"./freeze":24}],23:[function(require,module,exports){
(function (process,Buffer){(function (){
/* Some basic utilities, used in a number of places. */

const freeze = require('./freeze');
const Stream = require('./Stream');

var Util = Object.create(null);
var EOF = Stream.EOF;

/* Take a buffer, array, or stream, and return an input stream. */
Util.coerceInputStream = function(input, forceRead) {
    if (!('readByte' in input)) {
        var buffer = input;
        input = new Stream();
        input.size = buffer.length;
        input.pos = 0;
        input.readByte = function() {
            if (this.pos >= this.size) { return EOF; }
            return buffer[this.pos++];
        };
        input.read = function(buf, bufOffset, length) {
            var bytesRead = 0;
            while (bytesRead < length && this.pos < buffer.length) {
                buf[bufOffset++] = buffer[this.pos++];
                bytesRead++;
            }
            return bytesRead;
        };
        input.seek = function(pos) { this.pos = pos; };
        input.tell = function() { return this.pos; };
        input.eof = function() { return this.pos >= buffer.length; };
    } else if (forceRead && !('read' in input)) {
        // wrap input if it doesn't implement read
        var s = input;
        input = new Stream();
        input.readByte = function() {
            var ch = s.readByte();
            if (ch === EOF) { this._eof = true; }
            return ch;
        };
        if ('size' in s) { input.size = s.size; }
        if ('seek' in s) {
            input.seek = function(pos) {
                s.seek(pos); // may throw if s doesn't implement seek
                this._eof = false;
            };
        }
        if ('tell' in s) {
            input.tell = s.tell.bind(s);
        }
    }
    return input;
};

var BufferStream = function(buffer, resizeOk) {
    this.buffer = buffer;
    this.resizeOk = resizeOk;
    this.pos = 0;
};
BufferStream.prototype = Object.create(Stream.prototype);
BufferStream.prototype.writeByte = function(_byte) {
    if (this.resizeOk && this.pos >= this.buffer.length) {
        var newBuffer = Util.makeU8Buffer(this.buffer.length * 2);
        newBuffer.set(this.buffer);
        this.buffer = newBuffer;
    }
    this.buffer[this.pos++] = _byte;
};
BufferStream.prototype.getBuffer = function() {
    // trim buffer if needed
    if (this.pos !== this.buffer.length) {
        if (!this.resizeOk)
            throw new TypeError('outputsize does not match decoded input');
        var newBuffer = Util.makeU8Buffer(this.pos);
        newBuffer.set(this.buffer.subarray(0, this.pos));
        this.buffer = newBuffer;
    }
    return this.buffer;
};

/* Take a stream (or not) and an (optional) size, and return an
    * output stream.  Return an object with a 'retval' field equal to
    * the output stream (if that was given) or else a pointer at the
    * internal Uint8Array/buffer/array; and a 'stream' field equal to
    * an output stream to use.
    */
Util.coerceOutputStream = function(output, size) {
    var r = { stream: output, retval: output };
    if (output) {
        if (typeof(output)==='object' && 'writeByte' in output) {
            return r; /* leave output alone */
        } else if (typeof(size) === 'number') {
            console.assert(size >= 0);
            r.stream = new BufferStream(Util.makeU8Buffer(size), false);
        } else { // output is a buffer
            r.stream = new BufferStream(output, false);
        }
    } else {
        r.stream = new BufferStream(Util.makeU8Buffer(16384), true);
    }
    Object.defineProperty(r, 'retval', {
        get: r.stream.getBuffer.bind(r.stream)
    });
    return r;
};

Util.compressFileHelper = function(magic, guts, suppressFinalByte) {
    return function(inStream, outStream, props) {
        inStream = Util.coerceInputStream(inStream);
        var o = Util.coerceOutputStream(outStream, outStream);
        outStream = o.stream;

        // write the magic number to identify this file type
        // (it better be ASCII, we're not doing utf-8 conversion)
        var i;
        for (i=0; i<magic.length; i++) {
            outStream.writeByte(magic.charCodeAt(i));
        }

        // if we know the size, write it
        var fileSize;
        if ('size' in inStream && inStream.size >= 0) {
            fileSize = inStream.size;
        } else {
            fileSize = -1; // size unknown
        }
        if (suppressFinalByte) {
            var tmpOutput = Util.coerceOutputStream([]);
            Util.writeUnsignedNumber(tmpOutput.stream, fileSize + 1);
            tmpOutput = tmpOutput.retval;
            for (i=0; i<tmpOutput.length-1; i++) {
                outStream.writeByte(tmpOutput[i]);
            }
            suppressFinalByte = tmpOutput[tmpOutput.length-1];
        } else {
            Util.writeUnsignedNumber(outStream, fileSize + 1);
        }

        // call the guts to do the real compression
        guts(inStream, outStream, fileSize, props, suppressFinalByte);

        return o.retval;
    };
};
Util.decompressFileHelper = function(magic, guts) {
    return function(inStream, outStream) {
        inStream = Util.coerceInputStream(inStream);

        // read the magic number to confirm this file type
        // (it better be ASCII, we're not doing utf-8 conversion)
        var i;
        for (i=0; i<magic.length; i++) {
            if (magic.charCodeAt(i) !== inStream.readByte()) {
                throw new Error("Bad magic");
            }
        }

        // read the file size & create an appropriate output stream/buffer
        var fileSize = Util.readUnsignedNumber(inStream) - 1;
        var o = Util.coerceOutputStream(outStream, fileSize);
        outStream = o.stream;

        // call the guts to do the real decompression
        guts(inStream, outStream, fileSize);

        return o.retval;
    };
};
// a helper for simple self-test of model encode
Util.compressWithModel = function(inStream, fileSize, model) {
    var inSize = 0;
    while (inSize !== fileSize) {
        var ch = inStream.readByte();
        if (ch === EOF) {
            model.encode(256); // end of stream;
            break;
        }
        model.encode(ch);
        inSize++;
    }
};
// a helper for simple self-test of model decode
Util.decompressWithModel = function(outStream, fileSize, model) {
    var outSize = 0;
    while (outSize !== fileSize) {
        var ch = model.decode();
        if (ch === 256) {
            break; // end of stream;
        }
        outStream.writeByte(ch);
        outSize++;
    }
};

/** Write a number using a self-delimiting big-endian encoding. */
Util.writeUnsignedNumber = function(output, n) {
    console.assert(n >= 0);
    var bytes = [], i;
    do {
        bytes.push(n & 0x7F);
        // use division instead of shift to allow encoding numbers up to
        // 2^53
        n = Math.floor( n / 128 );
    } while (n !== 0);
    bytes[0] |= 0x80; // mark end of encoding.
    for (i=bytes.length-1; i>=0; i--) {
        output.writeByte(bytes[i]); // write in big-endian order
    }
    return output;
};

/** Read a number using a self-delimiting big-endian encoding. */
Util.readUnsignedNumber = function(input) {
    var n = 0, c;
    while (true) {
        c = input.readByte();
        if (c&0x80) { n += (c&0x7F); break; }
        // using + and * instead of << allows decoding numbers up to 2^53
        n = (n + c) * 128;
    }
    return n;
};

// Compatibility thunks for Buffer/TypedArray constructors.

var zerofill = function(a) {
    for (var i = 0, len = a.length; i < len; i++) {
        a[i] = 0;
    }
    return a;
};

var fallbackarray = function(size) {
    return zerofill(new Array(size));
};

// Node 0.11.6 - 0.11.10ish don't properly zero fill typed arrays.
// See https://github.com/joyent/node/issues/6664
// Try to detect and workaround the bug.
var ensureZeroed = function id(a) { return a; };
if ((typeof(process) !== 'undefined') &&
    Array.prototype.some.call(new Uint32Array(128), function(x) {
        return x !== 0;
    })) {
    //console.warn('Working around broken TypedArray');
    ensureZeroed = zerofill;
}

/** Portable 8-bit unsigned buffer. */
Util.makeU8Buffer = (typeof(Uint8Array) !== 'undefined') ? function(size) {
    // Uint8Array ought to be  automatically zero-filled
    return ensureZeroed(new Uint8Array(size));
} : (typeof(Buffer) !== 'undefined') ? function(size) {
    var b = new Buffer(size);
    b.fill(0);
    return b;
} : fallbackarray;

/** Portable 16-bit unsigned buffer. */
Util.makeU16Buffer = (typeof(Uint16Array) !== 'undefined') ? function(size) {
    // Uint16Array ought to be  automatically zero-filled
    return ensureZeroed(new Uint16Array(size));
} : fallbackarray;

/** Portable 32-bit unsigned buffer. */
Util.makeU32Buffer = (typeof(Uint32Array) !== 'undefined') ? function(size) {
    // Uint32Array ought to be  automatically zero-filled
    return ensureZeroed(new Uint32Array(size));
} : fallbackarray;

/** Portable 32-bit signed buffer. */
Util.makeS32Buffer = (typeof(Int32Array) !== 'undefined') ? function(size) {
    // Int32Array ought to be  automatically zero-filled
    return ensureZeroed(new Int32Array(size));
} : fallbackarray;

Util.arraycopy = function(dst, src) {
    console.assert(dst.length >= src.length);
    for (var i = 0, len = src.length; i < len ; i++) {
        dst[i] = src[i];
    }
    return dst;
};

/** Highest bit set in a byte. */
var bytemsb = [
    0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 /* 256 */
];
console.assert(bytemsb.length===0x100);
/** Find last set (most significant bit).
 *  @return the last bit set in the argument.
 *          <code>fls(0)==0</code> and <code>fls(1)==1</code>. */
var fls = Util.fls = function(v) {
    console.assert(v>=0);
    if (v > 0xFFFFFFFF) { // use floating-point mojo
        return 32 + fls(Math.floor(v / 0x100000000));
    }
    if ( (v & 0xFFFF0000) !== 0) {
        if ( (v & 0xFF000000) !== 0) {
            return 24 + bytemsb[(v>>>24) & 0xFF];
        } else {
            return 16 + bytemsb[v>>>16];
        }
    } else if ( (v & 0x0000FF00) !== 0) {
        return 8 + bytemsb[v>>>8];
    } else {
        return bytemsb[v];
    }
};
/** Returns ceil(log2(n)) */
Util.log2c = function(v) {
    return (v===0)?-1:fls(v-1);
};

module.exports = freeze(Util); // ensure constants are recognized as such.

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)
},{"./Stream":22,"./freeze":24,"_process":36,"buffer":28}],24:[function(require,module,exports){
'use strict';

// Object.freeze(), or a thunk if that method is not present in this
// JavaScript environment.

if (Object.freeze) {
    module.exports = Object.freeze;
} else {
    module.exports = function(o) { return o; };
}

},{}],25:[function(require,module,exports){
const freeze = require('./lib/freeze');
const BitStream = require('./lib/BitStream');
const Stream = require('./lib/Stream');
const BWT = require('./lib/BWT');
const Context1Model = require('./lib/Context1Model');
const DefSumModel = require('./lib/DefSumModel');
const FenwickModel = require('./lib/FenwickModel');
const MTFModel = require('./lib/MTFModel');
const NoModel = require('./lib/NoModel');
const Huffman = require('./lib/Huffman');
const RangeCoder = require('./lib/RangeCoder');
const BWTC = require('./lib/BWTC');
const Bzip2 = require('./lib/Bzip2');
const Dmc = require('./lib/Dmc');
const Lzjb = require('./lib/Lzjb');
const LzjbR = require('./lib/LzjbR');
const Lzp3 = require('./lib/Lzp3');
const PPM = require('./lib/PPM');
const Simple = require('./lib/Simple');

module.exports = freeze({
    version: "1.2.0",
    // APIs
    BitStream: BitStream,
    Stream: Stream,
    // transforms
    BWT: BWT,
    // models and coder
    Context1Model: Context1Model,
    DefSumModel: DefSumModel,
    FenwickModel: FenwickModel,
    MTFModel: MTFModel,
    NoModel: NoModel,
    Huffman: Huffman,
    RangeCoder: RangeCoder,
    // compression methods
    BWTC: BWTC,
    Bzip2: Bzip2,
    Dmc: Dmc,
    Lzjb: Lzjb,
    LzjbR: LzjbR,
    Lzp3: Lzp3,
    PPM: PPM,
    Simple: Simple
});

},{"./lib/BWT":2,"./lib/BWTC":3,"./lib/BitStream":4,"./lib/Bzip2":5,"./lib/Context1Model":7,"./lib/DefSumModel":8,"./lib/Dmc":9,"./lib/FenwickModel":10,"./lib/Huffman":11,"./lib/Lzjb":14,"./lib/LzjbR":15,"./lib/Lzp3":16,"./lib/MTFModel":17,"./lib/NoModel":18,"./lib/PPM":19,"./lib/RangeCoder":20,"./lib/Simple":21,"./lib/Stream":22,"./lib/freeze":24}],26:[function(require,module,exports){
(function(d,e){"object"===typeof exports&&"undefined"!==typeof module?e(exports):"function"===typeof define&&define.amd?define(["exports"],e):(d=d||self,e(d.alawmulaw={}))})(this,function(d){function e(a){a=-32768==a?-32767:a;var c=~a>>8&128;c||(a*=-1);32635<a&&(a=32635);if(256<=a){var b=k[a>>8&127];a=b<<4|a>>b+3&15}else a>>=4;return a^c^85}function f(a){var c=0;a^=85;a&128&&(a&=-129,c=-1);var b=((a&240)>>4)+4;a=4!=b?1<<b|(a&15)<<b-4|1<<b-5:a<<1|1;return-8*(0===c?a:-a)}function g(a){var c=a>>8&128;
0!=c&&(a=-a);a+=132;32635<a&&(a=32635);var b=l[a>>7&255];return~(c|b<<4|a>>b+3&15)}function h(a){a=~a;var c=a>>4&7;c=m[c]+((a&15)<<c+3);0!=(a&128)&&(c=-c);return c}var k=[1,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7],n=Object.freeze({__proto__:null,encodeSample:e,decodeSample:f,encode:function(a){for(var c=
new Uint8Array(a.length),b=0;b<a.length;b++)c[b]=e(a[b]);return c},decode:function(a){for(var c=new Int16Array(a.length),b=0;b<a.length;b++)c[b]=f(a[b]);return c}}),l=[0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7],m=[0,132,396,924,1980,4092,8316,16764],p=Object.freeze({__proto__:null,encodeSample:g,decodeSample:h,encode:function(a){for(var c=new Uint8Array(a.length),b=0;b<a.length;b++)c[b]=g(a[b]);return c},decode:function(a){for(var c=new Int16Array(a.length),b=0;b<a.length;b++)c[b]=h(a[b]);return c}});d.alaw=n;d.mulaw=p;Object.defineProperty(d,
"__esModule",{value:!0})});

},{}],27:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],28:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"base64-js":27,"buffer":28,"ieee754":30}],29:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

const base64 = require('base64-js')
const ieee754 = require('ieee754')
const customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

const K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    const arr = new Uint8Array(1)
    const proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  const valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  const b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  const length = byteLength(string, encoding) | 0
  let buf = createBuffer(length)

  const actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0
  const buf = createBuffer(length)
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    const copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  let buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0
    const buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  let x = a.length
  let y = b.length

  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  let i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  const buffer = Buffer.allocUnsafe(length)
  let pos = 0
  for (i = 0; i < list.length; ++i) {
    let buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
        buf.copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  const len = string.length
  const mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  let loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  const i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  const len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  const len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  const len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  const length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  let str = ''
  const max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  let x = thisEnd - thisStart
  let y = end - start
  const len = Math.min(x, y)

  const thisCopy = this.slice(thisStart, thisEnd)
  const targetCopy = target.slice(start, end)

  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  let indexSize = 1
  let arrLength = arr.length
  let valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  let i
  if (dir) {
    let foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      let found = true
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  const remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  const strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  let i
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  const remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  const res = []

  let i = start
  while (i < end) {
    const firstByte = buf[i]
    let codePoint = null
    let bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  const len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = ''
  let i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  const len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  let out = ''
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  const bytes = buf.slice(start, end)
  let res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  const len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  const newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  let val = this[offset + --byteLength]
  let mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24

  const hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
})

Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  const lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
})

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let i = byteLength
  let mul = 1
  let val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24) // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
})

Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
})

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let mul = 1
  let i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let i = byteLength - 1
  let mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function wrtBigUInt64LE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  return offset
}

function wrtBigUInt64BE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset + 7] = lo
  lo = lo >> 8
  buf[offset + 6] = lo
  lo = lo >> 8
  buf[offset + 5] = lo
  lo = lo >> 8
  buf[offset + 4] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset + 3] = hi
  hi = hi >> 8
  buf[offset + 2] = hi
  hi = hi >> 8
  buf[offset + 1] = hi
  hi = hi >> 8
  buf[offset] = hi
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = 0
  let mul = 1
  let sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = byteLength - 1
  let mul = 1
  let sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  const len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  let i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    const bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    const len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors = {}
function E (sym, getMessage, Base) {
  errors[sym] = class NodeError extends Base {
    constructor () {
      super()

      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      })

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name
    }

    get code () {
      return sym
    }

    set code (value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      })
    }

    toString () {
      return `${this.name} [${sym}]: ${this.message}`
    }
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS',
  function (name) {
    if (name) {
      return `${name} is outside of buffer bounds`
    }

    return 'Attempt to access memory outside buffer bounds'
  }, RangeError)
E('ERR_INVALID_ARG_TYPE',
  function (name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  }, TypeError)
E('ERR_OUT_OF_RANGE',
  function (str, range, input) {
    let msg = `The value of "${str}" is out of range.`
    let received = input
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    }
    msg += ` It must be ${range}. Received ${received}`
    return msg
  }, RangeError)

function addNumericalSeparator (val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}

// CHECK FUNCTIONS
// ===============

function checkBounds (buf, offset, byteLength) {
  validateNumber(offset, 'offset')
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1))
  }
}

function checkIntBI (value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : ''
    let range
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                `${(byteLength + 1) * 8 - 1}${n}`
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  }
  checkBounds(buf, offset, byteLength)
}

function validateNumber (value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
}

function boundsError (value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type)
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                    `>= ${type ? 1 : 0} and <= ${length}`,
                                    value)
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  let codePoint
  const length = string.length
  let leadSurrogate = null
  const bytes = []

  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  let c, hi, lo
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  let i
  for (i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = (function () {
  const alphabet = '0123456789abcdef'
  const table = new Array(256)
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

// Return not function with Error if BigInt not supported
function defineBigIntMethod (fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
}

function BufferBigIntNotDefined () {
  throw new Error('BigInt not supported')
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"base64-js":27,"buffer":28,"ieee754":30}],30:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],31:[function(require,module,exports){
"use strict"

function iota(n) {
  var result = new Array(n)
  for(var i=0; i<n; ++i) {
    result[i] = i
  }
  return result
}

module.exports = iota
},{}],32:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],33:[function(require,module,exports){
module.exports = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};

},{}],34:[function(require,module,exports){
var iota = require("iota-array")
var isBuffer = require("is-buffer")

var hasTypedArrays  = ((typeof Float64Array) !== "undefined")

function compare1st(a, b) {
  return a[0] - b[0]
}

function order() {
  var stride = this.stride
  var terms = new Array(stride.length)
  var i
  for(i=0; i<terms.length; ++i) {
    terms[i] = [Math.abs(stride[i]), i]
  }
  terms.sort(compare1st)
  var result = new Array(terms.length)
  for(i=0; i<result.length; ++i) {
    result[i] = terms[i][1]
  }
  return result
}

function compileConstructor(dtype, dimension) {
  var className = ["View", dimension, "d", dtype].join("")
  if(dimension < 0) {
    className = "View_Nil" + dtype
  }
  var useGetters = (dtype === "generic")

  if(dimension === -1) {
    //Special case for trivial arrays
    var code =
      "function "+className+"(a){this.data=a;};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new "+className+"(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_"+className+"(a){return new "+className+"(a);}"
    var procedure = new Function(code)
    return procedure()
  } else if(dimension === 0) {
    //Special case for 0d arrays
    var code =
      "function "+className+"(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function "+className+"_copy() {\
return new "+className+"(this.data,this.offset)\
};\
proto.pick=function "+className+"_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function "+className+"_get(){\
return "+(useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]")+
"};\
proto.set=function "+className+"_set(v){\
return "+(useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v")+"\
};\
return function construct_"+className+"(a,b,c,d){return new "+className+"(a,d)}"
    var procedure = new Function("TrivialArray", code)
    return procedure(CACHED_CONSTRUCTORS[dtype][0])
  }

  var code = ["'use strict'"]

  //Create constructor for view
  var indices = iota(dimension)
  var args = indices.map(function(i) { return "i"+i })
  var index_str = "this.offset+" + indices.map(function(i) {
        return "this.stride[" + i + "]*i" + i
      }).join("+")
  var shapeArg = indices.map(function(i) {
      return "b"+i
    }).join(",")
  var strideArg = indices.map(function(i) {
      return "c"+i
    }).join(",")
  code.push(
    "function "+className+"(a," + shapeArg + "," + strideArg + ",d){this.data=a",
      "this.shape=[" + shapeArg + "]",
      "this.stride=[" + strideArg + "]",
      "this.offset=d|0}",
    "var proto="+className+".prototype",
    "proto.dtype='"+dtype+"'",
    "proto.dimension="+dimension)

  //view.size:
  code.push("Object.defineProperty(proto,'size',{get:function "+className+"_size(){\
return "+indices.map(function(i) { return "this.shape["+i+"]" }).join("*"),
"}})")

  //view.order:
  if(dimension === 1) {
    code.push("proto.order=[0]")
  } else {
    code.push("Object.defineProperty(proto,'order',{get:")
    if(dimension < 4) {
      code.push("function "+className+"_order(){")
      if(dimension === 2) {
        code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})")
      } else if(dimension === 3) {
        code.push(
"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})")
      }
    } else {
      code.push("ORDER})")
    }
  }

  //view.set(i0, ..., v):
  code.push(
"proto.set=function "+className+"_set("+args.join(",")+",v){")
  if(useGetters) {
    code.push("return this.data.set("+index_str+",v)}")
  } else {
    code.push("return this.data["+index_str+"]=v}")
  }

  //view.get(i0, ...):
  code.push("proto.get=function "+className+"_get("+args.join(",")+"){")
  if(useGetters) {
    code.push("return this.data.get("+index_str+")}")
  } else {
    code.push("return this.data["+index_str+"]}")
  }

  //view.index:
  code.push(
    "proto.index=function "+className+"_index(", args.join(), "){return "+index_str+"}")

  //view.hi():
  code.push("proto.hi=function "+className+"_hi("+args.join(",")+"){return new "+className+"(this.data,"+
    indices.map(function(i) {
      return ["(typeof i",i,"!=='number'||i",i,"<0)?this.shape[", i, "]:i", i,"|0"].join("")
    }).join(",")+","+
    indices.map(function(i) {
      return "this.stride["+i + "]"
    }).join(",")+",this.offset)}")

  //view.lo():
  var a_vars = indices.map(function(i) { return "a"+i+"=this.shape["+i+"]" })
  var c_vars = indices.map(function(i) { return "c"+i+"=this.stride["+i+"]" })
  code.push("proto.lo=function "+className+"_lo("+args.join(",")+"){var b=this.offset,d=0,"+a_vars.join(",")+","+c_vars.join(","))
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'&&i"+i+">=0){\
d=i"+i+"|0;\
b+=c"+i+"*d;\
a"+i+"-=d}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a"+i
    }).join(",")+","+
    indices.map(function(i) {
      return "c"+i
    }).join(",")+",b)}")

  //view.step():
  code.push("proto.step=function "+className+"_step("+args.join(",")+"){var "+
    indices.map(function(i) {
      return "a"+i+"=this.shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "b"+i+"=this.stride["+i+"]"
    }).join(",")+",c=this.offset,d=0,ceil=Math.ceil")
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'){\
d=i"+i+"|0;\
if(d<0){\
c+=b"+i+"*(a"+i+"-1);\
a"+i+"=ceil(-a"+i+"/d)\
}else{\
a"+i+"=ceil(a"+i+"/d)\
}\
b"+i+"*=d\
}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a" + i
    }).join(",")+","+
    indices.map(function(i) {
      return "b" + i
    }).join(",")+",c)}")

  //view.transpose():
  var tShape = new Array(dimension)
  var tStride = new Array(dimension)
  for(var i=0; i<dimension; ++i) {
    tShape[i] = "a[i"+i+"]"
    tStride[i] = "b[i"+i+"]"
  }
  code.push("proto.transpose=function "+className+"_transpose("+args+"){"+
    args.map(function(n,idx) { return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)"}).join(";"),
    "var a=this.shape,b=this.stride;return new "+className+"(this.data,"+tShape.join(",")+","+tStride.join(",")+",this.offset)}")

  //view.pick():
  code.push("proto.pick=function "+className+"_pick("+args+"){var a=[],b=[],c=this.offset")
  for(var i=0; i<dimension; ++i) {
    code.push("if(typeof i"+i+"==='number'&&i"+i+">=0){c=(c+this.stride["+i+"]*i"+i+")|0}else{a.push(this.shape["+i+"]);b.push(this.stride["+i+"])}")
  }
  code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}")

  //Add return statement
  code.push("return function construct_"+className+"(data,shape,stride,offset){return new "+className+"(data,"+
    indices.map(function(i) {
      return "shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "stride["+i+"]"
    }).join(",")+",offset)}")

  //Compile procedure
  var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"))
  return procedure(CACHED_CONSTRUCTORS[dtype], order)
}

function arrayDType(data) {
  if(isBuffer(data)) {
    return "buffer"
  }
  if(hasTypedArrays) {
    switch(Object.prototype.toString.call(data)) {
      case "[object Float64Array]":
        return "float64"
      case "[object Float32Array]":
        return "float32"
      case "[object Int8Array]":
        return "int8"
      case "[object Int16Array]":
        return "int16"
      case "[object Int32Array]":
        return "int32"
      case "[object Uint8Array]":
        return "uint8"
      case "[object Uint16Array]":
        return "uint16"
      case "[object Uint32Array]":
        return "uint32"
      case "[object Uint8ClampedArray]":
        return "uint8_clamped"
      case "[object BigInt64Array]":
        return "bigint64"
      case "[object BigUint64Array]":
        return "biguint64"
    }
  }
  if(Array.isArray(data)) {
    return "array"
  }
  return "generic"
}

var CACHED_CONSTRUCTORS = {
  "float32":[],
  "float64":[],
  "int8":[],
  "int16":[],
  "int32":[],
  "uint8":[],
  "uint16":[],
  "uint32":[],
  "array":[],
  "uint8_clamped":[],
  "bigint64": [],
  "biguint64": [],
  "buffer":[],
  "generic":[]
}

;(function() {
  for(var id in CACHED_CONSTRUCTORS) {
    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))
  }
});

function wrappedNDArrayCtor(data, shape, stride, offset) {
  if(data === undefined) {
    var ctor = CACHED_CONSTRUCTORS.array[0]
    return ctor([])
  } else if(typeof data === "number") {
    data = [data]
  }
  if(shape === undefined) {
    shape = [ data.length ]
  }
  var d = shape.length
  if(stride === undefined) {
    stride = new Array(d)
    for(var i=d-1, sz=1; i>=0; --i) {
      stride[i] = sz
      sz *= shape[i]
    }
  }
  if(offset === undefined) {
    offset = 0
    for(var i=0; i<d; ++i) {
      if(stride[i] < 0) {
        offset -= (shape[i]-1)*stride[i]
      }
    }
  }
  var dtype = arrayDType(data)
  var ctor_list = CACHED_CONSTRUCTORS[dtype]
  while(ctor_list.length <= d+1) {
    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))
  }
  var ctor = ctor_list[d+1]
  return ctor(data, shape, stride, offset)
}

module.exports = wrappedNDArrayCtor

},{"iota-array":31,"is-buffer":32}],35:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.PCMPlayer = factory());
}(this, (function () { 'use strict';

  class PCMPlayer {
    constructor(option) {
      this.init(option);
    }

    init(option) {
      const defaultOption = {
        inputCodec: 'Int16', // 传入的数据是采用多少位编码，默认16位
        channels: 1, // 声道数
        sampleRate: 8000, // 采样率 单位Hz
        flushTime: 1000 // 缓存时间 单位 ms
      };

      this.option = Object.assign({}, defaultOption, option); // 实例最终配置参数
      this.samples = new Float32Array(); // 样本存放区域
      this.interval = setInterval(this.flush.bind(this), this.option.flushTime);
      this.convertValue = this.getConvertValue();
      this.typedArray = this.getTypedArray();
      this.initAudioContext();
    }

    getConvertValue() {
      // 根据传入的目标编码位数
      // 选定转换数据所需要的基本值
      const inputCodecs = {
        'Int8': 128,
        'Int16': 32768,
        'Int32': 2147483648,
        'Float32': 1
      };
      if (!inputCodecs[this.option.inputCodec]) {
        throw new Error('wrong codec.please input one of these codecs:Int8,Int16,Int32,Float32')
      }
      return inputCodecs[this.option.inputCodec]
    }

    getTypedArray() {
      // 根据传入的目标编码位数
      // 选定前端的所需要的保存的二进制数据格式
      // 完整TypedArray请看文档
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray
      const typedArrays = {
        'Int8': Int8Array,
        'Int16': Int16Array,
        'Int32': Int32Array,
        'Float32': Float32Array
      };
      if (!typedArrays[this.option.inputCodec]) {
        throw new Error('wrong codec.please input one of these codecs:Int8,Int16,Int32,Float32')
      }
      return typedArrays[this.option.inputCodec]
    }

    initAudioContext() {
      // 初始化音频上下文的东西
      this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      // 控制音量的 GainNode
      // https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/createGain
      this.gainNode = this.audioCtx.createGain();
      this.gainNode.gain.value = 10;
      this.gainNode.connect(this.audioCtx.destination);
      this.startTime = this.audioCtx.currentTime;
    }

    static isTypedArray(data) {
      // 检测输入的数据是否为 TypedArray 类型或 ArrayBuffer 类型
      return (data.byteLength && data.buffer && data.buffer.constructor == ArrayBuffer) || data.constructor == ArrayBuffer;
    }

    isSupported(data) {
      // 数据类型是否支持
      // 目前支持 ArrayBuffer 或者 TypedArray
      if (!PCMPlayer.isTypedArray(data)) {
        throw new Error('请传入ArrayBuffer或者任意TypedArray')
      }
      return true
    }

    feed(data) {
      this.isSupported(data);

      // 获取格式化后的buffer
      data = this.getFormatedValue(data);
      // 开始拷贝buffer数据
      // 新建一个Float32Array的空间
      const tmp = new Float32Array(this.samples.length + data.length);
      // console.log(data, this.samples, this.samples.length)
      // 复制当前的实例的buffer值（历史buff)
      // 从头（0）开始复制
      tmp.set(this.samples, 0);
      // 复制传入的新数据
      // 从历史buff位置开始
      tmp.set(data, this.samples.length);
      // 将新的完整buff数据赋值给samples
      // interval定时器也会从samples里面播放数据
      this.samples = tmp;
    }

    getFormatedValue(data) {
      if (data.constructor == ArrayBuffer) {
        data = new this.typedArray(data);
      } else {
        data = new this.typedArray(data.buffer);
      }

      let float32 = new Float32Array(data.length);

      for (let i = 0; i < data.length; i++) {
        // buffer 缓冲区的数据，需要是IEEE754 里32位的线性PCM，范围从-1到+1
        // 所以对数据进行除法
        // 除以对应的位数范围，得到-1到+1的数据
        // float32[i] = data[i] / 0x8000;
        float32[i] = data[i] / this.convertValue;
      }
      return float32
    }

    volume(volume) {
      this.gainNode.gain.value = volume;
    }

    destroy() {
      if (this.interval) {
        clearInterval(this.interval);
      }
      this.samples = null;
      this.audioCtx.close();
      this.audioCtx = null;
    }

    flush() {
      if (!this.samples.length) return
      var bufferSource = this.audioCtx.createBufferSource();
      const length = this.samples.length / this.option.channels;
      const audioBuffer = this.audioCtx.createBuffer(this.option.channels, length, this.option.sampleRate);

      for (let channel = 0; channel < this.option.channels; channel++) {
        const audioData = audioBuffer.getChannelData(channel);
        let offset = channel;
        let decrement = 50;
        for (let i = 0; i < length; i++) {
          audioData[i] = this.samples[offset];
          /* fadein */
          if (i < 50) {
            audioData[i] = (audioData[i] * i) / 50;
          }
          /* fadeout*/
          if (i >= (length - 51)) {
            audioData[i] = (audioData[i] * decrement--) / 50;
          }
          offset += this.option.channels;
        }
      }

      if (this.startTime < this.audioCtx.currentTime) {
        this.startTime = this.audioCtx.currentTime;
      }
      console.log('start vs current ' + this.startTime + ' vs ' + this.audioCtx.currentTime + ' duration: ' + audioBuffer.duration);
      bufferSource.buffer = audioBuffer;
      bufferSource.connect(this.gainNode);
      bufferSource.start(this.startTime);
      this.startTime += audioBuffer.duration;
      this.samples = new Float32Array();
    }

    async pause() {
      await this.audioCtx.suspend();
    }

    async continue() {
      await this.audioCtx.resume();
    }

  }

  return PCMPlayer;

})));

},{}],36:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],37:[function(require,module,exports){
"use strict";var e=setTimeout;function t(t,n){var u=n.useCachedSetTimeout?e:setTimeout;return new Promise((function(e){u(e,t)}))}module.exports=function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},u=n.useCachedSetTimeout,r=t(e,{useCachedSetTimeout:u});function o(e){return r.then((function(){return e}))}return o.then=function(){return r.then.apply(r,arguments)},o.catch=Promise.resolve().catch,o};

},{}],38:[function(require,module,exports){
/**
 * @license tga-js 1.1.1
 * Copyright (c) 2013-2020 Vincent Thibault, Inc.
 * License: MIT
 */
var e,a;e=this,a=function(){"use strict";function e(e,a){for(var t=0;t<a.length;t++){var r=a[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(){function a(){!function(e,a){if(!(e instanceof a))throw new TypeError("Cannot call a class as a function")}(this,a)}var t,r,i;return t=a,(r=[{key:"_checkHeader",value:function(){var e=this.header;if(0===e.imageType)throw Error("No data");if(e.hasColorMap){if(e.colorMapLength>256||24!==e.colorMapDepth||1!==e.colorMapType)throw Error("Invalid colormap for indexed type")}else if(e.colorMapType)throw Error("Why does the image contain a palette ?");if(!e.width||!e.height)throw Error("Invalid image size");if(8!==e.pixelDepth&&16!==e.pixelDepth&&24!==e.pixelDepth&&32!==e.pixelDepth)throw Error('Invalid pixel size "'+e.pixelDepth+'"')}},{key:"_decodeRLE",value:function(e,a,t,r){for(var i=new Uint8Array(r),o=new Uint8Array(t),n=0;n<r;){var h=e[a++],s=1+(127&h);if(128&h){for(var g=0;g<t;++g)o[g]=e[a+g];a+=t;for(var l=0;l<s;++l)i.set(o,n),n+=t}else{s*=t;for(var f=0;f<s;++f)i[n+f]=e[a+f];n+=s,a+=s}}return i}},{key:"_getImageData8bits",value:function(e,a,t,r,i,o,n,h,s,g){for(var l=0,f=i;f!==n;f+=o)for(var p=h;p!==g;p+=s,l++){var u=a[l];e[4*(p+r*f)+3]=255,e[4*(p+r*f)+2]=t[3*u+0],e[4*(p+r*f)+1]=t[3*u+1],e[4*(p+r*f)+0]=t[3*u+2]}return e}},{key:"_getImageData16bits",value:function(e,a,t,r,i,o,n,h,s,g){for(var l=0,f=i;f!==n;f+=o)for(var p=h;p!==g;p+=s,l+=2){var u=a[l+0]|a[l+1]<<8;e[4*(p+r*f)+0]=(31744&u)>>7,e[4*(p+r*f)+1]=(992&u)>>2,e[4*(p+r*f)+2]=(31&u)>>3,e[4*(p+r*f)+3]=32768&u?0:255}return e}},{key:"_getImageData24bits",value:function(e,a,t,r,i,o,n,h,s,g){for(var l=0,f=i;f!==n;f+=o)for(var p=h;p!==g;p+=s,l+=3)e[4*(p+r*f)+3]=255,e[4*(p+r*f)+2]=a[l+0],e[4*(p+r*f)+1]=a[l+1],e[4*(p+r*f)+0]=a[l+2];return e}},{key:"_getImageData32bits",value:function(e,a,t,r,i,o,n,h,s,g){for(var l=0,f=i;f!==n;f+=o)for(var p=h;p!==g;p+=s,l+=4)e[4*(p+r*f)+2]=a[l+0],e[4*(p+r*f)+1]=a[l+1],e[4*(p+r*f)+0]=a[l+2],e[4*(p+r*f)+3]=a[l+3];return e}},{key:"_getImageDataGrey8bits",value:function(e,a,t,r,i,o,n,h,s,g){for(var l=0,f=i;f!==n;f+=o)for(var p=h;p!==g;p+=s,l++){var u=a[l];e[4*(p+r*f)+0]=u,e[4*(p+r*f)+1]=u,e[4*(p+r*f)+2]=u,e[4*(p+r*f)+3]=255}return e}},{key:"_getImageDataGrey16bits",value:function(e,a,t,r,i,o,n,h,s,g){for(var l=0,f=i;f!==n;f+=o)for(var p=h;p!==g;p+=s,l+=2)e[4*(p+r*f)+0]=a[l+0],e[4*(p+r*f)+1]=a[l+0],e[4*(p+r*f)+2]=a[l+0],e[4*(p+r*f)+3]=a[l+1];return e}},{key:"open",value:function(e,a){var t=this,r=new XMLHttpRequest;r.responseType="arraybuffer",r.open("GET",e,!0),r.onload=function(){200===r.status&&(t.load(new Uint8Array(r.response)),a&&a())},r.send(null)}},{key:"load",value:function(e){var a=0;if(e.length<18)throw Error("Not enough data to contain header");var t={idLength:e[a++],colorMapType:e[a++],imageType:e[a++],colorMapIndex:e[a++]|e[a++]<<8,colorMapLength:e[a++]|e[a++]<<8,colorMapDepth:e[a++],offsetX:e[a++]|e[a++]<<8,offsetY:e[a++]|e[a++]<<8,width:e[a++]|e[a++]<<8,height:e[a++]|e[a++]<<8,pixelDepth:e[a++],flags:e[a++]};if(t.hasEncoding=9===t.imageType||10===t.imageType||11===t.imageType,t.hasColorMap=9===t.imageType||1===t.imageType,t.isGreyColor=11===t.imageType||3===t.imageType,this.header=t,this._checkHeader(),(a+=t.idLength)>=e.length)throw Error("No data");if(t.hasColorMap){var r=t.colorMapLength*(t.colorMapDepth>>3);this.palette=e.subarray(a,a+r),a+=r}var i=t.pixelDepth>>3,o=t.width*t.height,n=o*i;t.hasEncoding?this.imageData=this._decodeRLE(e,a,i,n):this.imageData=e.subarray(a,a+(t.hasColorMap?o:n))}},{key:"getImageData",value:function(e){var a,t,r,i,o,n,h,s=this.header,g=s.width,l=s.height,f=s.flags,p=s.pixelDepth,u=s.isGreyColor,c=(48&f)>>4;switch(e||(e=document?document.createElement("canvas").getContext("2d").createImageData(g,l):{width:g,height:l,data:new Uint8ClampedArray(g*l*4)}),2===c||3===c?(i=0,o=1,n=l):(i=l-1,o=-1,n=-1),2===c||0===c?(a=0,t=1,r=g):(a=g-1,t=-1,r=-1),p){case 8:h=u?this._getImageDataGrey8bits:this._getImageData8bits;break;case 16:h=u?this._getImageDataGrey16bits:this._getImageData16bits;break;case 24:h=this._getImageData24bits;break;case 32:h=this._getImageData32bits}return h.call(this,e.data,this.imageData,this.palette,g,i,o,n,a,t,r),e}},{key:"getCanvas",value:function(){var e=this.header,a=e.width,t=e.height,r=document.createElement("canvas"),i=r.getContext("2d"),o=i.createImageData(a,t);return r.width=a,r.height=t,i.putImageData(this.getImageData(o),0,0),r}},{key:"getDataURL",value:function(e){return this.getCanvas().toDataURL(e||"image/png")}}])&&e(t.prototype,r),i&&e(t,i),a}()},"object"==typeof exports&&"undefined"!=typeof module?module.exports=a():"function"==typeof define&&define.amd?define(a):(e=e||self).TgaLoader=a();

},{}],39:[function(require,module,exports){
const Buffer = require('buffer/').Buffer;
const { Bzip2 } = require('@ledgerhq/compressjs');

// BZ is a magic symbol, h is for huffman and 1 is the level of compression (
// from 1-9)
const BZIP_HEADER = Buffer.from('BZh1'.split('').map((c) => c.charCodeAt(0)));

function decompress(
    fileData,
    _,
    archiveData,
    fileSizeCompressed,
    offset
) {
    const compressed = Buffer.from(
        archiveData.slice(offset, fileSizeCompressed + offset)
    );

    const decompressed = Bzip2.decompressFile(
        Buffer.concat([BZIP_HEADER, compressed])
    );

    fileData.set(decompressed);
}

module.exports.decompress = decompress;

},{"@ledgerhq/compressjs":25,"buffer/":29}],40:[function(require,module,exports){
const C_A = 'a'.charCodeAt(0);
const C_AT = '@'.charCodeAt(0);
const C_DOT = '.'.charCodeAt(0);
const C_EXCLM = '!'.charCodeAt(0);
const C_PRCNT = '%'.charCodeAt(0);
const C_SPACE = ' '.charCodeAt(0);
const C_Z = 'z'.charCodeAt(0);
const C_CENT = '\uFFE0'.charCodeAt(0);

function fromCharArray(a) {
    return Array.from(a)
        .map((c) => String.fromCharCode(c))
        .join('');
}

class ChatMessage {
    static descramble(buff, off, len) {
        try {
            let newLen = 0;
            let l = -1;

            for (let idx = 0; idx < len; idx++) {
                let current = buff[off++] & 0xff;
                let k1 = (current >> 4) & 0xf;

                if (l === -1) {
                    if (k1 < 13) {
                        ChatMessage.chars[newLen++] = ChatMessage.charMap[k1];
                    } else {
                        l = k1;
                    }
                } else {
                    ChatMessage.chars[newLen++] =
                        ChatMessage.charMap[(l << 4) + k1 - 195];
                    l = -1;
                }

                k1 = current & 0xf;

                if (l === -1) {
                    if (k1 < 13) {
                        ChatMessage.chars[newLen++] = ChatMessage.charMap[k1];
                    } else {
                        l = k1;
                    }
                } else {
                    ChatMessage.chars[newLen++] =
                        ChatMessage.charMap[(l << 4) + k1 - 195];
                    l = -1;
                }
            }

            let flag = true;

            for (let l1 = 0; l1 < newLen; l1++) {
                let currentChar = ChatMessage.chars[l1];

                if (l1 > 4 && currentChar === C_AT) {
                    ChatMessage.chars[l1] = C_SPACE;
                }

                if (currentChar === C_PRCNT) {
                    ChatMessage.chars[l1] = C_SPACE;
                }

                if (flag && currentChar >= C_A && currentChar <= C_Z) {
                    ChatMessage.chars[l1] += C_CENT;
                    flag = false;
                }

                if (currentChar === C_DOT || currentChar === C_EXCLM) {
                    flag = true;
                }
            }

            return fromCharArray(ChatMessage.chars.slice(0, newLen));
        } catch (e) {
            return '.';
        }
    }

    static scramble(s) {
        if (s.length > 80) {
            s = s.slice(0, 80);
        }

        s = s.toLowerCase();

        let off = 0;
        let lshift = -1;

        for (let k = 0; k < s.length; k++) {
            let currentChar = s.charCodeAt(k);
            let foundCharMapIdx = 0;

            for (let n = 0; n < ChatMessage.charMap.length; n++) {
                if (currentChar !== ChatMessage.charMap[n]) {
                    continue;
                }

                foundCharMapIdx = n;
                break;
            }

            if (foundCharMapIdx > 12) {
                foundCharMapIdx += 195;
            }

            if (lshift === -1) {
                if (foundCharMapIdx < 13) {
                    lshift = foundCharMapIdx;
                } else {
                    ChatMessage.scrambledBytes[off++] = foundCharMapIdx & 0xff;
                }
            } else if (foundCharMapIdx < 13) {
                ChatMessage.scrambledBytes[off++] =
                    ((lshift << 4) + foundCharMapIdx) & 0xff;
                lshift = -1;
            } else {
                ChatMessage.scrambledBytes[off++] =
                    ((lshift << 4) + (foundCharMapIdx >> 4)) & 0xff;
                lshift = foundCharMapIdx & 0xf;
            }
        }

        if (lshift !== -1) {
            ChatMessage.scrambledBytes[off++] = (lshift << 4) & 0xff;
        }

        return off;
    }
}

ChatMessage.scrambledBytes = new Int8Array(100);
ChatMessage.chars = new Uint16Array(100);
ChatMessage.charMap = new Uint16Array(
    [
        ' ',
        'e',
        't',
        'a',
        'o',
        'i',
        'h',
        'n',
        's',
        'r',
        'd',
        'l',
        'u',
        'm',
        'w',
        'c',
        'y',
        'f',
        'g',
        'p',
        'b',
        'v',
        'k',
        'x',
        'j',
        'q',
        'z',
        '0',
        '1',
        '2',
        '3',
        '4',
        '5',
        '6',
        '7',
        '8',
        '9',
        ' ',
        '!',
        '?',
        '.',
        ',',
        ':',
        ';',
        '(',
        ')',
        '-',
        '&',
        '*',
        '\\',
        "'",
        '@',
        '#',
        '+',
        '=',
        '\243',
        '$',
        '%',
        '"',
        '[',
        ']'
    ].map((c) => c.charCodeAt(0))
);

module.exports = ChatMessage;

},{}],41:[function(require,module,exports){
class GameBuffer {
    // buffer is an Int8Array
    constructor(buffer) {
        this.buffer = buffer;
        this.offset = 0;
    }

    putByte(i) {
        this.buffer[this.offset++] = i;
    }

    putInt(i) {
        this.buffer[this.offset++] = i >> 24;
        this.buffer[this.offset++] = i >> 16;
        this.buffer[this.offset++] = i >> 8;
        this.buffer[this.offset++] = i;
    }

    putString(s) {
        for (let i = 0; i < s.length; i++) {
            this.buffer[this.offset++] = s.charCodeAt(i);
        }

        // null terminate
        this.buffer[this.offset++] = 10;
    }

    putBytes(src, srcPos, len) {
        for (let i = srcPos; i < len; i++) {
            this.buffer[this.offset++] = src[i];
        }
    }

    getUnsignedByte() {
        return this.buffer[this.offset++] & 0xff;
    }

    getUnsignedShort() {
        this.offset += 2;

        return (
            ((this.buffer[this.offset - 2] & 0xff) << 8) +
            (this.buffer[this.offset - 1] & 0xff)
        );
    }

    getUnsignedInt() {
        this.offset += 4;

        return (
            ((this.buffer[this.offset - 4] & 0xff) << 24) +
            ((this.buffer[this.offset - 3] & 0xff) << 16) +
            ((this.buffer[this.offset - 2] & 0xff) << 8) +
            (this.buffer[this.offset - 1] & 0xff)
        );
    }

    getBytes(dest, destPos, len) {
        for (let i = destPos; i < len; i++) {
            dest[destPos + i] = this.buffer[this.offset++];
        }
    }
}

module.exports = GameBuffer;

},{}],42:[function(require,module,exports){
const Long = require('long');

class GameCharacter {
    constructor() {
        this.hash = new Long();
        this.name = null;
        this.serverIndex = 0;
        this.serverId = 0;
        this.currentX = 0;
        this.currentY = 0;
        this.npcId = 0;
        this.stepCount = 0;
        this.animationCurrent = 0;
        this.animationNext = 0;
        this.movingStep = 0;
        this.waypointCurrent = 0;
        this.message = null;
        this.messageTimeout = 0;
        this.bubbleItem = 0;
        this.bubbleTimeout = 0;
        this.damageTaken = 0;
        this.healthCurrent = 0;
        this.healthMax = 0;
        this.combatTimer = 0;
        this.level = 0;
        this.colourHair = 0;
        this.colourTop = 0;
        this.colourBottom = 0;
        this.colourSkin = 0;
        this.incomingProjectileSprite = 0;
        this.attackingPlayerServerIndex = 0;
        this.attackingNpcServerIndex = 0;
        this.projectileRange = 0;
        this.skullVisible = 0;
        this.waypointsX = new Int32Array(10);
        this.waypointsY = new Int32Array(10);
        this.equippedItem = new Int32Array(12);
        this.level = -1;
    }
}

module.exports = GameCharacter;


},{"long":33}],43:[function(require,module,exports){
const Color = require('./lib/graphics/color');
const Font = require('./lib/graphics/font');
const GameShell = require('./game-shell');
const Long = require('long');
const PacketStream = require('./packet-stream');
const Utility = require('./utility');
const clientOpcodes = require('./opcodes/client');
const serverOpcodes = require('./opcodes/server');
const sleep = require('sleep-promise');

function fromCharArray(a) {
    return Array.from(a)
        .map((c) => String.fromCharCode(c))
        .join('');
}

class GameConnection extends GameShell {
    constructor(canvas) {
        super(canvas);

        this.friendListCount = 0;
        this.ignoreListCount = 0;
        this.settingsBlockChat = 0;
        this.settingsBlockPrivate = 0;
        this.settingsBlockTrade = 0;
        this.settingsBlockDuel = 0;
        this.sessionID = new Long(0);
        this.worldFullTimeout = 0;
        this.moderatorLevel = 0;
        this.autoLoginTImeout = 0;
        this.packetLastRead = 0;
        this.messageIndex = 0;

        this.server = '127.0.0.1';
        this.port = 43594;

        this.username = '';
        this.password = '';

        this.incomingPacket = new Int8Array(5000);

        this.friendListOnline = new Int32Array(200);
        this.friendListHashes = [];

        for (let i = 0; i < 200; i += 1) {
            this.friendListHashes.push(new Long(0));
        }

        this.ignoreList = [];

        for (let i = 0; i < GameConnection.maxSocialListSize; i += 1) {
            this.ignoreList.push(new Long(0));
        }

        this.messageTokens = new Int32Array(GameConnection.maxSocialListSize);
    }

    async register(username, password) {
        if (this.worldFullTimeout > 0) {
            this.showLoginScreenStatus(
                'Please wait...',
                'Connecting to server'
            );

            await sleep(2000);

            this.showLoginScreenStatus(
                'Sorry! The server is currently full.',
                'Please try again later'
            );

            return;
        }

        try {
            username = Utility.formatAuthString(username, 20);
            password = Utility.formatAuthString(password, 20);

            this.showLoginScreenStatus(
                'Please wait...',
                'Connecting to server'
            );

            this.packetStream = new PacketStream(
                await this.createSocket(this.server, this.port),
                this
            );

            const encodedUsername = Utility.usernameToHash(username);
            this.packetStream.newPacket(clientOpcodes.SESSION);
            this.packetStream.putByte(
                encodedUsername.shiftRight(16).and(31).toInt()
            );
            this.packetStream.flushPacket();

            const sessionID = await this.packetStream.getLong();
            this.sessionID = sessionID;

            if (sessionID.equals(0)) {
                this.showLoginScreenStatus(
                    'Login server offline.',
                    'Please try again in a few mins'
                );
                return;
            }

            console.log('Verb: Session id: ' + sessionID);

            this.packetStream.newPacket(clientOpcodes.REGISTER);
            this.packetStream.putShort(GameConnection.clientVersion);
            this.packetStream.putString(username);
            this.packetStream.putString(password);
            this.packetStream.flushPacket();

            const response = await this.packetStream.readStream();

            this.packetStream.closeStream();

            console.log('Newplayer response: ' + response);

            switch (response) {
                case 2: // success
                    this.resetLoginVars();
                    return;
                case 13: // username taken
                case 3:
                    this.showLoginScreenStatus(
                        'Username already taken.',
                        'Please choose another username'
                    );
                    return;
                case 4: // username in use. distinction??
                    this.showLoginScreenStatus(
                        'That username is already in use.',
                        'Wait 60 seconds then retry'
                    );
                    return;
                case 5: // client has been updated
                    this.showLoginScreenStatus(
                        'The client has been updated.',
                        'Please reload this page'
                    );
                    return;
                case 6: // IP in use
                    this.showLoginScreenStatus(
                        'You may only use 1 character at once.',
                        'Your ip-address is already in use'
                    );
                    return;
                case 7: // spam throttle was hit
                    this.showLoginScreenStatus(
                        'Login attempts exceeded!',
                        'Please try again in 5 minutes'
                    );
                    return;
                case 11: // temporary ban
                    this.showLoginScreenStatus(
                        'Account has been temporarily disabled',
                        'for cheating or abuse'
                    );
                    return;
                case 12: // permanent ban
                    this.showLoginScreenStatus(
                        'Account has been permanently disabled',
                        'for cheating or abuse'
                    );
                    return;
                case 14: // server full
                    this.showLoginScreenStatus(
                        'Sorry! The server is currently full.',
                        'Please try again later'
                    );
                    this.worldFullTimeout = 1500;
                    return;
                case 15: // members account needed
                    this.showLoginScreenStatus(
                        'You need a members account',
                        'to login to this server'
                    );
                    return;
                case 16: // switch to members server
                    this.showLoginScreenStatus(
                        'Please login to a members server',
                        'to access member-only features'
                    );
                    return;
                default:
                    this.showLoginScreenStatus(
                        'Error unable to create username.',
                        'Unrecognised response code'
                    );
                    return;
            }
        } catch (e) {
            console.error(e);

            this.showLoginScreenStatus(
                'Error unable to create user.',
                'Unrecognised response code'
            );
        }
    }

    async login(username, password, reconnecting) {
        if (this.worldFullTimeout > 0) {
            this.showLoginScreenStatus(
                'Please wait...',
                'Connecting to server'
            );

            await sleep(2000);

            this.showLoginScreenStatus(
                'Sorry! The server is currently full.',
                'Please try again later'
            );

            return;
        }

        try {
            this.username = username;
            username = Utility.formatAuthString(username, 20);

            this.password = password;
            password = Utility.formatAuthString(password, 20);

            if (username.trim().length === 0) {
                this.showLoginScreenStatus(
                    'You must enter both a username',
                    'and a password - Please try again'
                );
                return;
            }

            if (reconnecting) {
                this.drawTextBox(
                    'Connection lost! Please wait...',
                    'Attempting to re-establish'
                );
            } else {
                this.showLoginScreenStatus(
                    'Please wait...',
                    'Connecting to server'
                );
            }

            this.packetStream = new PacketStream(
                await this.createSocket(this.server, this.port),
                this
            );

            this.packetStream.maxReadTries = GameConnection.maxReadTries;

            this.packetStream.newPacket(clientOpcodes.SESSION);

            const encodedUsername = Utility.usernameToHash(username);

            this.packetStream.putByte(
                encodedUsername.shiftRight(16).and(31).toInt()
            );

            this.packetStream.flushPacket();

            const sessionID = await this.packetStream.getLong();
            this.sessionID = sessionID;

            if (sessionID.equals(0)) {
                this.showLoginScreenStatus(
                    'Login server offline.',
                    'Please try again in a few mins'
                );
                return;
            }

            console.log('Verb: Session id: ' + sessionID);

            const keys = new Int32Array(4);
            keys[0] = (Math.random() * 99999999) | 0;
            keys[1] = (Math.random() * 99999999) | 0;
            keys[2] = sessionID.shiftRight(32).toInt();
            keys[3] = sessionID.toInt();

            this.packetStream.newPacket(clientOpcodes.LOGIN);

            this.packetStream.putByte(+reconnecting);
            this.packetStream.putShort(GameConnection.clientVersion);
            this.packetStream.putByte(0); // limit30

            this.packetStream.putByte(10);
            this.packetStream.putInt(keys[0]);
            this.packetStream.putInt(keys[1]);
            this.packetStream.putInt(keys[2]);
            this.packetStream.putInt(keys[3]);
            this.packetStream.putInt(0); // uuid
            this.packetStream.putString(username);
            this.packetStream.putString(password);

            this.packetStream.flushPacket();
            //this.packetStream.seedIsaac(ai);

            const response = await this.packetStream.readStream();
            console.log('login response:' + response);

            if (response === 25) {
                this.moderatorLevel = 1;
                this.autoLoginTimeout = 0;
                this.resetGame();
                return;
            } else if (response === 0) {
                this.moderatorLevel = 0;
                this.autoLoginTimeout = 0;
                this.resetGame();
                return;
            } else if (response === 1) {
                this.autoLoginTimeout = 0;
                return;
            }

            if (reconnecting) {
                username = '';
                password = '';
                this.resetLoginVars();
                return;
            }

            switch (response) {
                case -1:
                    this.showLoginScreenStatus(
                        'Error unable to login.',
                        'Server timed out'
                    );
                    return;
                case 3:
                    this.showLoginScreenStatus(
                        'Invalid username or password.',
                        'Try again, or create a new account'
                    );
                    return;
                case 4:
                    this.showLoginScreenStatus(
                        'That username is already logged in.',
                        'Wait 60 seconds then retry'
                    );
                    return;
                case 5:
                    this.showLoginScreenStatus(
                        'The client has been updated.',
                        'Please reload this page'
                    );
                    return;
                case 6:
                    this.showLoginScreenStatus(
                        'You may only use 1 character at once.',
                        'Your ip-address is already in use'
                    );
                    return;
                case 7:
                    this.showLoginScreenStatus(
                        'Login attempts exceeded!',
                        'Please try again in 5 minutes'
                    );
                    return;
                case 8:
                    this.showLoginScreenStatus(
                        'Error unable to login.',
                        'Server rejected session'
                    );
                    return;
                case 9:
                    this.showLoginScreenStatus(
                        'Error unable to login.',
                        'Loginserver rejected session'
                    );
                    return;
                case 10:
                    this.showLoginScreenStatus(
                        'That username is already in use.',
                        'Wait 60 seconds then retry'
                    );
                    return;
                case 11:
                    this.showLoginScreenStatus(
                        'Account temporarily disabled.',
                        'Check your message inbox for details'
                    );
                    return;
                case 12:
                    this.showLoginScreenStatus(
                        'Account permanently disabled.',
                        'Check your message inbox for details'
                    );
                    return;
                case 14:
                    this.showLoginScreenStatus(
                        'Sorry! This world is currently full.',
                        'Please try a different world'
                    );
                    this.worldFullTimeout = 1500;
                    return;
                case 15:
                    this.showLoginScreenStatus(
                        'You need a members account',
                        'to login to this world'
                    );
                    return;
                case 16:
                    this.showLoginScreenStatus(
                        'Error - no reply from loginserver.',
                        'Please try again'
                    );
                    return;
                case 17:
                    this.showLoginScreenStatus(
                        'Error - failed to decode profile.',
                        'Contact customer support'
                    );
                    return;
                case 18:
                    this.showLoginScreenStatus(
                        'Account suspected stolen.',
                        "Press 'recover a locked account' on front page."
                    );
                    return;
                case 20:
                    this.showLoginScreenStatus(
                        'Error - loginserver mismatch',
                        'Please try a different world'
                    );
                    return;
                case 21:
                    this.showLoginScreenStatus(
                        'Unable to login.',
                        'That is not an RS-Classic account'
                    );
                    return;
                case 22:
                    this.showLoginScreenStatus(
                        'Password suspected stolen.',
                        "Press 'change your password' on front page."
                    );
                    return;
                default:
                    this.showLoginScreenStatus(
                        'Error unable to login.',
                        'Unrecognised response code'
                    );
                    return;
            }
        } catch (e) {
            console.error(e);
        }

        if (this.autoLoginTimeout > 0) {
            await sleep(5000);
            this.autoLoginTimeout--;
            await this.login(this.username, this.password, reconnecting);
        }

        if (reconnecting) {
            this.username = '';
            this.password = '';
            this.resetLoginVars();
        } else {
            this.showLoginScreenStatus(
                'Sorry! Unable to connect.',
                'Check internet settings or try another world'
            );
        }
    }

    async recoverAttempt(username) {
        this.showLoginScreenStatus('Please wait...', 'Connecting to server');

        try {
            this.packetStream = new PacketStream(
                await this.createSocket(this.server, this.port),
                this
            );
            this.packetStream.maxReadTries = this.maxReadTries;
            this.packetStream.newPacket();
            this.packetStream.putLong(Utility.usernameToHash(username));
            this.packetStream.flushPacket();

            const response = await this.packetStream.readStream();
            console.log('Getpq response: ' + response);

            if (response === 0) {
                this.showLoginScreenStatus(
                    'Sorry, the recovery questions for this user have not ' +
                        'been set',
                    ''
                );
                return;
            }

            for (let i = 0; i < 5; i++) {
                const length = await this.packetStream.readStream();

                if (length < 0) {
                    throw new Error('invalid recovery question length');
                }

                const buffer = new Int8Array(length);
                await this.packetStream.readBytes(length, buffer);
                const question = fromCharArray(buffer.slice(0, length));

                this.panelRecoverUser.updateText(
                    this.controlRecoverQuestions[i],
                    question
                );
            }

            if (this.recentRecoverFail) {
                this.showLoginScreenStatus(
                    'Sorry, you have already attempted 1 recovery, try again ' +
                        'later',
                    ''
                );
                return;
            }

            this.loginScreen = 3;
            this.panelRecoverUser.updateText(
                this.controlRecoverInfo1,
                '@yel@To prove this is your account please provide the ' +
                    'answers to'
            );
            this.panelRecoverUser.updateText(
                this.controlRecoverInfo2,
                '@yel@your security questions. You will then be able to ' +
                    'reset your password'
            );

            for (let i = 0; i < 5; i++) {
                this.panelRecoverUser.updateText(
                    this.controlRecoverAnswers[i],
                    ''
                );
            }

            this.panelRecoverUser.updateText(
                this.controlRecoverOldPassword,
                ''
            );
            this.panelRecoverUser.updateText(
                this.controlRecoverNewPassword,
                ''
            );
            this.panelRecoverUser.updateText(
                this.controlRecoverConfirmPassword,
                ''
            );
        } catch (e) {
            console.error(e);

            this.showLoginScreenStatus(
                'Sorry! Unable to connect.',
                'Check leternet settings or try another world'
            );

            return;
        }
    }

    closeConnection() {
        if (this.packetStream !== null) {
            try {
                this.packetStream.newPacket(clientOpcodes.CLOSE_CONNECTION);
                this.packetStream.flushPacket();
            } catch (e) {
                console.error(e);
            }
        }

        this.username = '';
        this.password = '';

        this.resetLoginVars();
    }

    async lostConnection() {
        try {
            throw new Error('');
        } catch (e) {
            console.error(e);
        }

        if (this.options.retryLoginOnDisconnect) {
            this.autoLoginTimeout = 10;
        }

        await this.login(this.username, this.password, true);
    }

    drawTextBox(top, bottom) {
        const graphics = this.getGraphics();
        const font = new Font('Helvetica', 1, 15);
        const width = 512;
        const height = 344;

        graphics.setColor(Color.black);

        graphics.fillRect(
            ((width / 2) | 0) - 140,
            ((height / 2) | 0) - 25,
            280,
            50
        );

        graphics.setColor(Color.white);

        graphics.drawRect(
            ((width / 2) | 0) - 140,
            ((height / 2) | 0) - 25,
            280,
            50
        );

        this.drawString(
            graphics,
            top,
            font,
            (width / 2) | 0,
            ((height / 2) | 0) - 10
        );

        this.drawString(
            graphics,
            bottom,
            font,
            (width / 2) | 0,
            ((height / 2) | 0) + 10
        );
    }

    async checkConnection() {
        // packetTick?
        const timestamp = Date.now();

        if (this.packetStream.hasPacket()) {
            this.packetLastRead = timestamp;
        }

        if (timestamp - this.packetLastRead > 5000) {
            this.packetLastRead = timestamp;
            this.packetStream.newPacket(clientOpcodes.PING);
            this.packetStream.sendPacket();
        }

        try {
            this.packetStream.writePacket(20);
        } catch (e) {
            await this.lostConnection();
            return;
        }

        const length = await this.packetStream.readPacket(this.incomingPacket);

        if (length > 0) {
            const opcode = this.packetStream.isaacCommand(
                this.incomingPacket[0] & 0xff
            );

            this.handlePacket(opcode, length);
        }
    }

    handlePacket(opcode, size) {
        console.log('opcode:' + opcode + ' psize:' + size);

        if (opcode === serverOpcodes.CLOSE_CONNECTION) {
            this.closeConnection();
            return;
        }

        if (opcode === serverOpcodes.LOGOUT_DENY) {
            this.cantLogout();
            return;
        }

        this.handleIncomingPacket(opcode, size, this.incomingPacket);
    }

    sortFriendsList() {
        let flag = true;

        while (flag) {
            flag = false;

            for (let i = 0; i < this.friendListCount - 1; i++) {
                if (
                    (this.friendListOnline[i] !== 255 &&
                        this.friendListOnline[i + 1] === 255) ||
                    (this.friendListOnline[i] === 0 &&
                        this.friendListOnline[i + 1] !== 0)
                ) {
                    const onlineStatus = this.friendListOnline[i];
                    this.friendListOnline[i] = this.friendListOnline[i + 1];
                    this.friendListOnline[i + 1] = onlineStatus;

                    const encodedUsername = this.friendListHashes[i];
                    this.friendListHashes[i] = this.friendListHashes[i + 1];
                    this.friendListHashes[i + 1] = encodedUsername;

                    flag = true;
                }
            }
        }
    }

    sendPrivacySettings(chat, privateChat, trade, duel) {
        this.packetStream.newPacket(clientOpcodes.SETTINGS_PRIVACY);
        this.packetStream.putByte(chat);
        this.packetStream.putByte(privateChat);
        this.packetStream.putByte(trade);
        this.packetStream.putByte(duel);
        this.packetStream.sendPacket();
    }

    ignoreAdd(username) {
        const encodedUsername = Utility.usernameToHash(username);

        this.packetStream.newPacket(clientOpcodes.IGNORE_ADD);
        this.packetStream.putLong(encodedUsername);
        this.packetStream.sendPacket();

        for (let i = 0; i < this.ignoreListCount; i++) {
            if (this.ignoreList[i].equals(encodedUsername)) {
                return;
            }
        }

        if (this.ignoreListCount >= GameConnection.maxSocialListSize) {
            return;
        } else {
            this.ignoreList[this.ignoreListCount++] = encodedUsername;
            return;
        }
    }

    ignoreRemove(encodedUsername) {
        this.packetStream.newPacket(clientOpcodes.IGNORE_REMOVE);
        this.packetStream.putLong(encodedUsername);
        this.packetStream.sendPacket();

        for (let i = 0; i < this.ignoreListCount; i++) {
            if (this.ignoreList[i].equals(encodedUsername)) {
                this.ignoreListCount--;

                for (let j = i; j < this.ignoreListCount; j++) {
                    this.ignoreList[j] = this.ignoreList[j + 1];
                }

                return;
            }
        }
    }

    friendAdd(username) {
        this.packetStream.newPacket(clientOpcodes.FRIEND_ADD);
        this.packetStream.putLong(Utility.usernameToHash(username));
        this.packetStream.sendPacket();

        const encodedUsername = Utility.usernameToHash(username);

        for (let i = 0; i < this.friendListCount; i++) {
            if (this.friendListHashes[i].equals(encodedUsername)) {
                return;
            }
        }

        if (this.friendListCount >= GameConnection.maxSocialListSize) {
            return;
        } else {
            this.friendListHashes[this.friendListCount] = encodedUsername;
            this.friendListOnline[this.friendListCount] = 0;
            this.friendListCount++;
            return;
        }
    }

    friendRemove(encodedUsername) {
        this.packetStream.newPacket(clientOpcodes.FRIEND_REMOVE);
        this.packetStream.putLong(encodedUsername);
        this.packetStream.sendPacket();

        for (let i = 0; i < this.friendListCount; i++) {
            if (!this.friendListHashes[i].equals(encodedUsername)) {
                continue;
            }

            this.friendListCount--;

            for (let j = i; j < this.friendListCount; j++) {
                this.friendListHashes[j] = this.friendListHashes[j + 1];
                this.friendListOnline[j] = this.friendListOnline[j + 1];
            }

            break;
        }

        this.showServerMessage(
            `@pri@${Utility.hashToUsername(encodedUsername)} has been ` +
                'removed from your friends list'
        );
    }

    sendPrivateMessage(username, message, length) {
        this.packetStream.newPacket(clientOpcodes.PM);
        this.packetStream.putLong(username);
        this.packetStream.putBytes(message, 0, length);
        this.packetStream.sendPacket();
    }

    sendChatMessage(message, length) {
        this.packetStream.newPacket(clientOpcodes.CHAT);
        this.packetStream.putBytes(message, 0, length);
        this.packetStream.sendPacket();
    }

    sendCommandString(command) {
        this.packetStream.newPacket(clientOpcodes.COMMAND);
        this.packetStream.putString(command);
        this.packetStream.sendPacket();
    }
}

GameConnection.clientVersion = 1;
GameConnection.maxReadTries = 0;
GameConnection.maxSocialListSize = 100;

module.exports = GameConnection;

},{"./game-shell":46,"./lib/graphics/color":47,"./lib/graphics/font":48,"./opcodes/client":54,"./opcodes/server":55,"./packet-stream":68,"./utility":100,"long":33,"sleep-promise":37}],44:[function(require,module,exports){
const Utility = require('./utility');
const ndarray = require('ndarray');

class GameData {
    static getModelIndex(s) {
        if (/^na$/i.test(s)) {
            return 0;
        }

        for (let i = 0; i < GameData.modelCount; i++) {
            if (GameData.modelName[i].toLowerCase() === s.toLowerCase()) {
                return i;
            }
        }

        GameData.modelName[GameData.modelCount++] = s;

        return GameData.modelCount - 1;
    }

    static getUnsignedByte() {
        let i = GameData.dataInteger[GameData.offset] & 0xff;
        GameData.offset++;

        return i;
    }

    static getUnsignedShort() {
        let i = Utility.getUnsignedShort(GameData.dataInteger, GameData.offset);
        GameData.offset += 2;

        return i;
    }

    static getUnsignedInt() {
        let i = Utility.getUnsignedInt(GameData.dataInteger, GameData.offset);
        GameData.offset += 4;

        if (i > 99999999) {
            i = 99999999 - i;
        }

        return i;
    }

    static getString() {
        let s = '';
        for (
            s = '';
            GameData.dataString[GameData.stringOffset] !== 0;
            s =
                s +
                String.fromCharCode(
                    GameData.dataString[GameData.stringOffset++]
                )
        );
        GameData.stringOffset++;

        return s;
    }

    static loadData(buffer, isMembers) {
        GameData.dataString = Utility.loadData('string.dat', 0, buffer);
        GameData.stringOffset = 0;
        GameData.dataInteger = Utility.loadData('integer.dat', 0, buffer);
        GameData.offset = 0;

        let i = 0;

        GameData.itemCount = GameData.getUnsignedShort();
        GameData.itemName = [];
        GameData.itemDescription = [];
        GameData.itemCommand = [];
        GameData.itemPicture = new Int32Array(GameData.itemCount);
        GameData.itemBasePrice = new Int32Array(GameData.itemCount);
        GameData.itemStackable = new Int32Array(GameData.itemCount);
        GameData.itemUnused = new Int32Array(GameData.itemCount);
        GameData.itemWearable = new Int32Array(GameData.itemCount);
        GameData.itemMask = new Int32Array(GameData.itemCount);
        GameData.itemSpecial = new Int32Array(GameData.itemCount);
        GameData.itemMembers = new Int32Array(GameData.itemCount);

        for (i = 0; i < GameData.itemCount; i++) {
            GameData.itemName.push(GameData.getString());
        }

        for (i = 0; i < GameData.itemCount; i++) {
            GameData.itemDescription.push(GameData.getString());
        }

        for (i = 0; i < GameData.itemCount; i++) {
            GameData.itemCommand.push(GameData.getString());
        }

        for (i = 0; i < GameData.itemCount; i++) {
            GameData.itemPicture[i] = GameData.getUnsignedShort();

            if (GameData.itemPicture[i] + 1 > GameData.itemSpriteCount) {
                GameData.itemSpriteCount = GameData.itemPicture[i] + 1;
            }
        }

        for (i = 0; i < GameData.itemCount; i++) {
            GameData.itemBasePrice[i] = GameData.getUnsignedInt();
        }

        for (i = 0; i < GameData.itemCount; i++) {
            GameData.itemStackable[i] = GameData.getUnsignedByte();
        }

        for (i = 0; i < GameData.itemCount; i++) {
            GameData.itemUnused[i] = GameData.getUnsignedByte();
        }

        for (i = 0; i < GameData.itemCount; i++) {
            GameData.itemWearable[i] = GameData.getUnsignedShort();
        }

        for (i = 0; i < GameData.itemCount; i++) {
            GameData.itemMask[i] = GameData.getUnsignedInt();
        }

        for (i = 0; i < GameData.itemCount; i++) {
            GameData.itemSpecial[i] = GameData.getUnsignedByte();
        }

        for (i = 0; i < GameData.itemCount; i++) {
            GameData.itemMembers[i] = GameData.getUnsignedByte();
        }

        for (i = 0; i < GameData.itemCount; i++) {
            if (!isMembers && GameData.itemMembers[i] === 1) {
                GameData.itemName[i] = 'Members object';

                GameData.itemDescription[i] =
                    'You need to be a member to use this object';

                GameData.itemBasePrice[i] = 0;
                GameData.itemCommand[i] = '';
                GameData.itemUnused[0] = 0;
                GameData.itemWearable[i] = 0;
                GameData.itemSpecial[i] = 1;
            }
        }

        GameData.npcCount = GameData.getUnsignedShort();
        GameData.npcName = [];
        GameData.npcDescription = [];
        GameData.npcCommand = [];
        GameData.npcAttack = new Int32Array(GameData.npcCount);
        GameData.npcStrength = new Int32Array(GameData.npcCount);
        GameData.npcHits = new Int32Array(GameData.npcCount);
        GameData.npcDefense = new Int32Array(GameData.npcCount);
        GameData.npcAttackable = new Int32Array(GameData.npcCount);

        GameData.npcSprite = ndarray(new Int32Array(GameData.npcCount * 12), [
            GameData.npcCount,
            12
        ]);

        GameData.npcColourHair = new Int32Array(GameData.npcCount);
        GameData.npcColourTop = new Int32Array(GameData.npcCount);
        GameData.npcColorBottom = new Int32Array(GameData.npcCount);
        GameData.npcColourSkin = new Int32Array(GameData.npcCount);
        GameData.npcWidth = new Int32Array(GameData.npcCount);
        GameData.npcHeight = new Int32Array(GameData.npcCount);
        GameData.npcWalkModel = new Int32Array(GameData.npcCount);
        GameData.npcCombatModel = new Int32Array(GameData.npcCount);
        GameData.npcCombatAnimation = new Int32Array(GameData.npcCount);

        for (i = 0; i < GameData.npcCount; i++) {
            GameData.npcName.push(GameData.getString());
        }

        for (i = 0; i < GameData.npcCount; i++) {
            GameData.npcDescription.push(GameData.getString());
        }

        for (i = 0; i < GameData.npcCount; i++) {
            GameData.npcAttack[i] = GameData.getUnsignedByte();
        }

        for (i = 0; i < GameData.npcCount; i++) {
            GameData.npcStrength[i] = GameData.getUnsignedByte();
        }

        for (i = 0; i < GameData.npcCount; i++) {
            GameData.npcHits[i] = GameData.getUnsignedByte();
        }

        for (i = 0; i < GameData.npcCount; i++) {
            GameData.npcDefense[i] = GameData.getUnsignedByte();
        }

        for (i = 0; i < GameData.npcCount; i++) {
            GameData.npcAttackable[i] = GameData.getUnsignedByte();
        }

        for (i = 0; i < GameData.npcCount; i++) {
            for (let i5 = 0; i5 < 12; i5++) {
                GameData.npcSprite.set(i, i5, GameData.getUnsignedByte());

                if (GameData.npcSprite.get(i, i5) === 255) {
                    GameData.npcSprite.set(i, i5, -1);
                }
            }
        }

        for (i = 0; i < GameData.npcCount; i++) {
            GameData.npcColourHair[i] = GameData.getUnsignedInt();
        }

        for (i = 0; i < GameData.npcCount; i++) {
            GameData.npcColourTop[i] = GameData.getUnsignedInt();
        }

        for (i = 0; i < GameData.npcCount; i++) {
            GameData.npcColorBottom[i] = GameData.getUnsignedInt();
        }

        for (i = 0; i < GameData.npcCount; i++) {
            GameData.npcColourSkin[i] = GameData.getUnsignedInt();
        }

        for (i = 0; i < GameData.npcCount; i++) {
            GameData.npcWidth[i] = GameData.getUnsignedShort();
        }

        for (i = 0; i < GameData.npcCount; i++) {
            GameData.npcHeight[i] = GameData.getUnsignedShort();
        }

        for (i = 0; i < GameData.npcCount; i++) {
            GameData.npcWalkModel[i] = GameData.getUnsignedByte();
        }

        for (i = 0; i < GameData.npcCount; i++) {
            GameData.npcCombatModel[i] = GameData.getUnsignedByte();
        }

        for (i = 0; i < GameData.npcCount; i++) {
            GameData.npcCombatAnimation[i] = GameData.getUnsignedByte();
        }

        for (i = 0; i < GameData.npcCount; i++) {
            GameData.npcCommand[i] = GameData.getString();
        }

        GameData.textureCount = GameData.getUnsignedShort();
        GameData.textureName = [];
        GameData.textureSubtypeName = [];

        for (i = 0; i < GameData.textureCount; i++) {
            GameData.textureName.push(GameData.getString());
        }

        for (i = 0; i < GameData.textureCount; i++) {
            GameData.textureSubtypeName.push(GameData.getString());
        }

        GameData.animationCount = GameData.getUnsignedShort();
        GameData.animationName = [];

        GameData.animationCharacterColour = new Int32Array(
            GameData.animationCount
        );

        GameData.animationGender = new Int32Array(GameData.animationCount);
        GameData.animationHasA = new Int32Array(GameData.animationCount);
        GameData.animationHasF = new Int32Array(GameData.animationCount);
        GameData.animationNumber = new Int32Array(GameData.animationCount);

        for (i = 0; i < GameData.animationCount; i++) {
            GameData.animationName.push(GameData.getString());
        }

        for (i = 0; i < GameData.animationCount; i++) {
            GameData.animationCharacterColour[i] = GameData.getUnsignedInt();
        }

        for (i = 0; i < GameData.animationCount; i++) {
            GameData.animationGender[i] = GameData.getUnsignedByte();
        }

        for (i = 0; i < GameData.animationCount; i++) {
            GameData.animationHasA[i] = GameData.getUnsignedByte();
        }

        for (i = 0; i < GameData.animationCount; i++) {
            GameData.animationHasF[i] = GameData.getUnsignedByte();
        }

        for (i = 0; i < GameData.animationCount; i++) {
            GameData.animationNumber[i] = GameData.getUnsignedByte();
        }

        GameData.objectCount = GameData.getUnsignedShort();
        GameData.objectName = [];
        GameData.objectDescription = [];
        GameData.objectCommand1 = [];
        GameData.objectCommand2 = [];
        GameData.objectModelIndex = new Int32Array(GameData.objectCount);
        GameData.objectWidth = new Int32Array(GameData.objectCount);
        GameData.objectHeight = new Int32Array(GameData.objectCount);
        GameData.objectType = new Int32Array(GameData.objectCount);
        GameData.objectElevation = new Int32Array(GameData.objectCount);

        for (i = 0; i < GameData.objectCount; i++) {
            GameData.objectName.push(GameData.getString());
        }

        for (i = 0; i < GameData.objectCount; i++) {
            GameData.objectDescription.push(GameData.getString());
        }

        for (i = 0; i < GameData.objectCount; i++) {
            GameData.objectCommand1.push(GameData.getString());
        }

        for (i = 0; i < GameData.objectCount; i++) {
            GameData.objectCommand2.push(GameData.getString());
        }

        for (i = 0; i < GameData.objectCount; i++) {
            GameData.objectModelIndex[i] = GameData.getModelIndex(
                GameData.getString()
            );
        }

        for (i = 0; i < GameData.objectCount; i++) {
            GameData.objectWidth[i] = GameData.getUnsignedByte();
        }

        for (i = 0; i < GameData.objectCount; i++) {
            GameData.objectHeight[i] = GameData.getUnsignedByte();
        }

        for (i = 0; i < GameData.objectCount; i++) {
            GameData.objectType[i] = GameData.getUnsignedByte();
        }

        for (i = 0; i < GameData.objectCount; i++) {
            GameData.objectElevation[i] = GameData.getUnsignedByte();
        }

        GameData.wallObjectCount = GameData.getUnsignedShort();
        GameData.wallObjectName = [];
        GameData.wallObjectDescription = [];
        GameData.wallObjectCommand1 = [];
        GameData.wallObjectCommand2 = [];
        GameData.wallObjectHeight = new Int32Array(GameData.wallObjectCount);

        GameData.wallObjectTextureFront = new Int32Array(
            GameData.wallObjectCount
        );

        GameData.wallObjectTextureBack = new Int32Array(
            GameData.wallObjectCount
        );

        GameData.wallObjectAdjacent = new Int32Array(GameData.wallObjectCount);
        GameData.wallObjectInvisible = new Int32Array(GameData.wallObjectCount);

        for (i = 0; i < GameData.wallObjectCount; i++) {
            GameData.wallObjectName.push(GameData.getString());
        }

        for (i = 0; i < GameData.wallObjectCount; i++) {
            GameData.wallObjectDescription.push(GameData.getString());
        }

        for (i = 0; i < GameData.wallObjectCount; i++) {
            GameData.wallObjectCommand1.push(GameData.getString());
        }

        for (i = 0; i < GameData.wallObjectCount; i++) {
            GameData.wallObjectCommand2.push(GameData.getString());
        }

        for (i = 0; i < GameData.wallObjectCount; i++) {
            GameData.wallObjectHeight[i] = GameData.getUnsignedShort();
        }

        for (i = 0; i < GameData.wallObjectCount; i++) {
            GameData.wallObjectTextureFront[i] = GameData.getUnsignedInt();
        }

        for (i = 0; i < GameData.wallObjectCount; i++) {
            GameData.wallObjectTextureBack[i] = GameData.getUnsignedInt();
        }

        for (i = 0; i < GameData.wallObjectCount; i++) {
            // what's this?
            GameData.wallObjectAdjacent[i] = GameData.getUnsignedByte();
        }

        for (i = 0; i < GameData.wallObjectCount; i++) {
            // value is 0 if visible
            GameData.wallObjectInvisible[i] = GameData.getUnsignedByte();
        }

        // the World class does something with these
        GameData.roofCount = GameData.getUnsignedShort();
        GameData.roofHeight = new Int32Array(GameData.roofCount);
        GameData.roofNumVertices = new Int32Array(GameData.roofCount);

        for (i = 0; i < GameData.roofCount; i++) {
            GameData.roofHeight[i] = GameData.getUnsignedByte();
        }

        for (i = 0; i < GameData.roofCount; i++) {
            GameData.roofNumVertices[i] = GameData.getUnsignedByte();
        }

        GameData.tileCount = GameData.getUnsignedShort(); // and these
        GameData.tileDecoration = new Int32Array(GameData.tileCount);
        GameData.tileType = new Int32Array(GameData.tileCount);
        GameData.tileAdjacent = new Int32Array(GameData.tileCount);

        for (i = 0; i < GameData.tileCount; i++) {
            GameData.tileDecoration[i] = GameData.getUnsignedInt();
        }

        for (i = 0; i < GameData.tileCount; i++) {
            GameData.tileType[i] = GameData.getUnsignedByte();
        }

        for (i = 0; i < GameData.tileCount; i++) {
            GameData.tileAdjacent[i] = GameData.getUnsignedByte();
        }

        GameData.projectileSprite = GameData.getUnsignedShort();
        GameData.spellCount = GameData.getUnsignedShort();
        GameData.spellName = [];
        GameData.spellDescription = [];
        GameData.spellLevel = new Int32Array(GameData.spellCount);
        GameData.spellRunesRequired = new Int32Array(GameData.spellCount);
        GameData.spellType = new Int32Array(GameData.spellCount);
        GameData.spellRunesId = [];
        GameData.spellRunesCount = [];

        for (i = 0; i < GameData.spellCount; i++) {
            GameData.spellName.push(GameData.getString());
        }

        for (i = 0; i < GameData.spellCount; i++) {
            GameData.spellDescription.push(GameData.getString());
        }

        for (i = 0; i < GameData.spellCount; i++) {
            GameData.spellLevel[i] = GameData.getUnsignedByte();
        }

        for (i = 0; i < GameData.spellCount; i++) {
            GameData.spellRunesRequired[i] = GameData.getUnsignedByte();
        }

        for (i = 0; i < GameData.spellCount; i++) {
            GameData.spellType[i] = GameData.getUnsignedByte();
        }

        for (i = 0; i < GameData.spellCount; i++) {
            const runeAmount = GameData.getUnsignedByte();

            GameData.spellRunesId.push(new Int32Array(runeAmount));

            for (let j = 0; j < runeAmount; j++) {
                GameData.spellRunesId[i][j] = GameData.getUnsignedShort();
            }
        }

        for (i = 0; i < GameData.spellCount; i++) {
            let runeAmount = GameData.getUnsignedByte();

            GameData.spellRunesCount.push(new Int32Array(runeAmount));

            for (let k = 0; k < runeAmount; k++) {
                GameData.spellRunesCount[i][k] = GameData.getUnsignedByte();
            }
        }

        GameData.prayerCount = GameData.getUnsignedShort();
        GameData.prayerName = [];
        GameData.prayerDescription = [];
        GameData.prayerLevel = new Int32Array(GameData.prayerCount);
        GameData.prayerDrain = new Int32Array(GameData.prayerCount);

        for (i = 0; i < GameData.prayerCount; i++) {
            GameData.prayerName.push(GameData.getString());
        }

        for (i = 0; i < GameData.prayerCount; i++) {
            GameData.prayerDescription.push(GameData.getString());
        }

        for (i = 0; i < GameData.prayerCount; i++) {
            GameData.prayerLevel[i] = GameData.getUnsignedByte();
        }

        for (i = 0; i < GameData.prayerCount; i++) {
            GameData.prayerDrain[i] = GameData.getUnsignedByte();
        }

        GameData.dataString = null;
        GameData.dataInteger = null;
    }
}

GameData.modelName = [];
GameData.modelName.length = 5000;
GameData.modelName.fill(null);
GameData.spellCount = 0;
GameData.itemCount = 0;
GameData.itemSpriteCount = 0;
GameData.tileCount = 0;
GameData.wallObjectCount = 0;
GameData.modelCount = 0;
GameData.prayerCount = 0;
GameData.projectileSprite = 0;
GameData.npcCount = 0;
GameData.textureCount = 0;
GameData.roofCount = 0;
GameData.objectCount = 0;
GameData.animationCount = 0;
GameData.stringOffset = 0;
GameData.offset = 0;

module.exports = GameData;

},{"./utility":100,"ndarray":34}],45:[function(require,module,exports){
const Utility = require('./utility');
const Scene = require('./scene');

const COLOUR_TRANSPARENT = 12345678;

class GameModel {
    constructor() {
        this.numVertices = 0;
        this.numFaces = 0;
        this.transformState = 0;
        this.visible = false;
        this.textureTranslucent = false;
        this.transparent = false;
        this.isolated = false;
        this.unlit = false;
        this.unpickable = false;
        this.projected = false;
        this.autocommit = false;
        this.depth = 0;
        this.x1 = 0;
        this.x2 = 0;
        this.y1 = 0;
        this.y2 = 0;
        this.z1 = 0;
        this.z2 = 0;
        this.key = 0;
        this.maxVerts = 0;
        this.lightDiffuse = 0;
        this.lightAmbience = 0;
        this.magic = 0;
        this.maxFaces = 0;
        this.baseX = 0;
        this.baseY = 0;
        this.baseZ = 0;
        this.scaleFx = 0;
        this.scaleFy = 0;
        this.scaleFz = 0;
        this.shearXy = 0;
        this.shearXz = 0;
        this.shearYx = 0;
        this.shearYz = 0;
        this.shearZx = 0;
        this.shearZy = 0;
        this.transformKind = 0;
        this.diameter = 0;
        this.lightDirectionX = 0;
        this.lightDirectionY = 0;
        this.lightDirectionZ = 0;
        this.lightDirectionMagnitude = 0;
        this.dataPtr = 0;
        this.orientationYaw = 0;
        this.orientationPitch = 0;
        this.orientationRoll = 0;

        this.projectVertexX = null;
        this.projectVertexY = null;
        this.projectVertexZ = null;
        this.vertexViewX = null;
        this.vertexViewY = null;
        this.vertexIntensity = null;
        this.vertexAmbience = null;
        this.faceNumVertices = null;
        this.faceVertices = null; // keep this one an array of int32arrays
        this.faceFillFront = null;
        this.faceFillBack = null;
        this.normalMagnitude = null;
        this.normalScale = null;
        this.faceIntensity = null;
        this.faceNormalX = null;
        this.faceNormalY = null;
        this.faceNormalZ = null;
        this.faceTag = null;
        this.isLocalPlayer = null;
        this.vertexX = null;
        this.vertexY = null;
        this.vertexZ = null;
        this.vertexTransformedX = null;
        this.vertexTransformedY = null;
        this.vertexTransformedZ = null;
        this.faceTransStateThing = null;
        this.faceBoundLeft = null;
        this.faceBoundRight = null;
        this.faceBoundBottom = null;
        this.faceBoundTop = null;
        this.faceBoundNear = null;
        this.faceBoundFar = null;

        /*switch (args.length) {
        case 2:
            if (Array.isArray(args[0])) {
                return this._from2A(...args);
            }

            return this._from2(...args);
        case 3:
            return this._from3(...args);
        case 7:
            return this._from7(...args);
        }*/
    }

    static _from2(numVertices, numFaces) {
        let gameModel = new GameModel();

        gameModel.transformState = 1;
        gameModel.visible = true;
        gameModel.textureTranslucent = false;
        gameModel.transparent = false;
        gameModel.key = -1;
        gameModel.autocommit = false;
        gameModel.isolated = false;
        gameModel.unlit = false;
        gameModel.unpickable = false;
        gameModel.projected = false;
        gameModel.magic = COLOUR_TRANSPARENT;
        gameModel.diameter = COLOUR_TRANSPARENT;
        gameModel.lightDirectionX = 180;
        gameModel.lightDirectionY = 155;
        gameModel.lightDirectionZ = 95;
        gameModel.lightDirectionMagnitude = 256;
        gameModel.lightDiffuse = 512;
        gameModel.lightAmbience = 32;

        gameModel.allocate(numVertices, numFaces);

        // TODO: maybe make gameModel an int32 array
        gameModel.faceTransStateThing = [];

        for (let v = 0; v < gameModel.numFaces; v++) {
            gameModel.faceTransStateThing.push(new Int32Array([0]));
        }

        return gameModel;
    }

    static _from2A(pieces, count) {
        let gameModel = new GameModel();

        gameModel.transformState = 1;
        gameModel.visible = true;
        gameModel.textureTranslucent = false;
        gameModel.transparent = false;
        gameModel.key = -1;
        gameModel.autocommit = false;
        gameModel.isolated = false;
        gameModel.unlit = false;
        gameModel.unpickable = false;
        gameModel.projected = false;
        gameModel.magic = COLOUR_TRANSPARENT;
        gameModel.diameter = COLOUR_TRANSPARENT;
        gameModel.lightDirectionX = 180;
        gameModel.lightDirectionY = 155;
        gameModel.lightDirectionZ = 95;
        gameModel.lightDirectionMagnitude = 256;
        gameModel.lightDiffuse = 512;
        gameModel.lightAmbience = 32;

        gameModel.merge(pieces, count, true);

        return gameModel;
    }

    static fromBytes(data, offset) {
        let gameModel = new GameModel();

        gameModel.transformState = 1;
        gameModel.visible = true;
        gameModel.textureTranslucent = false;
        gameModel.transparent = false;
        gameModel.key = -1;
        gameModel.autocommit = false;
        gameModel.isolated = false;
        gameModel.unlit = false;
        gameModel.unpickable = false;
        gameModel.projected = false;
        gameModel.magic = COLOUR_TRANSPARENT;
        gameModel.diameter = COLOUR_TRANSPARENT;
        gameModel.lightDirectionX = 180;
        gameModel.lightDirectionY = 155;
        gameModel.lightDirectionZ = 95;
        gameModel.lightDirectionMagnitude = 256;
        gameModel.lightDiffuse = 512;
        gameModel.lightAmbience = 32;

        let j = Utility.getUnsignedShort(data, offset);
        offset += 2;
        let k = Utility.getUnsignedShort(data, offset);
        offset += 2;

        gameModel.allocate(j, k);

        gameModel.faceTransStateThing = [];
        gameModel.faceTransStateThing.length = k;

        for (let i = 0; i < k; i += 1) {
            gameModel.faceTransStateThing[i] = [0];
        }

        for (let l = 0; l < j; l++) {
            gameModel.vertexX[l] = Utility.getSignedShort(data, offset);
            offset += 2;
        }

        for (let i1 = 0; i1 < j; i1++) {
            gameModel.vertexY[i1] = Utility.getSignedShort(data, offset);
            offset += 2;
        }

        for (let j1 = 0; j1 < j; j1++) {
            gameModel.vertexZ[j1] = Utility.getSignedShort(data, offset);
            offset += 2;
        }

        gameModel.numVertices = j;

        for (let k1 = 0; k1 < k; k1++) {
            gameModel.faceNumVertices[k1] = data[offset++] & 0xff;
        }

        for (let l1 = 0; l1 < k; l1++) {
            gameModel.faceFillFront[l1] = Utility.getSignedShort(data, offset);
            offset += 2;

            if (gameModel.faceFillFront[l1] === 32767) {
                gameModel.faceFillFront[l1] = gameModel.magic;
            }
        }

        for (let i2 = 0; i2 < k; i2++) {
            gameModel.faceFillBack[i2] = Utility.getSignedShort(data, offset);
            offset += 2;

            if (gameModel.faceFillBack[i2] === 32767) {
                gameModel.faceFillBack[i2] = gameModel.magic;
            }
        }

        for (let j2 = 0; j2 < k; j2++) {
            let k2 = data[offset++] & 0xff;

            if (k2 === 0) {
                gameModel.faceIntensity[j2] = 0;
            } else {
                gameModel.faceIntensity[j2] = gameModel.magic;
            }
        }

        for (let l2 = 0; l2 < k; l2++) {
            gameModel.faceVertices[l2] = new Int32Array(
                gameModel.faceNumVertices[l2]
            );

            for (let i3 = 0; i3 < gameModel.faceNumVertices[l2]; i3++) {
                if (j < 256) {
                    gameModel.faceVertices[l2][i3] = data[offset++] & 0xff;
                } else {
                    gameModel.faceVertices[l2][i3] = Utility.getUnsignedShort(
                        data,
                        offset
                    );
                    offset += 2;
                }
            }
        }

        gameModel.numFaces = k;
        gameModel.transformState = 1;

        return gameModel;
    }

    static _from6(pieces, count, autocommit, isolated, unlit, unpickable) {
        let gameModel = new GameModel();

        gameModel.transformState = 1;
        gameModel.visible = true;
        gameModel.textureTranslucent = false;
        gameModel.transparent = false;
        gameModel.key = -1;
        gameModel.projected = false;
        gameModel.magic = COLOUR_TRANSPARENT;
        gameModel.diameter = COLOUR_TRANSPARENT;
        gameModel.lightDirectionX = 180;
        gameModel.lightDirectionY = 155;
        gameModel.lightDirectionZ = 95;
        gameModel.lightDirectionMagnitude = 256;
        gameModel.lightDiffuse = 512;
        gameModel.lightAmbience = 32;
        gameModel.autocommit = autocommit;
        gameModel.isolated = isolated;
        gameModel.unlit = unlit;
        gameModel.unpickable = unpickable;

        gameModel.merge(pieces, count, false);

        return gameModel;
    }

    static _from7(
        numVertices,
        numFaces,
        autocommit,
        isolated,
        unlit,
        unpickable,
        projected
    ) {
        let gameModel = new GameModel();

        gameModel.transformState = 1;
        gameModel.visible = true;
        gameModel.textureTranslucent = false;
        gameModel.transparent = false;
        gameModel.key = -1;
        gameModel.magic = COLOUR_TRANSPARENT;
        gameModel.diameter = COLOUR_TRANSPARENT;
        gameModel.lightDirectionX = 180;
        gameModel.lightDirectionY = 155;
        gameModel.lightDirectionZ = 95;
        gameModel.lightDirectionMagnitude = 256;
        gameModel.lightDiffuse = 512;
        gameModel.lightAmbience = 32;
        gameModel.autocommit = autocommit;
        gameModel.isolated = isolated;
        gameModel.unlit = unlit;
        gameModel.unpickable = unpickable;
        gameModel.projected = projected;

        gameModel.allocate(numVertices, numFaces);

        return gameModel;
    }

    allocate(numV, numF) {
        this.vertexX = new Int32Array(numV);
        this.vertexY = new Int32Array(numV);
        this.vertexZ = new Int32Array(numV);
        this.vertexIntensity = new Int32Array(numV);
        this.vertexAmbience = new Int8Array(numV);
        this.faceNumVertices = new Int32Array(numF);

        this.faceVertices = [];
        this.faceVertices.length = numF;
        this.faceVertices.fill(null);
        this.faceFillFront = new Int32Array(numF);
        this.faceFillBack = new Int32Array(numF);
        this.faceIntensity = new Int32Array(numF);
        this.normalScale = new Int32Array(numF);
        this.normalMagnitude = new Int32Array(numF);

        if (!this.projected) {
            this.projectVertexX = new Int32Array(numV);
            this.projectVertexY = new Int32Array(numV);
            this.projectVertexZ = new Int32Array(numV);
            this.vertexViewX = new Int32Array(numV);
            this.vertexViewY = new Int32Array(numV);
        }

        if (!this.unpickable) {
            this.isLocalPlayer = new Int8Array(numF);
            this.faceTag = new Int32Array(numF);
        }

        if (this.autocommit) {
            this.vertexTransformedX = this.vertexX;
            this.vertexTransformedY = this.vertexY;
            this.vertexTransformedZ = this.vertexZ;
        } else {
            this.vertexTransformedX = new Int32Array(numV);
            this.vertexTransformedY = new Int32Array(numV);
            this.vertexTransformedZ = new Int32Array(numV);
        }

        if (!this.unlit || !this.isolated) {
            this.faceNormalX = new Int32Array(numF);
            this.faceNormalY = new Int32Array(numF);
            this.faceNormalZ = new Int32Array(numF);
        }

        if (!this.isolated) {
            this.faceBoundLeft = new Int32Array(numF);
            this.faceBoundRight = new Int32Array(numF);
            this.faceBoundBottom = new Int32Array(numF);
            this.faceBoundTop = new Int32Array(numF);
            this.faceBoundNear = new Int32Array(numF);
            this.faceBoundFar = new Int32Array(numF);
        }

        this.numFaces = 0;
        this.numVertices = 0;
        this.maxVerts = numV;
        this.maxFaces = numF;
        this.baseX = this.baseY = this.baseZ = 0;
        this.orientationYaw = this.orientationPitch = this.orientationRoll = 0;
        this.scaleFx = this.scaleFy = this.scaleFz = 256;
        this.shearXy = this.shearXz = this.shearYx = this.shearYz = this.shearZx = this.shearZy = 256;
        this.transformKind = 0;
    }

    projectionPrepare() {
        this.projectVertexX = new Int32Array(this.numVertices);
        this.projectVertexY = new Int32Array(this.numVertices);
        this.projectVertexZ = new Int32Array(this.numVertices);
        this.vertexViewX = new Int32Array(this.numVertices);
        this.vertexViewY = new Int32Array(this.numVertices);
    }

    clear() {
        this.numFaces = 0;
        this.numVertices = 0;
    }

    reduce(df, dz) {
        this.numFaces -= df;

        if (this.numFaces < 0) {
            this.numFaces = 0;
        }

        this.numVertices -= dz;

        if (this.numVertices < 0) {
            this.numVertices = 0;
        }
    }

    merge(pieces, count, transState) {
        let numF = 0;
        let numV = 0;

        for (let i = 0; i < count; i++) {
            numF += pieces[i].numFaces;
            numV += pieces[i].numVertices;
        }

        this.allocate(numV, numF);

        if (transState) {
            this.faceTransStateThing = [];
            this.faceTransStateThing.length = numF;
        }

        for (let i = 0; i < count; i++) {
            let source = pieces[i];
            source.commit();

            this.lightAmbience = source.lightAmbience;
            this.lightDiffuse = source.lightDiffuse;
            this.lightDirectionX = source.lightDirectionX;
            this.lightDirectionY = source.lightDirectionY;
            this.lightDirectionZ = source.lightDirectionZ;
            this.lightDirectionMagnitude = source.lightDirectionMagnitude;

            for (let srcF = 0; srcF < source.numFaces; srcF++) {
                let dstVs = new Int32Array(source.faceNumVertices[srcF]);
                let srcVs = source.faceVertices[srcF];

                for (let v = 0; v < source.faceNumVertices[srcF]; v++) {
                    dstVs[v] = this.vertexAt(
                        source.vertexX[srcVs[v]],
                        source.vertexY[srcVs[v]],
                        source.vertexZ[srcVs[v]]
                    );
                }

                let dstF = this.createFace(
                    source.faceNumVertices[srcF],
                    dstVs,
                    source.faceFillFront[srcF],
                    source.faceFillBack[srcF]
                );
                this.faceIntensity[dstF] = source.faceIntensity[srcF];
                this.normalScale[dstF] = source.normalScale[srcF];
                this.normalMagnitude[dstF] = source.normalMagnitude[srcF];

                if (transState) {
                    if (count > 1) {
                        this.faceTransStateThing[dstF] = new Int32Array(
                            source.faceTransStateThing[srcF].length + 1
                        );
                        this.faceTransStateThing[dstF][0] = i;

                        for (
                            let i2 = 0;
                            i2 < source.faceTransStateThing[srcF].length;
                            i2++
                        ) {
                            this.faceTransStateThing[dstF][i2 + 1] =
                                source.faceTransStateThing[srcF][i2];
                        }
                    } else {
                        this.faceTransStateThing[dstF] = new Int32Array(
                            source.faceTransStateThing[srcF].length
                        );

                        for (
                            let j2 = 0;
                            j2 < source.faceTransStateThing[srcF].length;
                            j2++
                        ) {
                            this.faceTransStateThing[dstF][j2] =
                                source.faceTransStateThing[srcF][j2];
                        }
                    }
                }
            }
        }

        this.transformState = 1;
    }

    vertexAt(x, y, z) {
        for (let l = 0; l < this.numVertices; l++) {
            if (
                this.vertexX[l] === x &&
                this.vertexY[l] === y &&
                this.vertexZ[l] === z
            ) {
                return l;
            }
        }

        if (this.numVertices >= this.maxVerts) {
            return -1;
        } else {
            this.vertexX[this.numVertices] = x;
            this.vertexY[this.numVertices] = y;
            this.vertexZ[this.numVertices] = z;

            return this.numVertices++;
        }
    }

    createVertex(i, j, k) {
        if (this.numVertices >= this.maxVerts) {
            return -1;
        } else {
            this.vertexX[this.numVertices] = i;
            this.vertexY[this.numVertices] = j;
            this.vertexZ[this.numVertices] = k;

            return this.numVertices++;
        }
    }

    createFace(n, vs, front, back) {
        if (this.numFaces >= this.maxFaces) {
            return -1;
        } else {
            this.faceNumVertices[this.numFaces] = n;
            this.faceVertices[this.numFaces] = vs;
            this.faceFillFront[this.numFaces] = front;
            this.faceFillBack[this.numFaces] = back;
            this.transformState = 1;

            return this.numFaces++;
        }
    }

    split(
        unused1,
        unused2,
        pieceDx,
        pieceDz,
        rows,
        count,
        pieceMaxVertices,
        pickable
    ) {
        this.commit();

        let pieceNV = new Int32Array(count);
        let pieceNF = new Int32Array(count);

        for (let i = 0; i < count; i++) {
            pieceNV[i] = 0;
            pieceNF[i] = 0;
        }

        for (let f = 0; f < this.numFaces; f++) {
            let sumX = 0;
            let sumZ = 0;
            let n = this.faceNumVertices[f];
            let vs = this.faceVertices[f];

            for (let i = 0; i < n; i++) {
                sumX += this.vertexX[vs[i]];
                sumZ += this.vertexZ[vs[i]];
            }

            let p =
                ((sumX / (n * pieceDx)) | 0) +
                ((sumZ / (n * pieceDz)) | 0) * rows;
            pieceNV[p] += n;
            pieceNF[p]++;
        }

        let pieces = [];

        for (let i = 0; i < count; i++) {
            if (pieceNV[i] > pieceMaxVertices) {
                pieceNV[i] = pieceMaxVertices;
            }

            pieces.push(
                GameModel._from7(
                    pieceNV[i],
                    pieceNF[i],
                    true,
                    true,
                    true,
                    pickable,
                    true
                )
            );
            pieces[i].lightDiffuse = this.lightDiffuse;
            pieces[i].lightAmbience = this.lightAmbience;
        }

        for (let f = 0; f < this.numFaces; f++) {
            let sumX = 0;
            let sumZ = 0;
            let n = this.faceNumVertices[f];
            let vs = this.faceVertices[f];

            for (let i = 0; i < n; i++) {
                sumX += this.vertexX[vs[i]];
                sumZ += this.vertexZ[vs[i]];
            }

            let p =
                ((sumX / (n * pieceDx)) | 0) +
                ((sumZ / (n * pieceDz)) | 0) * rows;
            this.copyLighting(pieces[p], vs, n, f);
        }

        for (let p = 0; p < count; p++) {
            pieces[p].projectionPrepare();
        }

        return pieces;
    }

    copyLighting(model, srcVs, nV, inF) {
        let dstVs = new Int32Array(nV);

        for (let inV = 0; inV < nV; inV++) {
            let outV = (dstVs[inV] = model.vertexAt(
                this.vertexX[srcVs[inV]],
                this.vertexY[srcVs[inV]],
                this.vertexZ[srcVs[inV]]
            ));
            model.vertexIntensity[outV] = this.vertexIntensity[srcVs[inV]];
            model.vertexAmbience[outV] = this.vertexAmbience[srcVs[inV]];
        }

        let outF = model.createFace(
            nV,
            dstVs,
            this.faceFillFront[inF],
            this.faceFillBack[inF]
        );

        if (!model.unpickable && !this.unpickable) {
            model.faceTag[outF] = this.faceTag[inF];
        }

        model.faceIntensity[outF] = this.faceIntensity[inF];
        model.normalScale[outF] = this.normalScale[inF];
        model.normalMagnitude[outF] = this.normalMagnitude[inF];
    }

    _setLight_from5(ambience, diffuse, x, y, z) {
        this.lightAmbience = 256 - ambience * 4;
        this.lightDiffuse = (64 - diffuse) * 16 + 128;

        if (!this.unlit) {
            this.lightDirectionX = x;
            this.lightDirectionY = y;
            this.lightDirectionZ = z;
            this.lightDirectionMagnitude = Math.sqrt(x * x + y * y + z * z) | 0;
            this.light();
        }
    }

    _setLight_from6(gouraud, ambient, diffuse, x, y, z) {
        this.lightAmbience = 256 - ambient * 4;
        this.lightDiffuse = (64 - diffuse) * 16 + 128;

        if (this.unlit) {
            return;
        }

        for (let i = 0; i < this.numFaces; i++) {
            if (gouraud) {
                this.faceIntensity[i] = this.magic;
            } else {
                this.faceIntensity[i] = 0;
            }
        }

        this.lightDirectionX = x;
        this.lightDirectionY = y;
        this.lightDirectionZ = z;
        this.lightDirectionMagnitude = Math.sqrt(x * x + y * y + z * z) | 0;

        this.light();
    }

    _setLight_from3(x, y, z) {
        if (!this.unlit) {
            this.lightDirectionX = x;
            this.lightDirectionY = y;
            this.lightDirectionZ = z;
            this.lightDirectionMagnitude = Math.sqrt(x * x + y * y + z * z) | 0;
            this.light();
        }
    }

    setLight(...args) {
        switch (args.length) {
            case 6:
                return this._setLight_from6(...args);
            case 5:
                return this._setLight_from5(...args);
            case 3:
                return this._setLight_from3(...args);
        }
    }

    setVertexAmbience(v, ambience) {
        this.vertexAmbience[v] = ambience & 0xff;
    }

    rotate(yaw, pitch, roll) {
        this.orientationYaw = (this.orientationYaw + yaw) & 0xff;
        this.orientationPitch = (this.orientationPitch + pitch) & 0xff;
        this.orientationRoll = (this.orientationRoll + roll) & 0xff;
        this.determineTransformKind();
        this.transformState = 1;
    }

    orient(yaw, pitch, roll) {
        this.orientationYaw = yaw & 0xff;
        this.orientationPitch = pitch & 0xff;
        this.orientationRoll = roll & 0xff;
        this.determineTransformKind();
        this.transformState = 1;
    }

    translate(x, y, z) {
        this.baseX += x;
        this.baseY += y;
        this.baseZ += z;
        this.determineTransformKind();
        this.transformState = 1;
    }

    place(x, y, z) {
        this.baseX = x;
        this.baseY = y;
        this.baseZ = z;
        this.determineTransformKind();
        this.transformState = 1;
    }

    determineTransformKind() {
        if (
            this.shearXy !== 256 ||
            this.shearXz !== 256 ||
            this.shearYx !== 256 ||
            this.shearYz !== 256 ||
            this.shearZx !== 256 ||
            this.shearZy !== 256
        ) {
            this.transformKind = 4;
        } else if (
            this.scaleFx !== 256 ||
            this.scaleFy !== 256 ||
            this.scaleFz !== 256
        ) {
            this.transformKind = 3;
        } else if (
            this.orientationYaw !== 0 ||
            this.orientationPitch !== 0 ||
            this.orientationRoll !== 0
        ) {
            this.transformKind = 2;
        } else if (this.baseX !== 0 || this.baseY !== 0 || this.baseZ !== 0) {
            this.transformKind = 1;
        } else {
            this.transformKind = 0;
        }
    }

    applyTranslate(dx, dy, dz) {
        for (let v = 0; v < this.numVertices; v++) {
            this.vertexTransformedX[v] += dx;
            this.vertexTransformedY[v] += dy;
            this.vertexTransformedZ[v] += dz;
        }
    }

    applyRotation(yaw, roll, pitch) {
        for (let v = 0; v < this.numVertices; v++) {
            if (pitch !== 0) {
                let sin = GameModel.sine9[pitch];
                let cos = GameModel.sine9[pitch + 256];
                let x =
                    (this.vertexTransformedY[v] * sin +
                        this.vertexTransformedX[v] * cos) >>
                    15;

                this.vertexTransformedY[v] =
                    (this.vertexTransformedY[v] * cos -
                        this.vertexTransformedX[v] * sin) >>
                    15;
                this.vertexTransformedX[v] = x;
            }

            if (yaw !== 0) {
                let sin = GameModel.sine9[yaw];
                let cos = GameModel.sine9[yaw + 256];
                let y =
                    (this.vertexTransformedY[v] * cos -
                        this.vertexTransformedZ[v] * sin) >>
                    15;

                this.vertexTransformedZ[v] =
                    (this.vertexTransformedY[v] * sin +
                        this.vertexTransformedZ[v] * cos) >>
                    15;
                this.vertexTransformedY[v] = y;
            }

            if (roll !== 0) {
                let sin = GameModel.sine9[roll];
                let cos = GameModel.sine9[roll + 256];
                let x =
                    (this.vertexTransformedZ[v] * sin +
                        this.vertexTransformedX[v] * cos) >>
                    15;

                this.vertexTransformedZ[v] =
                    (this.vertexTransformedZ[v] * cos -
                        this.vertexTransformedX[v] * sin) >>
                    15;
                this.vertexTransformedX[v] = x;
            }
        }
    }

    applyShear(xy, xz, yx, yz, zx, zy) {
        for (let idx = 0; idx < this.numVertices; idx++) {
            if (xy !== 0) {
                this.vertexTransformedX[idx] +=
                    (this.vertexTransformedY[idx] * xy) >> 8;
            }

            if (xz !== 0) {
                this.vertexTransformedZ[idx] +=
                    (this.vertexTransformedY[idx] * xz) >> 8;
            }

            if (yx !== 0) {
                this.vertexTransformedX[idx] +=
                    (this.vertexTransformedZ[idx] * yx) >> 8;
            }

            if (yz !== 0) {
                this.vertexTransformedY[idx] +=
                    (this.vertexTransformedZ[idx] * yz) >> 8;
            }

            if (zx !== 0) {
                this.vertexTransformedZ[idx] +=
                    (this.vertexTransformedX[idx] * zx) >> 8;
            }

            if (zy !== 0) {
                this.vertexTransformedY[idx] +=
                    (this.vertexTransformedX[idx] * zy) >> 8;
            }
        }
    }

    applyScale(fx, fy, fz) {
        for (let v = 0; v < this.numVertices; v++) {
            this.vertexTransformedX[v] = (this.vertexTransformedX[v] * fx) >> 8;
            this.vertexTransformedY[v] = (this.vertexTransformedY[v] * fy) >> 8;
            this.vertexTransformedZ[v] = (this.vertexTransformedZ[v] * fz) >> 8;
        }
    }

    computeBounds() {
        this.x1 = this.y1 = this.z1 = 999999;
        this.diameter = this.x2 = this.y2 = this.z2 = -999999;

        for (let face = 0; face < this.numFaces; face++) {
            let vs = this.faceVertices[face];
            let v = vs[0];
            let n = this.faceNumVertices[face];
            let x1 = 0;
            let x2 = (x1 = this.vertexTransformedX[v]);
            let y1 = 0;
            let y2 = (y1 = this.vertexTransformedY[v]);
            let z1 = 0;
            let z2 = (z1 = this.vertexTransformedZ[v]);

            for (let i = 0; i < n; i++) {
                v = vs[i];

                if (this.vertexTransformedX[v] < x1) {
                    x1 = this.vertexTransformedX[v];
                } else if (this.vertexTransformedX[v] > x2) {
                    x2 = this.vertexTransformedX[v];
                }

                if (this.vertexTransformedY[v] < y1) {
                    y1 = this.vertexTransformedY[v];
                } else if (this.vertexTransformedY[v] > y2) {
                    y2 = this.vertexTransformedY[v];
                }

                if (this.vertexTransformedZ[v] < z1) {
                    z1 = this.vertexTransformedZ[v];
                } else if (this.vertexTransformedZ[v] > z2) {
                    z2 = this.vertexTransformedZ[v];
                }
            }

            if (!this.isolated) {
                this.faceBoundLeft[face] = x1;
                this.faceBoundRight[face] = x2;
                this.faceBoundBottom[face] = y1;
                this.faceBoundTop[face] = y2;
                this.faceBoundNear[face] = z1;
                this.faceBoundFar[face] = z2;
            }

            if (x2 - x1 > this.diameter) {
                this.diameter = x2 - x1;
            }

            if (y2 - y1 > this.diameter) {
                this.diameter = y2 - y1;
            }

            if (z2 - z1 > this.diameter) {
                this.diameter = z2 - z1;
            }

            if (x1 < this.x1) {
                this.x1 = x1;
            }

            if (x2 > this.x2) {
                this.x2 = x2;
            }

            if (y1 < this.y1) {
                this.y1 = y1;
            }

            if (y2 > this.y2) {
                this.y2 = y2;
            }

            if (z1 < this.z1) {
                this.z1 = z1;
            }

            if (z2 > this.z2) {
                this.z2 = z2;
            }
        }
    }

    light() {
        if (this.unlit) {
            return;
        }

        let divisor = (this.lightDiffuse * this.lightDirectionMagnitude) >> 8;

        for (let face = 0; face < this.numFaces; face++) {
            if (this.faceIntensity[this.face] !== this.magic) {
                this.faceIntensity[this.face] =
                    ((this.faceNormalX[face] * this.lightDirectionX +
                        this.faceNormalY[face] * this.lightDirectionY +
                        this.faceNormalZ[face] * this.lightDirectionZ) /
                        divisor) |
                    0;
            }
        }

        let normalX = new Int32Array(this.numVertices);
        let normalY = new Int32Array(this.numVertices);
        let normalZ = new Int32Array(this.numVertices);
        let normalMagnitude = new Int32Array(this.numVertices);

        for (let k = 0; k < this.numVertices; k++) {
            normalX[k] = 0;
            normalY[k] = 0;
            normalZ[k] = 0;
            normalMagnitude[k] = 0;
        }

        for (let face = 0; face < this.numFaces; face++) {
            if (this.faceIntensity[face] === this.magic) {
                for (let v = 0; v < this.faceNumVertices[face]; v++) {
                    let k1 = this.faceVertices[face][v];

                    normalX[k1] += this.faceNormalX[face];
                    normalY[k1] += this.faceNormalY[face];
                    normalZ[k1] += this.faceNormalZ[face];
                    normalMagnitude[k1]++;
                }
            }
        }

        for (let v = 0; v < this.numVertices; v++) {
            if (normalMagnitude[v] > 0) {
                this.vertexIntensity[v] =
                    ((normalX[v] * this.lightDirectionX +
                        normalY[v] * this.lightDirectionY +
                        normalZ[v] * this.lightDirectionZ) /
                        (divisor * normalMagnitude[v])) |
                    0;
            }
        }
    }

    relight() {
        if (this.unlit && this.isolated) {
            return;
        }

        for (let face = 0; face < this.numFaces; face++) {
            let verts = this.faceVertices[face];

            let aX = this.vertexTransformedX[verts[0]];
            let aY = this.vertexTransformedY[verts[0]];
            let aZ = this.vertexTransformedZ[verts[0]];
            let bX = this.vertexTransformedX[verts[1]] - aX;
            let bY = this.vertexTransformedY[verts[1]] - aY;
            let bZ = this.vertexTransformedZ[verts[1]] - aZ;
            let cX = this.vertexTransformedX[verts[2]] - aX;
            let cY = this.vertexTransformedY[verts[2]] - aY;
            let cZ = this.vertexTransformedZ[verts[2]] - aZ;

            let normX = bY * cZ - cY * bZ;
            let normY = bZ * cX - cZ * bX;
            let normZ;

            for (
                normZ = bX * cY - cX * bY;
                normX > 8192 ||
                normY > 8192 ||
                normZ > 8192 ||
                normX < -8192 ||
                normY < -8192 ||
                normZ < -8192;
                normZ >>= 1
            ) {
                normX >>= 1;
                normY >>= 1;
            }

            let normMag =
                (256 *
                    Math.sqrt(normX * normX + normY * normY + normZ * normZ)) |
                0;

            if (normMag <= 0) {
                normMag = 1;
            }

            this.faceNormalX[face] = ((normX * 0x10000) / normMag) | 0;
            this.faceNormalY[face] = ((normY * 0x10000) / normMag) | 0;
            this.faceNormalZ[face] = ((normZ * 65535) / normMag) | 0;
            this.normalScale[face] = -1;
        }

        this.light();
    }

    apply() {
        if (this.transformState === 2) {
            this.transformState = 0;

            for (let v = 0; v < this.numVertices; v++) {
                this.vertexTransformedX[v] = this.vertexX[v];
                this.vertexTransformedY[v] = this.vertexY[v];
                this.vertexTransformedZ[v] = this.vertexZ[v];
            }

            this.x1 = this.y1 = this.z1 = -9999999;
            this.diameter = this.x2 = this.y2 = this.z2 = 9999999;

            return;
        }

        if (this.transformState === 1) {
            this.transformState = 0;

            for (let v = 0; v < this.numVertices; v++) {
                this.vertexTransformedX[v] = this.vertexX[v];
                this.vertexTransformedY[v] = this.vertexY[v];
                this.vertexTransformedZ[v] = this.vertexZ[v];
            }

            if (this.transformKind >= 2) {
                this.applyRotation(
                    this.orientationYaw,
                    this.orientationPitch,
                    this.orientationRoll
                );
            }

            if (this.transformKind >= 3) {
                this.applyScale(this.scaleFx, this.scaleFy, this.scaleFz);
            }

            if (this.transformKind >= 4) {
                this.applyShear(
                    this.shearXy,
                    this.shearXz,
                    this.shearYx,
                    this.shearYz,
                    this.shearZx,
                    this.shearZy
                );
            }

            if (this.transformKind >= 1) {
                this.applyTranslate(this.baseX, this.baseY, this.baseZ);
            }

            this.computeBounds();
            this.relight();
        }
    }

    project(
        cameraX,
        cameraY,
        cameraZ,
        cameraPitch,
        cameraRoll,
        cameraYaw,
        viewDist,
        clipNear
    ) {
        this.apply();

        if (
            this.z1 > Scene.frustumNearZ ||
            this.z2 < Scene.frustumFarZ ||
            this.x1 > Scene.frustumMinX ||
            this.x2 < Scene.frustumMaxX ||
            this.y1 > Scene.frustumMinY ||
            this.y2 < Scene.frustumMaxY
        ) {
            this.visible = false;
            return;
        }

        this.visible = true;

        let yawSin = 0;
        let yawCos = 0;
        let pitchSin = 0;
        let pitchCos = 0;
        let rollSin = 0;
        let rollCos = 0;

        if (cameraYaw !== 0) {
            yawSin = GameModel.sine11[cameraYaw];
            yawCos = GameModel.sine11[cameraYaw + 1024];
        }

        if (cameraRoll !== 0) {
            rollSin = GameModel.sine11[cameraRoll];
            rollCos = GameModel.sine11[cameraRoll + 1024];
        }

        if (cameraPitch !== 0) {
            pitchSin = GameModel.sine11[cameraPitch];
            pitchCos = GameModel.sine11[cameraPitch + 1024];
        }

        for (let v = 0; v < this.numVertices; v++) {
            let x = this.vertexTransformedX[v] - cameraX;
            let y = this.vertexTransformedY[v] - cameraY;
            let z = this.vertexTransformedZ[v] - cameraZ;

            if (cameraYaw !== 0) {
                let X = (y * yawSin + x * yawCos) >> 15;
                y = (y * yawCos - x * yawSin) >> 15;
                x = X;
            }

            if (cameraRoll !== 0) {
                let X = (z * rollSin + x * rollCos) >> 15;
                z = (z * rollCos - x * rollSin) >> 15;
                x = X;
            }

            if (cameraPitch !== 0) {
                let Y = (y * pitchCos - z * pitchSin) >> 15;
                z = (y * pitchSin + z * pitchCos) >> 15;
                y = Y;
            }

            if (z >= clipNear) {
                this.vertexViewX[v] = ((x << viewDist) / z) | 0;
            } else {
                this.vertexViewX[v] = x << viewDist;
            }

            if (z >= clipNear) {
                this.vertexViewY[v] = ((y << viewDist) / z) | 0;
            } else {
                this.vertexViewY[v] = y << viewDist;
            }

            this.projectVertexX[v] = x;
            this.projectVertexY[v] = y;
            this.projectVertexZ[v] = z;
        }
    }

    commit() {
        this.apply();

        for (let i = 0; i < this.numVertices; i++) {
            this.vertexX[i] = this.vertexTransformedX[i];
            this.vertexY[i] = this.vertexTransformedY[i];
            this.vertexZ[i] = this.vertexTransformedZ[i];
        }

        this.baseX = this.baseY = this.baseZ = 0;
        this.orientationYaw = this.orientationPitch = this.orientationRoll = 0;
        this.scaleFx = this.scaleFy = this.scaleFz = 256;
        this.shearXy = this.shearXz = this.shearYx = this.shearYz = this.shearZx = this.shearZy = 256;
        this.transformKind = 0;
    }

    copy(...args) {
        if (!args || !args.length) {
            let pieces = [this];
            let gameModel = GameModel._from2A(pieces, 1);
            gameModel.depth = this.depth;
            gameModel.transparent = this.transparent;

            return gameModel;
        }

        const [autocommit, isolated, unlit, pickable] = args;

        let pieces = [this];
        let gameModel = GameModel._from6(
            pieces,
            1,
            autocommit,
            isolated,
            unlit,
            pickable
        );
        gameModel.depth = this.depth;

        return gameModel;
    }

    copyPosition(model) {
        this.orientationYaw = model.orientationYaw;
        this.orientationPitch = model.orientationPitch;
        this.orientationRoll = model.orientationRoll;
        this.baseX = model.baseX;
        this.baseY = model.baseY;
        this.baseZ = model.baseZ;
        this.determineTransformKind();
        this.transformState = 1;
    }

    readBase64(buff) {
        for (
            ;
            buff[this.dataPtr] === 10 || buff[this.dataPtr] === 13;
            this.dataPtr++
        );

        let hi = GameModel.base64Alphabet[buff[this.dataPtr++] & 0xff];
        let mid = GameModel.base64Alphabet[buff[this.dataPtr++] & 0xff];
        let lo = GameModel.base64Alphabet[buff[this.dataPtr++] & 0xff];
        let val = (hi * 4096 + mid * 64 + lo - 0x20000) | 0;

        if (val === 123456) {
            val = this.magic;
        }

        return val;
    }
}

GameModel.sine9 = new Int32Array(512);
GameModel.sine11 = new Int32Array(2048);

GameModel.base64Alphabet = new Int32Array(256);

for (let i = 0; i < 256; i++) {
    GameModel.sine9[i] = (Math.sin(i * 0.02454369) * 32768) | 0;
    GameModel.sine9[i + 256] = (Math.cos(i * 0.02454369) * 32768) | 0;
}

for (let j = 0; j < 1024; j++) {
    GameModel.sine11[j] = (Math.sin(j * 0.00613592315) * 32768) | 0;
    GameModel.sine11[j + 1024] = (Math.cos(j * 0.00613592315) * 32768) | 0;
}

for (let j1 = 0; j1 < 10; j1++) {
    GameModel.base64Alphabet[48 + j1] = j1;
}

for (let k1 = 0; k1 < 26; k1++) {
    GameModel.base64Alphabet[65 + k1] = k1 + 10;
}

for (let l1 = 0; l1 < 26; l1++) {
    GameModel.base64Alphabet[97 + l1] = l1 + 36;
}

GameModel.base64Alphabet[163] = 62;
GameModel.base64Alphabet[36] = 63;

module.exports = GameModel;

},{"./scene":72,"./utility":100}],46:[function(require,module,exports){
const BZLib = require('./bzlib');
const Color = require('./lib/graphics/color');
const Font = require('./lib/graphics/font');
const Graphics = require('./lib/graphics/graphics');
const Socket = require('./lib/net/socket');
const Surface = require('./surface');
const TGA = require('tga-js');
const Utility = require('./utility');
const keycodes = require('./lib/keycodes');
const version = require('./version');
const sleep = require('sleep-promise');

const CHAR_MAP =
    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!"\243$%^&' +
    "*()-_=+[{]};:'@#~,<.>/?\\| ";

const FONTS = [
    'h11p.jf',
    'h12b.jf',
    'h12p.jf',
    'h13b.jf',
    'h14b.jf',
    'h16b.jf',
    'h20b.jf',
    'h24b.jf'
];

class GameShell {
    constructor(canvas) {
        this._canvas = canvas;
        this._graphics = new Graphics(this._canvas);

        this.options = {
            middleClickCamera: false,
            mouseWheel: false,
            resetCompass: false,
            zoomCamera: false,
            showRoofs: true,
            remainingExperience: false,
            totalExperience: false,
            wordFilter: true,
            accountManagement: true,
            messageScrollBack: true,
            retroFPSCounter: false,
            retryLoginOnDisconnect: true
        };

        this.middleButtonDown = false;
        this.mouseScrollDelta = 0;

        this.mouseActionTimeout = 0;
        this.loadingStep = 0;
        this.logoHeaderText = null;
        this.mouseX = 0;
        this.mouseY = 0;
        this.mouseButtonDown = 0;
        this.lastMouseButtonDown = 0;
        this.timings = [];
        this.resetTimings();
        this.stopTimeout = 0;
        this.interlaceTimer = 0;
        this.loadingProgressPercent = 0;
        this.imageLogo = null;
        this.graphics = null;

        this.appletWidth = 512;
        this.appletHeight = 346;
        this.targetFps = 20;
        this.maxDrawTime = 1000;
        this.timings = [];
        this.loadingStep = 1;
        this.hasRefererLogoNotUsed = false;
        this.loadingProgessText = 'Loading';
        this.fontTimesRoman15 = new Font('TimesRoman', 0, 15);
        this.fontHelvetica13b = new Font('Helvetica', Font.BOLD, 13);
        this.fontHelvetica12 = new Font('Helvetica', 0, 12);
        this.keyLeft = false;
        this.keyRight = false;
        this.keyUp = false;
        this.keyDown = false;
        this.keySpace = false;
        this.keyHome = false;
        this.keyPgUp = false;
        this.keyPgDown = false;
        this.ctrl = false;
        this.threadSleep = 1;
        this.interlace = false;
        this.inputTextCurrent = '';
        this.inputTextFinal = '';
        this.inputPMCurrent = '';
        this.inputPMFinal = '';
    }

    async startApplication(width, height, title) {
        window.document.title = title;

        this._canvas.width = width;
        this._canvas.height = height;

        console.log('Started application');

        this.appletWidth = width;
        this.appletHeight = height;

        this._canvas.addEventListener(
            'mousedown',
            this.mousePressed.bind(this)
        );

        // prevent right clicks
        this._canvas.addEventListener('contextmenu', (event) => {
            event.preventDefault();
            return false;
        });

        this._canvas.addEventListener('mousemove', this.mouseMoved.bind(this));
        this._canvas.addEventListener('mouseup', this.mouseReleased.bind(this));
        this._canvas.addEventListener('mouseout', this.mouseOut.bind(this));
        this._canvas.addEventListener('wheel', this.mouseWheel.bind(this));

        window.addEventListener('beforeunload', () => this.onClosing());
        window.addEventListener('keydown', this.keyPressed.bind(this));
        window.addEventListener('keyup', this.keyReleased.bind(this));

        this.loadingStep = 1;

        await this.run();
    }

    setTargetFps(i) {
        this.targetFps = 1000 / i;
    }

    resetTimings() {
        for (let i = 0; i < 10; i += 1) {
            this.timings[i] = 0;
        }
    }

    keyPressed(e) {
        e.preventDefault();

        const code = e.keyCode;
        let charCode = e.key.length === 1 ? e.key.charCodeAt(0) : 65535;

        if (
            [8, 10, 13, 9].includes(code) ||
            (this.options.messageScrollBack &&
                [keycodes.UP_ARROW, keycodes.DOWN_ARROW].includes(code) &&
                this.ctrl)
        ) {
            charCode = code;
        }

        this.handleKeyPress(charCode);

        if (code === keycodes.LEFT_ARROW) {
            this.keyLeft = true;
        } else if (code === keycodes.RIGHT_ARROW) {
            this.keyRight = true;
        } else if (code === keycodes.UP_ARROW) {
            this.keyUp = true;
        } else if (code === keycodes.DOWN_ARROW) {
            this.keyDown = true;
        } else if (code === keycodes.SPACE) {
            this.keySpace = true;
        } else if (code === keycodes.F1) {
            this.interlace = !this.interlace;
        } else if (code === keycodes.HOME) {
            this.keyHome = true;
        } else if (code === keycodes.PAGE_UP) {
            this.keyPgUp = true;
        } else if (code === keycodes.PAGE_DOWN) {
            this.keyPgDown = true;
        } else if (code === keycodes.CTRL) {
            this.ctrl = true;
        }

        let foundText = false;

        for (let i = 0; i < CHAR_MAP.length; i++) {
            if (CHAR_MAP.charCodeAt(i) === charCode) {
                foundText = true;
                break;
            }
        }

        if (foundText) {
            if (this.inputTextCurrent.length < 20) {
                this.inputTextCurrent += String.fromCharCode(charCode);
            }

            if (this.inputPMCurrent.length < 80) {
                this.inputPMCurrent += String.fromCharCode(charCode);
            }
        }

        if (code === keycodes.ENTER) {
            this.inputTextFinal = this.inputTextCurrent;
            this.inputPMFinal = this.inputPMCurrent;
        } else if (code === keycodes.BACKSPACE) {
            if (this.inputTextCurrent.length > 0) {
                this.inputTextCurrent = this.inputTextCurrent.substring(
                    0,
                    this.inputTextCurrent.length - 1
                );
            }

            if (this.inputPMCurrent.length > 0) {
                this.inputPMCurrent = this.inputPMCurrent.substring(
                    0,
                    this.inputPMCurrent.length - 1
                );
            }
        }

        return false;
    }

    keyReleased(e) {
        e.preventDefault();

        const code = e.keyCode;

        if (code === keycodes.LEFT_ARROW) {
            this.keyLeft = false;
        } else if (code === keycodes.RIGHT_ARROW) {
            this.keyRight = false;
        } else if (code === keycodes.UP_ARROW) {
            this.keyUp = false;
        } else if (code === keycodes.DOWN_ARROW) {
            this.keyDown = false;
        } else if (code === keycodes.SPACE) {
            this.keySpace = false;
        } else if (code === keycodes.HOME) {
            this.keyHome = false;
        } else if (code === keycodes.PAGE_UP) {
            this.keyPgUp = false;
        } else if (code === keycodes.PAGE_DOWN) {
            this.keyPgDown = false;
        } else if (code === keycodes.CTRL) {
            this.ctrl = false;
        }

        return false;
    }

    mouseMoved(e) {
        this.mouseX = e.offsetX;
        this.mouseY = e.offsetY;
        this.mouseActionTimeout = 0;
    }

    mouseReleased(e) {
        this.mouseX = e.offsetX;
        this.mouseY = e.offsetY;
        this.mouseButtonDown = 0;

        if (e.button === 1) {
            this.middleButtonDown = false;
        }
    }

    mouseOut(e) {
        this.mouseX = e.offsetX;
        this.mouseY = e.offsetY;
        this.mouseButtonDown = 0;
        this.middleButtonDown = false;
    }

    mousePressed(e) {
        e.preventDefault();

        const x = e.offsetX;
        const y = e.offsetY;

        this.mouseX = x;
        this.mouseY = y;

        if (this.options.middleClickCamera && e.button === 1) {
            this.middleButtonDown = true;
            this.originRotation = this.cameraRotation;
            this.originMouseX = this.mouseX;
            return false;
        }

        if (e.metaKey || e.button === 2) {
            this.mouseButtonDown = 2;
        } else {
            this.mouseButtonDown = 1;
        }

        this.lastMouseButtonDown = this.mouseButtonDown;
        this.mouseActionTimeout = 0;
        this.handleMouseDown(this.mouseButtonDown, x, y);

        return false;
    }

    mouseWheel(e) {
        if (!this.options.mouseWheel) {
            return;
        }

        e.preventDefault();

        if (e.deltaMode === 0) {
            // deltaMode === 0 means deltaY/deltaY is given in pixels (chrome)
            this.mouseScrollDelta = Math.floor(e.deltaY / 14);
        } else if (e.deltaMode === 1) {
            // deltaMode === 1 means deltaY/deltaY is given in lines (firefox)
            this.mouseScrollDelta = Math.floor(e.deltaY);
        }

        return false;
    }

    start() {
        if (this.stopTimeout >= 0) {
            this.stopTimeout = 0;
        }
    }

    stop() {
        if (this.stopTimeout >= 0) {
            this.stopTimeout = 4000 / this.targetFps;
        }
    }

    async run() {
        if (this.loadingStep === 1) {
            this.loadingStep = 2;
            this.graphics = this.getGraphics();
            await this.loadJagex();
            this.drawLoadingScreen(0, 'Loading...');
            await this.startGame();
            this.loadingStep = 0;
        }

        let i = 0;
        let j = 256;
        let delay = 1;
        let i1 = 0;

        for (let j1 = 0; j1 < 10; j1++) {
            this.timings[j1] = Date.now();
        }

        while (this.stopTimeout >= 0) {
            if (this.stopTimeout > 0) {
                this.stopTimeout--;

                if (this.stopTimeout === 0) {
                    this.onClosing();
                    return;
                }
            }

            const k1 = j;
            const lastDelay = delay;

            j = 300;
            delay = 1;

            const time = Date.now();

            if (this.timings[i] === 0) {
                j = k1;
                delay = lastDelay;
            } else if (time > this.timings[i]) {
                j = ((2560 * this.targetFps) / (time - this.timings[i])) | 0;
            }

            if (j < 25) {
                j = 25;
            }

            if (j > 256) {
                j = 256;
                delay = (this.targetFps - (time - this.timings[i]) / 10) | 0;

                if (delay < this.threadSleep) {
                    delay = this.threadSleep;
                }
            }

            await sleep(delay);

            this.timings[i] = time;
            i = (i + 1) % 10;

            if (delay > 1) {
                for (let j2 = 0; j2 < 10; j2++) {
                    if (this.timings[j2] !== 0) {
                        this.timings[j2] += delay;
                    }
                }
            }

            let k2 = 0;

            while (i1 < 256) {
                await this.handleInputs();
                i1 += j;

                if (++k2 > this.maxDrawTime) {
                    i1 = 0;
                    this.interlaceTimer += 6;

                    if (this.interlaceTimer > 25) {
                        this.interlaceTimer = 0;
                        this.interlace = true;
                    }

                    break;
                }
            }

            this.interlaceTimer--;
            i1 &= 0xff;

            this.draw();

            // calculate fps
            this.fps = (1000 * j) / (this.targetFps * 256);

            this.mouseScrollDelta = 0;
        }
    }

    update(graphics) {
        this.paint(graphics);
    }

    paint() {
        if (this.loadingStep === 2 && this.imageLogo !== null) {
            this.drawLoadingScreen(
                this.loadingProgressPercent,
                this.loadingProgessText
            );
        }
    }

    async loadJagex() {
        this.graphics.setColor(Color.black);
        this.graphics.fillRect(0, 0, this.appletWidth, this.appletHeight);

        const jagexJag = await this.readDataFile(
            'jagex.jag',
            'Jagex library',
            0
        );

        if (jagexJag) {
            const logoTga = Utility.loadData('logo.tga', 0, jagexJag);
            this.imageLogo = this.parseTGA(logoTga);
        }

        const fontsJag = await this.readDataFile(
            `fonts${version.FONTS}.jag`,
            'Game fonts',
            5
        );

        if (jagexJag !== null) {
            for (let i = 0; i < FONTS.length; i += 1) {
                const fontName = FONTS[i];
                Surface.createFont(Utility.loadData(fontName, 0, fontsJag), i);
            }
        }
    }

    drawLoadingScreen(percent, text) {
        let x = ((this.appletWidth - 281) / 2) | 0;
        let y = ((this.appletHeight - 148) / 2) | 0;

        this.graphics.setColor(Color.black);
        this.graphics.fillRect(0, 0, this.appletWidth, this.appletHeight);

        if (!this.hasRefererLogoNotUsed) {
            this.graphics.drawImage(this.imageLogo, x, y /*, this*/);
        }

        x += 2;
        y += 90;

        this.loadingProgressPercent = percent;
        this.loadingProgessText = text;

        this.graphics.setColor(new Color(132, 132, 132));

        if (this.hasRefererLogoNotUsed) {
            this.graphics.setColor(new Color(220, 0, 0));
        }

        this.graphics.drawRect(x - 2, y - 2, 280, 23);
        this.graphics.fillRect(x, y, ((277 * percent) / 100) | 0, 20);
        this.graphics.setColor(new Color(198, 198, 198));

        if (this.hasRefererLogoNotUsed) {
            this.graphics.setColor(new Color(255, 255, 255));
        }

        this.drawString(
            this.graphics,
            text,
            this.fontTimesRoman15,
            x + 138,
            y + 10
        );

        if (!this.hasRefererLogoNotUsed) {
            this.drawString(
                this.graphics,
                'Created by JAGeX - visit www.jagex.com',
                this.fontHelvetica13b,
                x + 138,
                y + 30
            );
            this.drawString(
                this.graphics,
                '\u00a92001-2002 Andrew Gower and Jagex Ltd',
                this.fontHelvetica13b,
                x + 138,
                y + 44
            );
        } else {
            this.graphics.setColor(new Color(132, 132, 152));
            this.drawString(
                this.graphics,
                '\u00a92001-2002 Andrew Gower and Jagex Ltd',
                this.fontHelvetica12,
                x + 138,
                this.appletHeight - 20
            );
        }

        // not sure where this would have been used. maybe to indicate a
        // special client?
        if (this.logoHeaderText !== null) {
            this.graphics.setColor(Color.white);
            this.drawString(
                this.graphics,
                this.logoHeaderText,
                this.fontHelvetica13b,
                x + 138,
                y - 120
            );
        }
    }

    showLoadingProgress(percent, text) {
        let x = ((this.appletWidth - 281) / 2) | 0;
        let y = ((this.appletHeight - 148) / 2) | 0;
        x += 2;
        y += 90;

        this.loadingProgressPercent = percent;
        this.loadingProgessText = text;

        this.graphics.setColor(new Color(132, 132, 132));

        if (this.hasRefererLogoNotUsed) {
            this.graphics.setColor(new Color(220, 0, 0));
        }

        const progressWidth = ((277 * percent) / 100) | 0;

        this.graphics.fillRect(x, y, progressWidth, 20);
        this.graphics.setColor(Color.black);
        this.graphics.fillRect(x + progressWidth, y, 277 - progressWidth, 20);
        this.graphics.setColor(new Color(198, 198, 198));

        if (this.hasRefererLogoNotUsed) {
            this.graphics.setColor(new Color(255, 255, 255));
        }

        this.drawString(
            this.graphics,
            text,
            this.fontTimesRoman15,
            x + 138,
            y + 10
        );
    }

    drawString(graphics, string, font, x, y) {
        graphics.setFont(font);

        const { width, height } = graphics.ctx.measureText(string);

        graphics.drawString(
            string,
            x - ((width / 2) | 0),
            y + ((height / 4) | 0)
        );
    }

    parseTGA(tgaBuffer) {
        const tgaImage = new TGA();
        tgaImage.load(new Uint8Array(tgaBuffer.buffer));

        const canvas = tgaImage.getCanvas();
        const ctx = canvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

        return imageData;
    }

    async readDataFile(file, description, percent) {
        file = `./data204/${file}`;

        this.showLoadingProgress(percent, `Loading ${description} - 0%`);

        const fileDownloadStream = Utility.openFile(file);

        const header = new Int8Array(6);
        await fileDownloadStream.readFully(header, 0, 6);

        const archiveSize =
            ((header[0] & 0xff) << 16) +
            ((header[1] & 0xff) << 8) +
            (header[2] & 0xff);

        const archiveSizeCompressed =
            ((header[3] & 0xff) << 16) +
            ((header[4] & 0xff) << 8) +
            (header[5] & 0xff);

        this.showLoadingProgress(percent, `Loading ${description} - 5%`);

        let read = 0;
        const archiveData = new Int8Array(archiveSizeCompressed);

        while (read < archiveSizeCompressed) {
            let length = archiveSizeCompressed - read;

            if (length > 1000) {
                length = 1000;
            }

            await fileDownloadStream.readFully(archiveData, read, length);
            read += length;

            this.showLoadingProgress(
                percent,
                `Loading ${description} - ` +
                    ((5 + (read * 95) / archiveSizeCompressed) | 0) +
                    '%'
            );
        }

        this.showLoadingProgress(percent, `Unpacking ${description}`);

        if (archiveSizeCompressed !== archiveSize) {
            const decompressed = new Int8Array(archiveSize);

            BZLib.decompress(
                decompressed,
                archiveSize,
                archiveData,
                archiveSizeCompressed,
                0
            );

            return decompressed;
        }

        return archiveData;
    }

    getGraphics() {
        return this._graphics;
    }

    async createSocket(server, port) {
        const socket = new Socket(server, port);
        await socket.connect();
        return socket;
    }
}

module.exports = GameShell;

},{"./bzlib":39,"./lib/graphics/color":47,"./lib/graphics/font":48,"./lib/graphics/graphics":49,"./lib/keycodes":50,"./lib/net/socket":52,"./surface":74,"./utility":100,"./version":101,"sleep-promise":37,"tga-js":38}],47:[function(require,module,exports){
class Color {
    constructor(r, g, b, a = 255) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }

    toCanvasStyle() {
        return `rgba(${this.r},${this.g}, ${this.b}, ${this.a})`;
    }
}

Color.white = new Color(255, 255, 255);
Color.WHITE = Color.white;

Color.lightGray = new Color(192, 192, 192);
Color.LIGHT_GRAY = Color.lightGray;

Color.gray = new Color(128, 128, 128);
Color.GRAY = Color.gray;

Color.darkGray = new Color(64, 64, 64);
Color.DARK_GRAY = Color.darkGray;

Color.black = new Color(0, 0, 0);
Color.BLACK = Color.black;

Color.red = new Color(255, 0, 0);
Color.RED = Color.red;

Color.pink = new Color(255, 175, 175);
Color.PINK = Color.pink;

Color.orange = new Color(255, 200, 0);
Color.ORANGE = Color.orange;

Color.yellow = new Color(255, 255, 0);
Color.YELLOW = Color.yellow;

Color.green = new Color(0, 255, 0);
Color.GREEN = Color.green;

Color.magenta = new Color(255, 0, 255);
Color.MAGENTA = Color.magenta;

Color.cyan = new Color(0, 255, 255);
Color.CYAN = Color.cyan;

Color.blue = new Color(0, 0, 255);
Color.BLUE = Color.blue;

module.exports = Color;

},{}],48:[function(require,module,exports){
class Font {
    constructor(name, type, size) {
        this.name = name;
        this.type = type;
        this.size = size;
    }

    toCanvasFont() {
        return `${this.getType()} ${this.size}px ${this.name}`;
    }

    getType(){
        if (this.type === 1) {
            return 'bold';
        } else if (this.type === 2) {
            return 'italic';
        }

        return 'normal';
    }
}

module.exports = Font;
},{}],49:[function(require,module,exports){
// shims https://docs.oracle.com/javase/7/docs/api/java/awt/Graphics.html

class Graphics {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d', { alpha: false });
    }

    setColor(color) {
        this.ctx.fillStyle = color.toCanvasStyle();
        this.ctx.strokeStyle = color.toCanvasStyle();
    }

    fillRect(x, y, width, height) {
        this.ctx.fillRect(x, y, width, height);
    }

    drawRect(x, y, width, height) {
        this.ctx.strokeRect(x, y, width, height);
    }

    setFont(font) {
        this.ctx.font = font.toCanvasFont();
    }

    drawString(s, x, y) {
        this.ctx.fillText(s, x, y);
    }

    measureTextWidth(s) {
        return this.ctx.measureText(s).width;
    }

    drawImage(image, x, y) {
        this.ctx.putImageData(image, x, y);
    }

    getImage(width, height) {
        return this.ctx.getImageData(0, 0, width, height);
    }
}

module.exports = Graphics;

},{}],50:[function(require,module,exports){
module.exports={
   "0": 48,
   "1": 49,
   "2": 50,
   "3": 51,
   "4": 52,
   "5": 53,
   "6": 54,
   "7": 55,
   "8": 56,
   "9": 57,
   "BACKSPACE": 8,
   "TAB": 9,
   "ENTER": 13,
   "SPACE": 32,
   "SHIFT": 16,
   "CTRL": 17,
   "ALT": 18,
   "PAUSE_BREAK": 19,
   "CAPS_LOCK": 20,
   "ESCAPE": 27,
   "PAGE_UP": 33,
   "PAGE_DOWN": 34,
   "END": 35,
   "HOME": 36,
   "LEFT_ARROW": 37,
   "UP_ARROW": 38,
   "RIGHT_ARROW": 39,
   "DOWN_ARROW": 40,
   "INSERT": 45,
   "DELETE": 46,
   "A": 65,
   "B": 66,
   "C": 67,
   "D": 68,
   "E": 69,
   "F": 70,
   "G": 71,
   "H": 72,
   "I": 73,
   "J": 74,
   "K": 75,
   "L": 76,
   "M": 77,
   "N": 78,
   "O": 79,
   "P": 80,
   "Q": 81,
   "R": 82,
   "S": 83,
   "T": 84,
   "U": 85,
   "V": 86,
   "W": 87,
   "X": 88,
   "Y": 89,
   "Z": 90,
   "LEFT_WINDOW_KEY": 91,
   "RIGHT_WINDOW_KEY": 92,
   "SELECT_KEY": 93,
   "NUMPAD_0": 96,
   "NUMPAD_1": 97,
   "NUMPAD_2": 98,
   "NUMPAD_3": 99,
   "NUMPAD_4": 100,
   "NUMPAD_5": 101,
   "NUMPAD_6": 102,
   "NUMPAD_7": 103,
   "NUMPAD_8": 104,
   "NUMPAD_9": 105,
   "MULTIPLY": 106,
   "ADD": 107,
   "SUBTRACT": 109,
   "DECIMAL_POINT": 110,
   "DIVIDE": 111,
   "F1": 112,
   "F2": 113,
   "F3": 114,
   "F4": 115,
   "F5": 116,
   "F6": 117,
   "F7": 118,
   "F8": 119,
   "F9": 120,
   "F10": 121,
   "F11": 122,
   "F12": 123,
   "NUM_LOCK": 144,
   "SCROLL_LOCK": 145,
   "SEMI_COLON": 186,
   "EQUAL_SIGN": 187,
   "COMMA": 188,
   "DASH": 189,
   "PERIOD": 190,
   "FORWARD_SLASH": 191,
   "GRAVE_ACCENT": 192,
   "OPEN_BRACKET": 219,
   "BACK_SLASH": 220,
   "CLOSE_BRAKET": 221,
   "SINGLE_QUOTE": 222
}
},{}],51:[function(require,module,exports){
// a quick shim for downloading files

class FileDownloadStream {
    constructor(file) {
        this.url = file;

        this.xhr = new XMLHttpRequest();
        this.xhr.responseType = 'arraybuffer';
        this.xhr.open('GET', file, true);

        this.buffer = null;
        this.pos = 0;
    }

    _loadResBytes() {
        return new Promise((resolve, reject) => {
            this.xhr.onerror = e => reject(e);

            this.xhr.onload = () => {
                if (!/^2/.test(this.xhr.status)) {
                    reject(new Error(`unable to download ${this.url}.
                        status code = ${this.xhr.status}`));
                } else {
                    resolve(new Int8Array(this.xhr.response));
                }
            };

            this.xhr.send();
        });
    }

    async readFully(dest, off = 0, len) {
        if (typeof len === 'undefined') {
            len = dest.length;
        }

        if (!this.buffer) {
            this.buffer = await this._loadResBytes();
        }

        dest.set(this.buffer.slice(this.pos, this.pos + len), off);
        this.pos += len;
    }
}

module.exports = FileDownloadStream;

},{}],52:[function(require,module,exports){
// a shim for java.net.Socket
// https://docs.oracle.com/javase/7/docs/api/java/net/Socket.html

const CLOSE_TIMEOUT = 5000;

class Socket {
    constructor(host, port) {
        this.host = host;
        this.port = port;

        this.client = null;
        this.connected = false;

        // amount of bytes are left to read since last read call (in total)
        this.bytesAvailable = 0;

        // the message buffers that arrive from the websocket
        this.buffers = [];

        // the current buffer we're reading
        this.currentBuffer = null;

        // amount of bytes we read in current buffer
        this.offset = 0;

        // amount of bytes left in current buffer
        this.bytesLeft = 0;
    }

    connect() {
        return new Promise((resolve, reject) => {
            this.client = new WebSocket(
                `ws://${this.host}:${this.port}`,
                'binary'
            );

            const closeTimeout = setTimeout(() => {
                if (!this.connected) {
                    this.client.close();
                    reject(new Error('websocket connect timeout'));
                }
            }, CLOSE_TIMEOUT);

            this.client.binaryType = 'arraybuffer';

            const onError = (err) => {
                if (this.onError) {
                    this.onError(err);
                    this.onError = undefined;
                }

                reject(err);
            };

            this.client.addEventListener('error', onError);

            this.client.addEventListener('close', () => {
                if (this.onClose) {
                    this.onClose(-1);
                    this.onClose = undefined;
                }

                this.connected = false;
                this.clear();
            });

            this.client.addEventListener('message', (msg) => {
                this.buffers.push(new Int8Array(msg.data));
                this.bytesAvailable += msg.data.byteLength;
                this.refreshCurrentBuffer();

                if (this.onNextMessage) {
                    this.onNextMessage(msg.data.byteLength);
                    this.onNextMessage = undefined;
                }
            });

            this.client.addEventListener('open', () => {
                this.connected = true;
                clearTimeout(closeTimeout);
                resolve();
            });
        });
    }

    write(bytes, off = 0, len = -1) {
        if (!this.connected) {
            throw new Error('attempting to write to closed socket');
        }

        len = len === -1 ? bytes.length : len;
        this.client.send(bytes.slice(off, off + len));
    }

    refreshCurrentBuffer() {
        if (this.bytesLeft === 0 && this.bytesAvailable > 0) {
            this.currentBuffer = this.buffers.shift();
            this.offset = 0;

            if (this.currentBuffer && this.currentBuffer.length) {
                this.bytesLeft = this.currentBuffer.length;
            } else {
                this.bytesLeft = 0;
            }
        }
    }

    // read the first byte available in the buffer, or wait for one to be sent
    // if none are available.
    async read() {
        if (!this.connected) {
            return -1;
        }

        if (this.bytesLeft > 0) {
            this.bytesLeft--;
            this.bytesAvailable--;

            return this.currentBuffer[this.offset++] & 0xff;
        }

        const bytesRead = await new Promise((resolve, reject) => {
            this.onClose = resolve;
            this.onError = reject;
            this.onNextMessage = resolve;
        });

        if (bytesRead === -1) {
            return -1;
        }

        return await this.read();
    }

    // read multiple bytes (specified by `length`) and put them into the
    // `destination` array at specified `offset` (0 by default).
    async readBytes(destination, offset = 0, length = -1) {
        if (!this.connected) {
            return -1;
        }

        length = length === -1 ? destination.length : length;

        if (this.bytesAvailable >= length) {
            while (length > 0) {
                destination[offset++] =
                    this.currentBuffer[this.offset++] & 0xff;

                this.bytesLeft -= 1;
                this.bytesAvailable -= 1;
                length -= 1;

                if (this.bytesLeft === 0) {
                    this.refreshCurrentBuffer();
                }
            }

            return;
        }

        const bytesRead = await new Promise((resolve, reject) => {
            this.onClose = resolve;
            this.onError = reject;
            this.onNextMessage = resolve;
        });

        if (bytesRead === -1) {
            return -1;
        }

        return await this.readBytes(destination, offset, length);
    }

    close() {
        if (!this.connected) {
            return;
        }

        this.client.close();
    }

    available() {
        return this.bytesAvailable;
    }

    clear() {
        if (this.connected) {
            this.client.close();
        }

        this.currentBuffer = null;
        this.buffers.length = 0;
        this.bytesLeft = 0;
    }
}

module.exports = Socket;

},{}],53:[function(require,module,exports){
const ChatMessage = require('./chat-message');
const Color = require('./lib/graphics/color');
const Font = require('./lib/graphics/font');
const GameBuffer = require('./game-buffer');
const GameCharacter = require('./game-character');
const GameConnection = require('./game-connection');
const GameData = require('./game-data');
const GameModel = require('./game-model');
const Long = require('long');
const Panel = require('./panel');
const Scene = require('./scene');
const StreamAudioPlayer = require('./stream-audio-player');
const Surface = require('./surface');
const Utility = require('./utility');
const WordFilter = require('./word-filter');
const World = require('./world');
const applyUIComponents = require('./ui');
const getPacketHandlers = require('./packet-handlers');
const keycodes = require('./lib/keycodes');
const clientOpcodes = require('./opcodes/client');
const serverOpcodes = require('./opcodes/server');
const version = require('./version');

const ZOOM_MIN = 450;
const ZOOM_MAX = 1250;
const ZOOM_INDOORS = 550;
const ZOOM_OUTDOORS = 750;

const MENU_MAX = 250;
const PATH_STEPS_MAX = 8000;
const PLAYERS_MAX = 500;
const NPCS_MAX = 500;
const WALL_OBJECTS_MAX = 500;
const PLAYERS_SERVER_MAX = 4000;
const GROUND_ITEMS_MAX = 5000;
const NPCS_SERVER_MAX = 5000;
const OBJECTS_MAX = 1500;
const PLAYER_STAT_COUNT = 18;
const QUEST_COUNT = 50;
const PLAYER_STAT_EQUIPMENT_COUNT = 5;

const ANIMATED_MODELS = [
    'torcha2', 'torcha3', 'torcha4', 'skulltorcha2', 'skulltorcha3',
    'skulltorcha4', 'firea2', 'firea3', 'fireplacea2', 'fireplacea3',
    'firespell2', 'firespell3', 'lightning2', 'lightning3', 'clawspell2',
    'clawspell3', 'clawspell4', 'clawspell5', 'spellcharge2', 'spellcharge3'
];

function fromCharArray(a) {
    return Array.from(a).map(c => String.fromCharCode(c)).join('');
}

class mudclient extends GameConnection {
    constructor(canvas) {
        super(canvas);

        applyUIComponents(this);
        this.packetHandlers = getPacketHandlers(this);

        this.localRegionX = 0;
        this.localRegionY = 0;
        this.controlTextListChat = 0;
        this.controlTextListAll = 0;
        this.controlTextListQuest = 0;
        this.controlTextListPrivate = 0;
        this.messageTabSelected = 0;
        this.mouseClickXX = 0;
        this.mouseClickXY = 0;
        this.privateMessageTarget = new Long(0);
        this.controlListQuest = 0;
        this.controlListMagic = 0;
        this.packetErrorCount = 0;
        this.mouseButtonDownTime = 0;
        this.mouseButtonItemCountIncrement = 0;
        this.animationIndex = 0;
        this.cameraRotationX = 0;
        this.tradeConfirmAccepted = false;
        this.appearanceHeadType = 0;
        this.appearanceSkinColour = 0;
        this.anInt707 = 0;
        this.deathScreenTimeout = 0;
        this.cameraRotationY = 0;
        this.welcomeUnreadMessages = 0;
        this.logoutTimeout = 0;
        this.tradeRecipientConfirmHash = new Long(0);
        this.loginTimer = 0;
        this.npcCombatModelArray1 = new Int32Array([0, 1, 2, 1, 0, 0, 0, 0]);
        this.npcCombatModelArray2 = new Int32Array([0, 0, 0, 0, 0, 1, 2, 1]);
        this.systemUpdate = 0;
        this.graphics = null;
        this.regionX = 0;
        this.regionY = 0;
        this.welcomScreenAlreadyShown = false;
        this.mouseButtonClick = 0;
        this.healthBarCount = 0;
        this.spriteMedia = 0;
        this.spriteUtil = 0;
        this.spriteItem = 0;
        this.spriteProjectile = 0;
        this.spriteTexture = 0;
        this.spriteTextureWorld = 0;
        this.spriteLogo = 0;
        this.teleportBubbleCount = 0;
        this.mouseClickCount = 0;
        this.shopSellPriceMod = 0;
        this.shopBuyPriceMod = 0;
        this.duelOptionRetreat = 0;
        this.duelOptionMagic = 0;
        this.duelOptionPrayer = 0;
        this.duelOptionWeapons = 0;
        this.groundItemCount = 0;
        this.receivedMessagesCount = 0;
        this.messageTabFlashAll = 0;
        this.messageTabFlashHistory = 0;
        this.messageTabFlashQuest = 0;
        this.messageTabFlashPrivate = 0;
        this.bankItemCount = 0;
        this.objectAnimationNumberFireLightningSpell = 0;
        this.objectAnimationNumberTorch = 0;
        this.objectAnimationNumberClaw = 0;
        this.loggedIn = 0;
        this.npcCount = 0;
        this.npcCacheCount = 0;
        this.objectAnimationCount = 0;
        this.tradeConfirmItemsCount = 0;
        this.mouseClickXStep = 0;
        this.newBankItemCount = 0;

        // the orders of the NPC animation slots at different angles
        this.npcAnimationArray = [
            new Int32Array([11, 2, 9, 7, 1, 6, 10, 0, 5, 8, 3, 4]),
            new Int32Array([11, 2, 9, 7, 1, 6, 10, 0, 5, 8, 3, 4]),
            new Int32Array([11, 3, 2, 9, 7, 1, 6, 10, 0, 5, 8, 4]),
            new Int32Array([3, 4, 2, 9, 7, 1, 6, 10, 8, 11, 0, 5]),
            new Int32Array([3, 4, 2, 9, 7, 1, 6, 10, 8, 11, 0, 5]),
            new Int32Array([4, 3, 2, 9, 7, 1, 6, 10, 8, 11, 0, 5]),
            new Int32Array([11, 4, 2, 9, 7, 1, 6, 10, 0, 5, 8, 3]),
            new Int32Array([11, 2, 9, 7, 1, 6, 10, 0, 5, 8, 4, 3])];

        this.npcWalkModel = new Int32Array([0, 1, 2, 1]);
        this.referID = 0;
        this.combatTimeout = 0;
        this.optionMenuCount = 0;
        this.errorLoadingCodebase = false;
        this.cameraRotationTime = 0;
        this.duelOpponentItemsCount = 0;
        this.duelItemsCount = 0;
        this.characterSkinColours = new Int32Array([
            0xecded0, 0xccb366, 0xb38c40, 0x997326, 0x906020
        ]);
        this.duelOfferOpponentItemCount = 0;
        this.characterTopBottomColours = new Int32Array([
            0xff0000, 0xff8000, 0xffe000, 0xa0e000, 0x00e000,
            0x008000, 0x00a080, 0x00b0ff, 0x0080ff, 0x0030f0,
            0xe000e0, 0x303030, 0x604000, 0x805000, 0xffffff
        ]);
        this.itemsAboveHeadCount = 0;
        this.selectedItemInventoryIndex = 0;
        this.statFatigue = 0;
        this.fatigueSleeping = 0;
        this.tradeRecipientConfirmItemsCount = 0;
        this.tradeRecipientItemsCount = 0;
        this.showDialogServerMessage = false;
        this.menuX = 0;
        this.menuY = 0;
        this.menuWidth = 0;
        this.menuHeight = 0;
        this.menuItemsCount = 0;
        this.showUiTab = 0;
        this.tradeItemsCount = 0;
        this.planeWidth = 0;
        this.planeHeight = 0;
        this.planeMultiplier = 0;
        this.playerQuestPoints = 0;
        this.characterHairColours = new Int32Array([
            0xffc030, 0xffa040, 0x805030, 0x604020, 0x303030, 0xff6020, 0xff4000, 0xffffff, 65280, 65535
        ]);
        this.bankActivePage = 0;
        this.welcomeLastLoggedInDays = 0;
        this.inventoryItemsCount = 0;
        this.duelOpponentNameHash = new Long(0);
        this.minimapRandom1 = 0;
        this.minimapRandom2 = 0;
        this.objectCount = 0;
        this.duelOfferItemCount = 0;
        this.objectCount = 0;
        this.duelOfferItemCount = 0;
        this.cameraAutoRotatePlayerX = 0;
        this.cameraAutoRotatePlayerY = 0;
        this.playerCount = 0;
        this.knownPlayerCount = 0;
        this.spriteCount = 0;
        this.wallObjectCount = 0;
        this.welcomeRecoverySetDays = 0;
        this.localLowerX = 0;
        this.localLowerY = 0;
        this.localUpperX = 0;
        this.localUpperY = 0;
        this.world = null;
        this.welcomeLastLoggedInIP = 0;
        this.sleepWordDelayTimer = 0;

        this.menuIndices = new Int32Array(MENU_MAX);
        this.cameraAutoAngleDebug = false;
        this.wallObjectDirection = new Int32Array(WALL_OBJECTS_MAX);
        this.wallObjectId = new Int32Array(WALL_OBJECTS_MAX);
        this.cameraRotationXIncrement = 2;
        this.inventoryMaxItemCount = 30;
        this.bankItemsMax = 48;
        this.optionMenuEntry = [];
        this.optionMenuEntry.length = 5;
        this.optionMenuEntry.fill(null);
        this.newBankItems = new Int32Array(256);
        this.newBankItemsCount = new Int32Array(256);
        this.teleportBubbleTime = new Int32Array(50);
        this.tradeConfirmAccepted = false;
        this.receivedMessageX = new Int32Array(50);
        this.receivedMessageY = new Int32Array(50);
        this.receivedMessageMidPoint = new Int32Array(50);
        this.receivedMessageHeight = new Int32Array(50);
        this.localPlayer = new GameCharacter();
        this.localPlayerServerIndex = -1;
        this.menuItemX = new Int32Array(MENU_MAX);
        this.menuItemY = new Int32Array(MENU_MAX);
        this.bankItems = new Int32Array(256);
        this.bankItemsCount = new Int32Array(256);
        this.appearanceBodyGender = 1;
        this.appearance2Colour = 2;
        this.appearanceHairColour = 2;
        this.appearanceTopColour = 8;
        this.appearanceBottomColour = 14;
        this.appearanceHeadGender = 1;
        this.loginUser = '';
        this.loginPass = '';
        this.cameraAngle = 1;
        this.members = false;
        this.optionSoundDisabled = false;
        this.showRightClickMenu = false;
        this.cameraRotationYIncrement = 2;
        this.objectAlreadyInMenu = new Int8Array(OBJECTS_MAX);
        this.menuItemText1 = [];
        this.menuItemText1.length = MENU_MAX;
        this.menuItemText1.fill(null);
        this.duelOpponentName = '';
        this.lastObjectAnimationNumberFireLightningSpell = -1;
        this.lastObjectAnimationNumberTorch = -1;
        this.lastObjectAnimationNumberClaw = -1;
        this.planeIndex = -1;
        this.welcomScreenAlreadyShown = false;
        this.cameraRotation = 128;
        this.teleportBubbleX = new Int32Array(50);
        this.errorLoadingData = false;
        this.playerExperience = new Int32Array(PLAYER_STAT_COUNT);
        this.tradeRecipientAccepted = false;
        this.tradeAccepted = false;
        this.mouseClickXHistory = new Int32Array(8192);
        this.mouseClickYHistory = new Int32Array(8192);
        this.playerServerIndexes = new Int32Array(PLAYERS_MAX);
        this.teleportBubbleY = new Int32Array(50);
        this.receivedMessages = [];
        this.receivedMessages.length = 50;
        this.receivedMessages.fill(null);
        this.showDialogDuelConfirm = false;
        this.duelAccepted = false;
        this.players = [];
        this.players.length = PLAYERS_MAX;
        this.players.fill(null);
        this.prayerOn = new Int8Array(50);
        this.menuIndex = new Int32Array(MENU_MAX);
        this.menuSourceIndex = new Int32Array(MENU_MAX);
        this.menuTargetIndex = new Int32Array(MENU_MAX);
        this.wallObjectAlreadyInMenu = new Int8Array(WALL_OBJECTS_MAX);
        this.magicLoc = 128;
        this.errorLoadingMemory = false;
        this.fogOfWar = false;
        this.gameWidth = 512;
        this.gameHeight = 334;
        this.const_9 = 9;
        this.tradeConfirmItems = new Int32Array(14);
        this.tradeConfirmItemCount = new Int32Array(14);
        this.tradeRecipientName = '';
        this.selectedSpell = -1;
        this.showOptionMenu = false;
        this.playerStatCurrent = new Int32Array(PLAYER_STAT_COUNT);
        this.teleportBubbleType = new Int32Array(50);
        this.errorLoadingCodebase = false;
        this.showDialogShop = false;
        this.shopItem = new Int32Array(256);
        this.shopItemCount = new Int32Array(256);
        this.shopItemPrice = new Int32Array(256);
        this.duelOfferOpponentAccepted = false;
        this.duelOfferAccepted = false;
        this.gameModels = [];
        this.gameModels.length = 1000;
        this.gameModels.fill(null);
        this.showDialogDuel = false;
        this.serverMessage = '';
        this.serverMessageBoxTop = false;
        this.duelOpponentItems = new Int32Array(8);
        this.duelOpponentItemCount = new Int32Array(8);
        this.duelItems = new Int32Array(8);
        this.duelItemCount = new Int32Array(8);
        this.playerStatBase = new Int32Array(PLAYER_STAT_COUNT);
        this.npcsCache = [];
        this.npcsCache.length = NPCS_MAX;
        this.npcsCache.fill(null);
        this.groundItemX = new Int32Array(GROUND_ITEMS_MAX);
        this.groundItemY = new Int32Array(GROUND_ITEMS_MAX);
        this.groundItemID = new Int32Array(GROUND_ITEMS_MAX);
        this.groundItemZ = new Int32Array(GROUND_ITEMS_MAX);
        this.bankSelectedItemSlot = -1;
        this.bankSelectedItem = -2;
        this.duelOfferOpponentItemId = new Int32Array(8);
        this.duelOfferOpponentItemStack = new Int32Array(8);
        this.messageHistoryTimeout = new Int32Array(5);
        this.optionCameraModeAuto = true;
        this.objectX = new Int32Array(OBJECTS_MAX);
        this.objectY = new Int32Array(OBJECTS_MAX);
        this.objectId = new Int32Array(OBJECTS_MAX);
        this.objectDirection = new Int32Array(OBJECTS_MAX);
        this.selectedItemInventoryIndex = -1;
        this.selectedItemName = '';
        this.loadingArea = false;
        this.tradeRecipientConfirmItems = new Int32Array(14);
        this.tradeRecipientConfirmItemCount = new Int32Array(14);
        this.tradeRecipientItems = new Int32Array(14);
        this.tradeRecipientItemCount = new Int32Array(14);
        this.showDialogServerMessage = false;
        this.menuType = new Int32Array(MENU_MAX);
        this.questComplete = new Int8Array(QUEST_COUNT);
        this.wallObjectModel = [];
        this.wallObjectModel.length = WALL_OBJECTS_MAX;
        this.wallObjectModel.fill(null);
        this.actionBubbleX = new Int32Array(50);
        this.actionBubbleY = new Int32Array(50);
        this.cameraZoom = ZOOM_INDOORS; // 400-1250
        this.tradeItems = new Int32Array(14);
        this.tradeItemCount = new Int32Array(14);
        this.lastHeightOffset = -1;
        this.duelSettingsRetreat = false;
        this.duelSettingsMagic = false;
        this.duelSettingsPrayer = false;
        this.duelSettingsWeapons = false;
        this.showDialogBank = false;
        this.loginUserDesc = '';
        this.loginUserDisp = '';
        this.optionMouseButtonOne = false;
        this.inventoryItemId = new Int32Array(35);
        this.inventoryItemStackCount = new Int32Array(35);
        this.inventoryEquipped = new Int32Array(35);
        this.knownPlayers = [];
        this.knownPlayers.length = PLAYERS_MAX;
        this.knownPlayers.fill(null);
        this.messageHistory = [];
        this.messageHistory.length = 5;
        this.messageHistory.fill(null);
        this.duelOfferItemId = new Int32Array(8);
        this.duelOfferItemStack = new Int32Array(8);
        this.actionBubbleScale = new Int32Array(50);
        this.actionBubbleItem = new Int32Array(50);
        this.sleepWordDelay = true;
        this.showAppearanceChange = false;
        this.shopSelectedItemIndex = -1;
        this.shopSelectedItemType = -2;
        this.projectileMaxRange = 40;
        this.npcs = [];
        this.npcs.length = NPCS_MAX;
        this.npcs.fill(null);
        this.experienceArray = new Int32Array(99);
        this.healthBarX = new Int32Array(50);
        this.healthBarY = new Int32Array(50);
        this.healthBarMissing = new Int32Array(50);
        this.playerServer = [];
        this.playerServer.length = PLAYERS_SERVER_MAX;
        this.playerServer.fill(null);
        this.walkPathX = new Int32Array(PATH_STEPS_MAX);
        this.walkPathY = new Int32Array(PATH_STEPS_MAX);
        this.wallObjectX = new Int32Array(WALL_OBJECTS_MAX);
        this.wallObjectY = new Int32Array(WALL_OBJECTS_MAX);
        this.menuItemText2 = [];
        this.menuItemText2.length = MENU_MAX;
        this.menuItemText2.fill(null);
        this.npcsServer = [];
        this.npcsServer.length = NPCS_SERVER_MAX;
        this.npcsServer.fill(null);
        this.playerStatEquipment = new Int32Array(PLAYER_STAT_EQUIPMENT_COUNT);
        this.objectModel = [];
        this.objectModel.length = OBJECTS_MAX;
        this.objectModel.fill(null);

        // message scrollback
        this.playerMsgHistory = [];
        this.playerMsgPtr = 0;

        this.recoveryQuestions = [
            'Where were you born?',
            'What was your first teachers name?',
            'What is your fathers middle name?',
            'Who was your first best friend?',
            'What is your favourite vacation spot?',
            'What is your mothers middle name?',
            'What was your first pets name?',
            'What was the name of your first school?',
            'What is your mothers maiden name?',
            'Who was your first boyfriend/girlfriend?',
            'What was the first computer game you purchased?',
            'Who is your favourite actor/actress?',
            'Who is your favourite author?',
            'Who is your favourite musician?',
            'Who is your favourite cartoon character?',
            'What is your favourite book?',
            'What is your favourite food?',
            'What is your favourite movie?'
        ];

        this.showRecoverChange = false;
        this.recoverCustomQuestionIndex = -1;
        this.showChangePasswordStep = 0;
        this.changePasswordOld = '';
        this.changePasswordNew = '';
        this.welcomeTipDay = 0;
    }

    playSoundFile(soundName) {
        if (!this.audioPlayer || this.optionSoundDisabled) {
            return;
        }

        const filename = `${soundName}.pcm`;

        this.audioPlayer.writeStream(
            this.soundData,
            Utility.getDataFileOffset(filename, this.soundData),
            Utility.getDataFileLength(filename, this.soundData)
        );
    }

    _walkToActionSource_from8(startX, startY, x1, y1, x2, y2, checkObjects, walkToAction) {
        let steps = this.world.route(startX, startY, x1, y1, x2, y2, this.walkPathX, this.walkPathY, checkObjects);

        if (steps === -1) {
            if (walkToAction) {
                steps = 1;
                this.walkPathX[0] = x1;
                this.walkPathY[0] = y1;
            } else {
                return false;
            }
        }

        steps--;
        startX = this.walkPathX[steps];
        startY = this.walkPathY[steps];
        steps--;

        if (walkToAction) {
            this.packetStream.newPacket(clientOpcodes.WALK_ACTION);
        } else {
            this.packetStream.newPacket(clientOpcodes.WALK);
        }

        this.packetStream.putShort(startX + this.regionX);
        this.packetStream.putShort(startY + this.regionY);

        if (walkToAction && steps === -1 && (startX + this.regionX) % 5 === 0) {
            steps = 0;
        }

        for (let i = steps; i >= 0 && i > steps - 25; i--) {
            this.packetStream.putByte(this.walkPathX[i] - startX);
            this.packetStream.putByte(this.walkPathY[i] - startY);
        }

        this.packetStream.sendPacket();

        this.mouseClickXStep = -24;
        this.mouseClickXX = this.mouseX;
        this.mouseClickXY = this.mouseY;

        return true;
    }

    walkTo(startX, startY, x1, y1, x2, y2, checkObjects, walkToAction) {
        let steps = this.world.route(startX, startY, x1, y1, x2, y2, this.walkPathX, this.walkPathY, checkObjects);

        if (steps === -1) {
            return false;
        }

        steps--;
        startX = this.walkPathX[steps];
        startY = this.walkPathY[steps];
        steps--;

        if (walkToAction) {
            this.packetStream.newPacket(clientOpcodes.WALK_ACTION);
        } else {
            this.packetStream.newPacket(clientOpcodes.WALK);
        }

        this.packetStream.putShort(startX + this.regionX);
        this.packetStream.putShort(startY + this.regionY);

        if (walkToAction && steps === -1 && (startX + this.regionX) % 5 === 0) {
            steps = 0;
        }

        for (let i = steps; i >= 0 && i > steps - 25; i--) {
            this.packetStream.putByte(this.walkPathX[i] - startX);
            this.packetStream.putByte(this.walkPathY[i] - startY);
        }

        this.packetStream.sendPacket();

        this.mouseClickXStep = -24;
        this.mouseClickXX = this.mouseX;
        this.mouseClickXY = this.mouseY;

        return true;
    }

    updateBankItems() {
        this.bankItemCount = this.newBankItemCount;

        for (let i = 0; i < this.newBankItemCount; i++) {
            this.bankItems[i] = this.newBankItems[i];
            this.bankItemsCount[i] = this.newBankItemsCount[i];
        }

        for (let invIdx = 0; invIdx < this.inventoryItemsCount; invIdx++) {
            if (this.bankItemCount >= this.bankItemsMax) {
                break;
            }

            const inventoryID = this.inventoryItemId[invIdx];
            let hasItemInInventory = false;

            for (let i = 0; i < this.bankItemCount; i++) {
                if (this.bankItems[i] === inventoryID) {
                    hasItemInInventory = true;
                    break;
                }
            }

            if (!hasItemInInventory) {
                this.bankItems[this.bankItemCount] = inventoryID;
                this.bankItemsCount[this.bankItemCount] = 0;
                this.bankItemCount++;
            }
        }
    }

    drawAboveHeadStuff() {
        for (let i = 0; i < this.receivedMessagesCount; i++) {
            const textHeight = this.surface.textHeight(1);
            const x = this.receivedMessageX[i];
            let y = this.receivedMessageY[i];
            const messageMid = this.receivedMessageMidPoint[i];
            const messageHeight = this.receivedMessageHeight[i];
            let flag = true;

            while (flag) {
                flag = false;

                for (let j = 0; j < i; j++) {
                    if (y + messageHeight > this.receivedMessageY[j] - textHeight && y - textHeight < this.receivedMessageY[j] + this.receivedMessageHeight[j] && x - messageMid < this.receivedMessageX[j] + this.receivedMessageMidPoint[j] && x + messageMid > this.receivedMessageX[j] - this.receivedMessageMidPoint[j] && this.receivedMessageY[j] - textHeight - messageHeight < y) {
                        y = this.receivedMessageY[j] - textHeight - messageHeight;
                        flag = true;
                    }
                }
            }

            this.receivedMessageY[i] = y;
            this.surface.drawParagraph(this.receivedMessages[i], x, y, 1, 0xffff00, 300);
        }

        for (let i = 0; i < this.itemsAboveHeadCount; i++) {
            const x = this.actionBubbleX[i];
            const y = this.actionBubbleY[i];
            const scale = this.actionBubbleScale[i];
            const id = this.actionBubbleItem[i];
            const scaleX = ((39 * scale) / 100) | 0;
            const scaleY = ((27 * scale) / 100) | 0;

            this.surface.drawActionBubble(x - ((scaleX / 2) | 0), y - scaleY, scaleX, scaleY, this.spriteMedia + 9, 85);

            const scaleXClip = ((36 * scale) / 100) | 0;
            const scaleYClip = ((24 * scale) / 100) | 0;

            this.surface._spriteClipping_from9(x - ((scaleXClip / 2) | 0), (y - scaleY + ((scaleY / 2) | 0)) - ((scaleYClip / 2) | 0), scaleXClip, scaleYClip, GameData.itemPicture[id] + this.spriteItem, GameData.itemMask[id], 0, 0, false);
        }

        for (let i = 0; i < this.healthBarCount; i++) {
            const x = this.healthBarX[i];
            const y = this.healthBarY[i];
            const missing = this.healthBarMissing[i];

            this.surface.drawBoxAlpha(x - 15, y - 3, missing, 5, 65280, 192);
            this.surface.drawBoxAlpha((x - 15) + missing, y - 3, 30 - missing,
                5, 0xff0000, 192);
        }
    }

    _walkToActionSource_from5(sx, sy, dx, dy, action) {
        this._walkToActionSource_from8(sx, sy, dx, dy, dx, dy, false, action);
    }

    createMessageTabPanel() {
        this.panelMessageTabs = new Panel(this.surface, 10);
        this.controlTextListChat = this.panelMessageTabs.addTextList(5, 269, 502, 56, 1, 20, true);
        this.controlTextListAll = this.panelMessageTabs.addTextListInput(7, 324, 498, 14, 1, 80, false, true);
        this.controlTextListQuest = this.panelMessageTabs.addTextList(5, 269, 502, 56, 1, 20, true);
        this.controlTextListPrivate = this.panelMessageTabs.addTextList(5, 269, 502, 56, 1, 20, true);
        this.panelMessageTabs.setFocus(this.controlTextListAll);
    }

    disposeAndCollect() {
        if (this.surface !== null) {
            this.surface.clear();
            this.surface.pixels = null;
            this.surface = null;
        }

        if (this.scene !== null) {
            this.scene.dispose();
            this.scene = null;
        }

        this.gameModels = null;
        this.objectModel = null;
        this.wallObjectModel = null;
        this.playerServer = null;
        this.players = null;
        this.npcsServer = null;
        this.npcs = null;
        this.localPlayer = null;

        if (this.world !== null) {
            this.world.terrainModels = null;
            this.world.wallModels = null;
            this.world.roofModels = null;
            this.world.parentModel = null;
            this.world = null;
        }
    }

    drawUi() {
        if (this.logoutTimeout !== 0) {
            this.drawDialogLogout();
        } else if (this.showDialogWelcome) {
            this.drawDialogWelcome();
        } else if (this.showDialogServerMessage) {
            this.drawDialogServerMessage();
        } else if (this.showUiWildWarn === 1) {
            this.drawDialogWildWarn();
        } else if (this.showDialogBank && this.combatTimeout === 0) {
            this.drawDialogBank();
        } else if (this.showDialogShop && this.combatTimeout === 0) {
            this.drawDialogShop();
        } else if (this.showDialogTradeConfirm) {
            this.drawDialogTradeConfirm();
        } else if (this.showDialogTrade) {
            this.drawDialogTrade();
        } else if (this.showDialogDuelConfirm) {
            this.drawDialogDuelConfirm();
        } else if (this.showDialogDuel) {
            this.drawDialogDuel();
        } else if (this.showDialogReportAbuseStep === 1) {
            this.drawDialogReportAbuse();
        } else if (this.showDialogReportAbuseStep === 2) {
            this.drawDialogReportAbuseInput();
        } else if (this.showChangePasswordStep !== 0) {
            this.drawDialogChangePassword();
        } else if (this.showDialogSocialInput !== 0) {
            this.drawDialogSocialInput();
        } else {
            if (this.showOptionMenu) {
                this.drawOptionMenu();
            }

            if (this.localPlayer.animationCurrent === 8 ||
                this.localPlayer.animationCurrent === 9) {
                this.drawDialogCombatStyle();
            }

            this.setActiveUiTab();

            const noMenus = !this.showOptionMenu && !this.showRightClickMenu;

            if (noMenus) {
                this.menuItemsCount = 0;
            }

            if (this.showUiTab === 0 && noMenus) {
                this.createRightClickMenu();
            }

            if (this.showUiTab === 1) {
                this.drawUiTabInventory(noMenus);
            } else if (this.showUiTab === 2) {
                this.drawUiTabMinimap(noMenus);
            } else if (this.showUiTab === 3) {
                this.drawUiTabPlayerInfo(noMenus);
            } else if (this.showUiTab === 4) {
                this.drawUiTabMagic(noMenus);
            } else if (this.showUiTab === 5) {
                this.drawUiTabSocial(noMenus);
            } else if (this.showUiTab === 6) {
                this.drawUiTabOptions(noMenus);
            }

            if (!this.showRightClickMenu && !this.showOptionMenu) {
                this.createTopMouseMenu();
            }

            if (this.showRightClickMenu && !this.showOptionMenu) {
                this.drawRightClickMenu();
            }
        }

        this.mouseButtonClick = 0;
    }

    resetGame() {
        this.systemUpdate = 0;
        this.combatStyle = 0;
        this.logoutTimeout = 0;
        this.loginScreen = 0;
        this.loggedIn = 1;

        this.resetPMText();
        this.surface.blackScreen();
        this.surface.draw(this.graphics, 0, 0);

        for (let i = 0; i < this.objectCount; i++) {
            this.scene.removeModel(this.objectModel[i]);
            this.world.removeObject(this.objectX[i], this.objectY[i], this.objectId[i]);
        }

        for (let i = 0; i < this.wallObjectCount; i++) {
            this.scene.removeModel(this.wallObjectModel[i]);
            this.world.removeWallObject(this.wallObjectX[i], this.wallObjectY[i], this.wallObjectDirection[i], this.wallObjectId[i]);
        }

        this.objectCount = 0;
        this.wallObjectCount = 0;
        this.groundItemCount = 0;
        this.playerCount = 0;

        for (let i = 0; i < PLAYERS_SERVER_MAX; i++) {
            this.playerServer[i] = null;
        }

        for (let i = 0; i < PLAYERS_MAX; i++) {
            this.players[i] = null;
        }

        this.npcCount = 0;

        for (let i = 0; i < NPCS_SERVER_MAX; i++) {
            this.npcsServer[i] = null;
        }

        for (let i = 0; i < NPCS_MAX; i++) {
            this.npcs[i] = null;
        }

        for (let i = 0; i < this.prayerOn.length; i++) {
            this.prayerOn[i] = false;
        }

        this.mouseButtonClick = 0;
        this.lastMouseButtonDown = 0;
        this.mouseButtonDown = 0;
        this.showDialogShop = false;
        this.showDialogBank = false;
        this.isSleeping = false;
        this.friendListCount = 0;
    }

    handleKeyPress(keyCode) {
        if (this.loggedIn === 0) {
            if (this.loginScreen === 0 && this.panelLoginWelcome) {
                this.panelLoginWelcome.keyPress(keyCode);
            }

            if (this.loginScreen === 1 && this.panelLoginNewUser) {
                this.panelLoginNewUser.keyPress(keyCode);
            }

            if (this.loginScreen === 2 && this.panelLoginExistingUser) {
                this.panelLoginExistingUser.keyPress(keyCode);
            }

            if (this.loginScreen === 3 && this.panelRecoverUser) {
                this.panelRecoverUser.keyPress(keyCode);
            }
        }

        if (this.loggedIn === 1) {
            if (this.showAppearanceChange && this.panelAppearance !== null) {
                this.panelAppearance.keyPress(keyCode);
                return;
            }

            if (
                this.showChangePasswordStep === 0 &&
                this.showDialogSocialInput === 0 &&
                this.showDialogReportAbuseStep === 0 &&
                !this.isSleeping &&
                this.panelMessageTabs !== null
            ) {
                // for scrolling through messages the player previously sent
                if (this.options.messageScrollBack) {
                    if (
                        this.ctrl &&
                        [keycodes.UP_ARROW, keycodes.DOWN_ARROW].includes(keyCode)
                    ) {
                        if (keyCode === keycodes.UP_ARROW) {
                            if (this.playerMsgPtr >= this.playerMsgHistory.length) {
                                return;
                            }

                            this.playerMsgPtr += 1;
                        } else if (keyCode === keycodes.DOWN_ARROW) {
                            if (this.playerMsgPtr <= 1) {
                                this.panelMessageTabs.controlText[1] = "";
                                this.playerMsgPtr = 0;
                                return;
                            }

                            this.playerMsgPtr -= 1;
                        }

                        const newPlayerMsg = this.playerMsgHistory[
                            this.playerMsgHistory.length - this.playerMsgPtr
                        ];

                        if (newPlayerMsg) {
                            this.panelMessageTabs.controlText[1] = newPlayerMsg;
                        }

                        return;
                    }

                    if (keyCode === keycodes.ENTER) {
                        const chatMessage = this.panelMessageTabs.controlText[1];

                        if (chatMessage) {
                            const lastChatMessage = this.playerMsgHistory[
                                this.playerMsgHistory.length - 1
                            ];

                            if (chatMessage !== lastChatMessage) {
                                this.playerMsgHistory.push(chatMessage);
                            }

                            this.playerMsgPtr = 0;
                        }
                    }
                }

                this.panelMessageTabs.keyPress(keyCode);
            }

            if (
                this.showChangePasswordStep === 3 ||
                this.showChangePasswordStep === 4
            ) {
                this.showChangePasswordStep = 0;
            }
        }
    }

    sendLogout() {
        if (this.loggedIn === 0) {
            return;
        }

        if (this.combatTimeout > 450) {
            this.showMessage(
                "@cya@You can't logout during combat!",
                3
            );

            return;
        }

        if (this.combatTimeout > 0) {
            this.showMessage(
                "@cya@You can't logout for 10 seconds after combat",
                3
            );

            return;
        } else {
            this.packetStream.newPacket(clientOpcodes.LOGOUT);
            this.packetStream.sendPacket();
            this.logoutTimeout = 1000;
            return;
        }
    }

    createPlayer(serverIndex, x, y, anim) {
        if (this.playerServer[serverIndex] === null) {
            this.playerServer[serverIndex] = new GameCharacter();
            this.playerServer[serverIndex].serverIndex = serverIndex;
            this.playerServer[serverIndex].serverId = 0;
        }

        const player = this.playerServer[serverIndex];
        let flag = false;

        for (let i = 0; i < this.knownPlayerCount; i++) {
            if (this.knownPlayers[i].serverIndex !== serverIndex) {
                continue;
            }

            flag = true;
            break;
        }

        if (flag) {
            player.animationNext = anim;
            let j1 = player.waypointCurrent;

            if (x !== player.waypointsX[j1] || y !== player.waypointsY[j1]) {
                player.waypointCurrent = j1 = (j1 + 1) % 10;
                player.waypointsX[j1] = x;
                player.waypointsY[j1] = y;
            }
        } else {
            player.serverIndex = serverIndex;
            player.movingStep = 0;
            player.waypointCurrent = 0;
            player.waypointsX[0] = player.currentX = x;
            player.waypointsY[0] = player.currentY = y;
            player.animationNext = player.animationCurrent = anim;
            player.stepCount = 0;
        }

        this.players[this.playerCount++] = player;

        return player;
    }

    drawAppearancePanelCharacterSprites() {
        this.surface.interlace = false;
        this.surface.blackScreen();
        this.panelAppearance.drawPanel();
        let x = 140;
        let y = 50;
        x += 116;
        y -= 25;
        this.surface._spriteClipping_from6(x - 32 - 55, y, 64, 102, GameData.animationNumber[this.appearance2Colour], this.characterTopBottomColours[this.appearanceBottomColour]);
        this.surface._spriteClipping_from9(x - 32 - 55, y, 64, 102, GameData.animationNumber[this.appearanceBodyGender], this.characterTopBottomColours[this.appearanceTopColour], this.characterSkinColours[this.appearanceSkinColour], 0, false);
        this.surface._spriteClipping_from9(x - 32 - 55, y, 64, 102, GameData.animationNumber[this.appearanceHeadType], this.characterHairColours[this.appearanceHairColour], this.characterSkinColours[this.appearanceSkinColour], 0, false);
        this.surface._spriteClipping_from6(x - 32, y, 64, 102, GameData.animationNumber[this.appearance2Colour] + 6, this.characterTopBottomColours[this.appearanceBottomColour]);
        this.surface._spriteClipping_from9(x - 32, y, 64, 102, GameData.animationNumber[this.appearanceBodyGender] + 6, this.characterTopBottomColours[this.appearanceTopColour], this.characterSkinColours[this.appearanceSkinColour], 0, false);
        this.surface._spriteClipping_from9(x - 32, y, 64, 102, GameData.animationNumber[this.appearanceHeadType] + 6, this.characterHairColours[this.appearanceHairColour], this.characterSkinColours[this.appearanceSkinColour], 0, false);
        this.surface._spriteClipping_from6((x - 32) + 55, y, 64, 102, GameData.animationNumber[this.appearance2Colour] + 12, this.characterTopBottomColours[this.appearanceBottomColour]);
        this.surface._spriteClipping_from9((x - 32) + 55, y, 64, 102, GameData.animationNumber[this.appearanceBodyGender] + 12, this.characterTopBottomColours[this.appearanceTopColour], this.characterSkinColours[this.appearanceSkinColour], 0, false);
        this.surface._spriteClipping_from9((x - 32) + 55, y, 64, 102, GameData.animationNumber[this.appearanceHeadType] + 12, this.characterHairColours[this.appearanceHairColour], this.characterSkinColours[this.appearanceSkinColour], 0, false);
        this.surface._drawSprite_from3(0, this.gameHeight, this.spriteMedia + 22);
        this.surface.draw(this.graphics, 0, 0);
    }

    drawItem(x, y, w, h, id) {
        const picture = GameData.itemPicture[id] + this.spriteItem;
        const mask = GameData.itemMask[id];
        this.surface._spriteClipping_from9(x, y, w, h, picture, mask, 0, 0,
            false);
    }

    async handleGameInput() {
        if (this.systemUpdate > 1) {
            this.systemUpdate--;
        }

        await this.checkConnection();

        if (this.logoutTimeout > 0) {
            this.logoutTimeout--;
        }

        if (this.mouseActionTimeout > 4500 && this.combatTimeout === 0 && this.logoutTimeout === 0) {
            this.mouseActionTimeout -= 500;
            this.sendLogout();
            return;
        }

        if (this.localPlayer.animationCurrent === 8 || this.localPlayer.animationCurrent === 9) {
            this.combatTimeout = 500;
        }

        if (this.combatTimeout > 0) {
            this.combatTimeout--;
        }

        if (this.showAppearanceChange) {
            this.handleAppearancePanelInput();
            return;
        }

        for (let i = 0; i < this.playerCount; i++) {
            const player = this.players[i];

            // TODO figure out why this is happening
            if (!player) {
                console.log('null character at ', i, this.playerCount);
                return;
            }

            let k = (player.waypointCurrent + 1) % 10;

            if (player.movingStep !== k) {
                let i1 = -1;
                let l2 = player.movingStep;
                let j4;

                if (l2 < k) {
                    j4 = k - l2;
                } else {
                    j4 = (10 + k) - l2;
                }

                let j5 = 4;

                if (j4 > 2) {
                    j5 = (j4 - 1) * 4;
                }

                if (player.waypointsX[l2] - player.currentX > this.magicLoc * 3 || player.waypointsY[l2] - player.currentY > this.magicLoc * 3 || player.waypointsX[l2] - player.currentX < -this.magicLoc * 3 || player.waypointsY[l2] - player.currentY < -this.magicLoc * 3 || j4 > 8) {
                    player.currentX = player.waypointsX[l2];
                    player.currentY = player.waypointsY[l2];
                } else {
                    if (player.currentX < player.waypointsX[l2]) {
                        player.currentX += j5;
                        player.stepCount++;
                        i1 = 2;
                    } else if (player.currentX > player.waypointsX[l2]) {
                        player.currentX -= j5;
                        player.stepCount++;
                        i1 = 6;
                    }

                    if (player.currentX - player.waypointsX[l2] < j5 && player.currentX - player.waypointsX[l2] > -j5) {
                        player.currentX = player.waypointsX[l2];
                    }

                    if (player.currentY < player.waypointsY[l2]) {
                        player.currentY += j5;
                        player.stepCount++;

                        if (i1 === -1) {
                            i1 = 4;
                        } else if (i1 === 2) {
                            i1 = 3;
                        } else {
                            i1 = 5;
                        }
                    } else if (player.currentY > player.waypointsY[l2]) {
                        player.currentY -= j5;
                        player.stepCount++;

                        if (i1 === -1) {
                            i1 = 0;
                        } else if (i1 === 2) {
                            i1 = 1;
                        } else {
                            i1 = 7;
                        }
                    }

                    if (player.currentY - player.waypointsY[l2] < j5 && player.currentY - player.waypointsY[l2] > -j5) {
                        player.currentY = player.waypointsY[l2];
                    }
                }

                if (i1 !== -1) {
                    player.animationCurrent = i1;
                }

                if (player.currentX === player.waypointsX[l2] && player.currentY === player.waypointsY[l2]) {
                    player.movingStep = (l2 + 1) % 10;
                }
            } else {
                player.animationCurrent = player.animationNext;
            }

            if (player.messageTimeout > 0) {
                player.messageTimeout--;
            }

            if (player.bubbleTimeout > 0) {
                player.bubbleTimeout--;
            }

            if (player.combatTimer > 0) {
                player.combatTimer--;
            }

            if (this.deathScreenTimeout > 0) {
                this.deathScreenTimeout--;

                if (this.deathScreenTimeout === 0) {
                    this.showMessage('You have been granted another life. Be more careful this time!', 3);
                    this.showMessage('You retain your skills. Your objects land where you died', 3);
                }
            }
        }

        for (let i = 0; i < this.npcCount; i++) {
            const npc = this.npcs[i];
            let j1 = (npc.waypointCurrent + 1) % 10;

            if (npc.movingStep !== j1) {
                let i3 = -1;
                let k4 = npc.movingStep;
                let k5;

                if (k4 < j1) {
                    k5 = j1 - k4;
                } else {
                    k5 = (10 + j1) - k4;
                }

                let l5 = 4;

                if (k5 > 2) {
                    l5 = (k5 - 1) * 4;
                }

                if (npc.waypointsX[k4] - npc.currentX > this.magicLoc * 3 || npc.waypointsY[k4] - npc.currentY > this.magicLoc * 3 || npc.waypointsX[k4] - npc.currentX < -this.magicLoc * 3 || npc.waypointsY[k4] - npc.currentY < -this.magicLoc * 3 || k5 > 8) {
                    npc.currentX = npc.waypointsX[k4];
                    npc.currentY = npc.waypointsY[k4];
                } else {
                    if (npc.currentX < npc.waypointsX[k4]) {
                        npc.currentX += l5;
                        npc.stepCount++;
                        i3 = 2;
                    } else if (npc.currentX > npc.waypointsX[k4]) {
                        npc.currentX -= l5;
                        npc.stepCount++;
                        i3 = 6;
                    }

                    if (npc.currentX - npc.waypointsX[k4] < l5 && npc.currentX - npc.waypointsX[k4] > -l5) {
                        npc.currentX = npc.waypointsX[k4];
                    }

                    if (npc.currentY < npc.waypointsY[k4]) {
                        npc.currentY += l5;
                        npc.stepCount++;

                        if (i3 === -1) {
                            i3 = 4;
                        } else if (i3 === 2) {
                            i3 = 3;
                        } else {
                            i3 = 5;
                        }
                    } else if (npc.currentY > npc.waypointsY[k4]) {
                        npc.currentY -= l5;
                        npc.stepCount++;

                        if (i3 === -1) {
                            i3 = 0;
                        } else if (i3 === 2) {
                            i3 = 1;
                        } else {
                            i3 = 7;
                        }
                    }

                    if (npc.currentY - npc.waypointsY[k4] < l5 && npc.currentY - npc.waypointsY[k4] > -l5) {
                        npc.currentY = npc.waypointsY[k4];
                    }
                }

                if (i3 !== -1) {
                    npc.animationCurrent = i3;
                }

                if (npc.currentX === npc.waypointsX[k4] && npc.currentY === npc.waypointsY[k4]) {
                    npc.movingStep = (k4 + 1) % 10;
                }
            } else {
                npc.animationCurrent = npc.animationNext;

                if (npc.npcId === 43) {
                    npc.stepCount++;
                }
            }

            if (npc.messageTimeout > 0) {
                npc.messageTimeout--;
            }

            if (npc.bubbleTimeout > 0) {
                npc.bubbleTimeout--;
            }

            if (npc.combatTimer > 0) {
                npc.combatTimer--;
            }
        }

        if (this.showUiTab !== 2) {
            if (Surface.anInt346 > 0) {
                this.sleepWordDelayTimer++;
            }

            if (Surface.anInt347 > 0) {
                this.sleepWordDelayTimer = 0;
            }

            Surface.anInt346 = 0;
            Surface.anInt347 = 0;
        }

        for (let i = 0; i < this.playerCount; i++) {
            const player = this.players[i];

            if (player.projectileRange > 0) {
                player.projectileRange--;
            }
        }

        if (this.cameraAutoAngleDebug) {
            if (this.cameraAutoRotatePlayerX - this.localPlayer.currentX < -500 || this.cameraAutoRotatePlayerX - this.localPlayer.currentX > 500 || this.cameraAutoRotatePlayerY - this.localPlayer.currentY < -500 || this.cameraAutoRotatePlayerY - this.localPlayer.currentY > 500) {
                this.cameraAutoRotatePlayerX = this.localPlayer.currentX;
                this.cameraAutoRotatePlayerY = this.localPlayer.currentY;
            }
        } else {
            if (this.cameraAutoRotatePlayerX - this.localPlayer.currentX < -500 || this.cameraAutoRotatePlayerX - this.localPlayer.currentX > 500 || this.cameraAutoRotatePlayerY - this.localPlayer.currentY < -500 || this.cameraAutoRotatePlayerY - this.localPlayer.currentY > 500) {
                this.cameraAutoRotatePlayerX = this.localPlayer.currentX;
                this.cameraAutoRotatePlayerY = this.localPlayer.currentY;
            }

            if (this.cameraAutoRotatePlayerX !== this.localPlayer.currentX) {
                this.cameraAutoRotatePlayerX += ((this.localPlayer.currentX - this.cameraAutoRotatePlayerX) / (16 + (((this.cameraZoom - 500) / 15) | 0))) | 0;
            }

            if (this.cameraAutoRotatePlayerY !== this.localPlayer.currentY) {
                this.cameraAutoRotatePlayerY += ((this.localPlayer.currentY - this.cameraAutoRotatePlayerY) / (16 + (((this.cameraZoom - 500) / 15) | 0))) | 0;
            }

            if (this.optionCameraModeAuto) {
                let k1 = this.cameraAngle * 32;
                let j3 = k1 - this.cameraRotation;
                let byte0 = 1;

                if (j3 !== 0) {
                    this.anInt707++;

                    if (j3 > 128) {
                        byte0 = -1;
                        j3 = 256 - j3;
                    } else if (j3 > 0)
                        byte0 = 1;
                    else if (j3 < -128) {
                        byte0 = 1;
                        j3 = 256 + j3;
                    } else if (j3 < 0) {
                        byte0 = -1;
                        j3 = -j3;
                    }

                    this.cameraRotation += (((this.anInt707 * j3 + 255) / 256) | 0) * byte0;
                    this.cameraRotation &= 0xff;
                } else {
                    this.anInt707 = 0;
                }
            }
        }

        if (this.sleepWordDelayTimer > 20) {
            this.sleepWordDelay = false;
            this.sleepWordDelayTimer = 0;
        }

        if (this.isSleeping) {
            this.handleSleepInput();
            return;
        }

        if (this.mouseY > this.gameHeight - 4) {
            if (this.mouseX > 15 && this.mouseX < 96 && this.lastMouseButtonDown === 1) {
                this.messageTabSelected = 0;
            }

            if (this.mouseX > 110 && this.mouseX < 194 && this.lastMouseButtonDown === 1) {
                this.messageTabSelected = 1;
                this.panelMessageTabs.controlFlashText[this.controlTextListChat] = 999999;
            }

            if (this.mouseX > 215 && this.mouseX < 295 && this.lastMouseButtonDown === 1) {
                this.messageTabSelected = 2;
                this.panelMessageTabs.controlFlashText[this.controlTextListQuest] = 999999;
            }

            if (this.mouseX > 315 && this.mouseX < 395 && this.lastMouseButtonDown === 1) {
                this.messageTabSelected = 3;
                this.panelMessageTabs.controlFlashText[this.controlTextListPrivate] = 999999;
            }

            if (this.mouseX > 417 && this.mouseX < 497 && this.lastMouseButtonDown === 1) {
                this.showDialogReportAbuseStep = 1;
                this.reportAbuseOffence = 0;
                this.inputTextCurrent = '';
                this.inputTextFinal = '';
            }

            this.lastMouseButtonDown = 0;
            this.mouseButtonDown = 0;
        }

        this.panelMessageTabs.handleMouse(this.mouseX, this.mouseY, this.lastMouseButtonDown, this.mouseButtonDown, this.mouseScrollDelta);

        if (this.messageTabSelected > 0 && this.mouseX >= 494 && this.mouseY >= this.gameHeight - 66) {
            this.lastMouseButtonDown = 0;
        }

        if (this.panelMessageTabs.isClicked(this.controlTextListAll)) {
            let message = this.panelMessageTabs.getText(this.controlTextListAll);
            this.panelMessageTabs.updateText(this.controlTextListAll, '');

            if (/^::/.test(message)) {
                if (/^::closecon$/i.test(message)) {
                    this.packetStream.closeStream();
                } else if (/^::logout/i.test(message)) {
                    this.closeConnection();
                } else if (/^::lostcon$/i.test(message)) {
                    await this.lostConnection();
                } else {
                    this.sendCommandString(message.substring(2));
                }
            } else {
                const encodedMessage = ChatMessage.scramble(message);
                this.sendChatMessage(ChatMessage.scrambledBytes, encodedMessage);
                message = ChatMessage.descramble(ChatMessage.scrambledBytes, 0, encodedMessage);

                if (this.options.wordFilter) {
                    message = WordFilter.filter(message);
                }

                this.localPlayer.messageTimeout = 150;
                this.localPlayer.message = message;
                this.showMessage(`${this.localPlayer.name}: ${message}`, 2);
            }
        }

        if (this.messageTabSelected === 0) {
            for (let l1 = 0; l1 < 5; l1++) {
                if (this.messageHistoryTimeout[l1] > 0) {
                    this.messageHistoryTimeout[l1]--;
                }
            }
        }

        if (this.deathScreenTimeout !== 0) {
            this.lastMouseButtonDown = 0;
        }

        if (this.showDialogTrade || this.showDialogDuel) {
            if (this.mouseButtonDown !== 0) {
                this.mouseButtonDownTime++;
            } else {
                this.mouseButtonDownTime = 0;
            }

            if (this.mouseButtonDownTime > 600) {
                this.mouseButtonItemCountIncrement += 5000;
            } else if (this.mouseButtonDownTime > 450) {
                this.mouseButtonItemCountIncrement += 500;
            } else if (this.mouseButtonDownTime > 300) {
                this.mouseButtonItemCountIncrement += 50;
            } else if (this.mouseButtonDownTime > 150) {
                this.mouseButtonItemCountIncrement += 5;
            } else if (this.mouseButtonDownTime > 50) {
                this.mouseButtonItemCountIncrement++;
            } else if (this.mouseButtonDownTime > 20 && (this.mouseButtonDownTime & 5) === 0) {
                this.mouseButtonItemCountIncrement++;
            }
        } else {
            this.mouseButtonDownTime = 0;
            this.mouseButtonItemCountIncrement = 0;
        }

        if (this.lastMouseButtonDown === 1) {
            this.mouseButtonClick = 1;
        } else if (this.lastMouseButtonDown === 2) {
            this.mouseButtonClick = 2;
        }

        this.scene.setMouseLoc(this.mouseX, this.mouseY);
        this.lastMouseButtonDown = 0;

        if (this.optionCameraModeAuto) {
            if (this.anInt707 === 0 || this.cameraAutoAngleDebug) {
                if (this.keyLeft) {
                    this.cameraAngle = this.cameraAngle + 1 & 7;
                    this.keyLeft = false;

                    if (!this.fogOfWar) {
                        if ((this.cameraAngle & 1) === 0) {
                            this.cameraAngle = this.cameraAngle + 1 & 7;
                        }

                        for (let i2 = 0; i2 < 8; i2++) {
                            if (this.isValidCameraAngle(this.cameraAngle)) {
                                break;
                            }

                            this.cameraAngle = this.cameraAngle + 1 & 7;
                        }
                    }
                }

                if (this.keyRight) {
                    this.cameraAngle = this.cameraAngle + 7 & 7;
                    this.keyRight = false;

                    if (!this.fogOfWar) {
                        if ((this.cameraAngle & 1) === 0) {
                            this.cameraAngle = this.cameraAngle + 7 & 7;
                        }

                        for (let j2 = 0; j2 < 8; j2++) {
                            if (this.isValidCameraAngle(this.cameraAngle)) {
                                break;
                            }

                            this.cameraAngle = this.cameraAngle + 7 & 7;
                        }
                    }
                }
            }
        } else if (this.keyLeft) {
            this.cameraRotation = this.cameraRotation + 2 & 0xff;
        } else if (this.keyRight) {
            this.cameraRotation = this.cameraRotation - 2 & 0xff;
        }

        if (!this.optionCameraModeAuto && this.options.middleClickCamera && this.middleButtonDown) {
            this.cameraRotation = (this.originRotation + ((this.mouseX - this.originMouseX) / 2)) & 0xff;
        }

        if (this.options.zoomCamera) {
            this.handleCameraZoom();
        } else {
            if (this.fogOfWar && this.cameraZoom > ZOOM_INDOORS) {
                this.cameraZoom -= 4;
            } else if (!this.fogOfWar && this.cameraZoom < ZOOM_OUTDOORS) {
                this.cameraZoom += 4;
            }
        }

        if (this.mouseClickXStep > 0) {
            this.mouseClickXStep--;
        } else if (this.mouseClickXStep < 0) {
            this.mouseClickXStep++;
        }

        this.scene.doSOemthingWithTheFuckinFountainFuck(17);
        this.objectAnimationCount++;

        if (this.objectAnimationCount > 5) {
            this.objectAnimationCount = 0;
            this.objectAnimationNumberFireLightningSpell = (this.objectAnimationNumberFireLightningSpell + 1) % 3;
            this.objectAnimationNumberTorch = (this.objectAnimationNumberTorch + 1) % 4;
            this.objectAnimationNumberClaw = (this.objectAnimationNumberClaw + 1) % 5;
        }

        for (let i = 0; i < this.objectCount; i++) {
            const x = this.objectX[i];
            const y = this.objectY[i];

            if (x >= 0 && y >= 0 && x < 96 && y < 96 && this.objectId[i] === 74) {
                this.objectModel[i].rotate(1, 0, 0);
            }
        }

        for (let i = 0; i < this.teleportBubbleCount; i++) {
            this.teleportBubbleTime[i]++;

            if (this.teleportBubbleTime[i] > 50) {
                this.teleportBubbleCount--;

                for (let j = i; j < this.teleportBubbleCount; j++) {
                    this.teleportBubbleX[j] = this.teleportBubbleX[j + 1];
                    this.teleportBubbleY[j] = this.teleportBubbleY[j + 1];
                    this.teleportBubbleTime[j] = this.teleportBubbleTime[j + 1];
                    this.teleportBubbleType[j] = this.teleportBubbleType[j + 1];
                }
            }
        }
    }

    handleCameraZoom() {
        if (this.keyUp && !this.ctrl) {
            this.cameraZoom -= 16;
        } else if (this.keyDown && !this.ctrl) {
            this.cameraZoom += 16;
        } else if (this.keyHome) {
            this.cameraZoom = ZOOM_OUTDOORS;
        } else if (this.keyPgUp) {
            this.cameraZoom = ZOOM_MIN;
        } else if (this.keyPgDown) {
            this.cameraZoom = ZOOM_MAX;
        }

        if (this.mouseScrollDelta !== 0 && (this.showUiTab === 2 || this.showUiTab === 0)) {
            if (this.messageTabSelected !== 0 && this.mouseY > (this.gameHeight - 64)) {
                return;
            }

            this.cameraZoom += this.mouseScrollDelta * 24;
        }

        if (this.cameraZoom >= ZOOM_MAX) {
            this.cameraZoom = ZOOM_MAX;
        } else if (this.cameraZoom <= ZOOM_MIN) {
            this.cameraZoom = ZOOM_MIN;
        }
    }

    autoRotateCamera() {
        if ((this.cameraAngle & 1) === 1 && this.isValidCameraAngle(this.cameraAngle)) {
            return;
        }

        if ((this.cameraAngle & 1) === 0 && this.isValidCameraAngle(this.cameraAngle)) {
            if (this.isValidCameraAngle(this.cameraAngle + 1 & 7)) {
                this.cameraAngle = this.cameraAngle + 1 & 7;
                return;
            }

            if (this.isValidCameraAngle(this.cameraAngle + 7 & 7)) {
                this.cameraAngle = this.cameraAngle + 7 & 7;
            }

            return;
        }

        let ai = new Int32Array([1, -1, 2, -2, 3, -3, 4]);

        for (let i = 0; i < 7; i++) {
            if (!this.isValidCameraAngle(this.cameraAngle + ai[i] + 8 & 7)) {
                continue;
            }

            this.cameraAngle = this.cameraAngle + ai[i] + 8 & 7;
            break;
        }

        if ((this.cameraAngle & 1) === 0 && this.isValidCameraAngle(this.cameraAngle)) {
            if (this.isValidCameraAngle(this.cameraAngle + 1 & 7)) {
                this.cameraAngle = this.cameraAngle + 1 & 7;
                return;
            }

            if (this.isValidCameraAngle(this.cameraAngle + 7 & 7)) {
                this.cameraAngle = this.cameraAngle + 7 & 7;
            }
        }
    }

    drawRightClickMenu() {
        if (this.mouseButtonClick !== 0) {
            for (let i = 0; i < this.menuItemsCount; i++) {
                const entryX = this.menuX + 2;
                const entryY = this.menuY + 27 + i * 15;

                if (
                    this.mouseX <= entryX - 2 ||
                    this.mouseY <= entryY - 12 ||
                    this.mouseY >= entryY + 4 ||
                    this.mouseX >= (entryX - 3) + this.menuWidth
                ) {
                    continue;
                }

                this.menuItemClick(this.menuIndices[i]);
                break;
            }

            this.mouseButtonClick = 0;
            this.showRightClickMenu = false;
            return;
        }

        if (
            this.mouseX < this.menuX - 10 ||
            this.mouseY < this.menuY - 10 ||
            this.mouseX > this.menuX + this.menuWidth + 10 ||
            this.mouseY > this.menuY + this.menuHeight + 10
        ) {
            this.showRightClickMenu = false;
            return;
        }

        this.surface.drawBoxAlpha(
            this.menuX,
            this.menuY,
            this.menuWidth,
            this.menuHeight,
            0xd0d0d0,
            160
        );

        this.surface.drawString(
            'Choose option',
            this.menuX + 2,
            this.menuY + 12,
            1,
            0x00ffff
        );

        for (let i = 0; i < this.menuItemsCount; i++) {
            const entryX = this.menuX + 2;
            const entryY = this.menuY + 27 + i * 15;
            let textColour = 0xffffff;

            if (
                this.mouseX > entryX - 2 &&
                this.mouseY > entryY - 12 &&
                this.mouseY < entryY + 4 &&
                this.mouseX < (entryX - 3) + this.menuWidth
            ) {
                textColour = 0xffff00;
            }

            this.surface.drawString(
                this.menuItemText1[this.menuIndices[i]] + ' ' +
                    this.menuItemText2[this.menuIndices[i]],
                entryX,
                entryY,
                1,
                textColour
            );
        }
    }

    setActiveUiTab() {
        if (this.showUiTab === 0 && this.mouseX >= this.surface.width2 - 35 && this.mouseY >= 3 && this.mouseX < this.surface.width2 - 3 && this.mouseY < 35) {
            this.showUiTab = 1;
        }

        if (this.showUiTab === 0 && this.mouseX >= this.surface.width2 - 35 - 33 && this.mouseY >= 3 && this.mouseX < this.surface.width2 - 3 - 33 && this.mouseY < 35) {
            this.showUiTab = 2;
            this.minimapRandom1 = ((Math.random() * 13) | 0) - 6;
            this.minimapRandom2 = ((Math.random() * 23) | 0) - 11;
        }

        if (this.showUiTab === 0 && this.mouseX >= this.surface.width2 - 35 - 66 && this.mouseY >= 3 && this.mouseX < this.surface.width2 - 3 - 66 && this.mouseY < 35) {
            this.showUiTab = 3;
        }

        if (this.showUiTab === 0 && this.mouseX >= this.surface.width2 - 35 - 99 && this.mouseY >= 3 && this.mouseX < this.surface.width2 - 3 - 99 && this.mouseY < 35) {
            this.showUiTab = 4;
        }

        if (this.showUiTab === 0 && this.mouseX >= this.surface.width2 - 35 - 132 && this.mouseY >= 3 && this.mouseX < this.surface.width2 - 3 - 132 && this.mouseY < 35) {
            this.showUiTab = 5;
        }

        if (this.showUiTab === 0 && this.mouseX >= this.surface.width2 - 35 - 165 && this.mouseY >= 3 && this.mouseX < this.surface.width2 - 3 - 165 && this.mouseY < 35) {
            this.showUiTab = 6;
        }

        if (this.showUiTab !== 0 && this.mouseX >= this.surface.width2 - 35 && this.mouseY >= 3 && this.mouseX < this.surface.width2 - 3 && this.mouseY < 26) {
            this.showUiTab = 1;
        }

        if (this.showUiTab !== 0 && this.showUiTab !== 2 && this.mouseX >= this.surface.width2 - 35 - 33 && this.mouseY >= 3 && this.mouseX < this.surface.width2 - 3 - 33 && this.mouseY < 26) {
            this.showUiTab = 2;
            this.minimapRandom1 = ((Math.random() * 13) | 0) - 6;
            this.minimapRandom2 = ((Math.random() * 23) | 0) - 11;
        }

        if (this.showUiTab !== 0 && this.mouseX >= this.surface.width2 - 35 - 66 && this.mouseY >= 3 && this.mouseX < this.surface.width2 - 3 - 66 && this.mouseY < 26) {
            this.showUiTab = 3;
        }

        if (this.showUiTab !== 0 && this.mouseX >= this.surface.width2 - 35 - 99 && this.mouseY >= 3 && this.mouseX < this.surface.width2 - 3 - 99 && this.mouseY < 26) {
            this.showUiTab = 4;
        }

        if (this.showUiTab !== 0 && this.mouseX >= this.surface.width2 - 35 - 132 && this.mouseY >= 3 && this.mouseX < this.surface.width2 - 3 - 132 && this.mouseY < 26) {
            this.showUiTab = 5;
        }

        if (this.showUiTab !== 0 && this.mouseX >= this.surface.width2 - 35 - 165 && this.mouseY >= 3 && this.mouseX < this.surface.width2 - 3 - 165 && this.mouseY < 26) {
            this.showUiTab = 6;
        }

        if (this.showUiTab === 1 && (this.mouseX < this.surface.width2 - 248 || this.mouseY > 36 + ((this.inventoryMaxItemCount / 5) | 0) * 34)) {
            this.showUiTab = 0;
        }

        if (this.showUiTab === 3 && (this.mouseX < this.surface.width2 - 199 || this.mouseY > 316)) {
            this.showUiTab = 0;
        }

        if ((this.showUiTab === 2 || this.showUiTab === 4 || this.showUiTab === 5) && (this.mouseX < this.surface.width2 - 199 || this.mouseY > 240)) {
            this.showUiTab = 0;
        }

        if (this.showUiTab === 6 && (this.mouseX < this.surface.width2 - 199 || this.mouseY > 311)) {
            this.showUiTab = 0;
        }
    }

    drawNpc(x, y, w, h, id, tx, ty) {
        let character = this.npcs[id];
        let l1 = character.animationCurrent + (this.cameraRotation + 16) / 32 & 7;
        let flag = false;
        let i2 = l1;

        if (i2 === 5) {
            i2 = 3;
            flag = true;
        } else if (i2 === 6) {
            i2 = 2;
            flag = true;
        } else if (i2 === 7) {
            i2 = 1;
            flag = true;
        }

        let j2 = i2 * 3 + this.npcWalkModel[((character.stepCount / GameData.npcWalkModel[character.npcId]) | 0) % 4];

        if (character.animationCurrent === 8) {
            i2 = 5;
            l1 = 2;
            flag = false;
            x -= ((GameData.npcCombatAnimation[character.npcId] * ty) / 100) | 0;
            j2 = i2 * 3 + this.npcCombatModelArray1[(((this.loginTimer / (GameData.npcCombatModel[character.npcId]) | 0) - 1)) % 8];
        } else if (character.animationCurrent === 9) {
            i2 = 5;
            l1 = 2;
            flag = true;
            x += ((GameData.npcCombatAnimation[character.npcId] * ty) / 100) | 0;
            j2 = i2 * 3 + this.npcCombatModelArray2[((this.loginTimer / GameData.npcCombatModel[character.npcId]) | 0) % 8];
        }

        for (let k2 = 0; k2 < 12; k2++) {
            let l2 = this.npcAnimationArray[l1][k2];
            let k3 = GameData.npcSprite.get(character.npcId, l2);

            if (k3 >= 0) {
                let i4 = 0;
                let j4 = 0;
                let k4 = j2;

                if (flag && i2 >= 1 && i2 <= 3 && GameData.animationHasF[k3] === 1) {
                    k4 += 15;
                }

                if (i2 !== 5 || GameData.animationHasA[k3] === 1) {
                    let l4 = k4 + GameData.animationNumber[k3];

                    i4 = ((i4 * w) / this.surface.spriteWidthFull[l4]) | 0;
                    j4 = ((j4 * h) / this.surface.spriteHeightFull[l4]) | 0;

                    let i5 = ((w * this.surface.spriteWidthFull[l4]) / this.surface.spriteWidthFull[GameData.animationNumber[k3]]) | 0;

                    i4 -= ((i5 - w) / 2) | 0;

                    let col = GameData.animationCharacterColour[k3];
                    let skincol = 0;

                    if (col === 1) {
                        col = GameData.npcColourHair[character.npcId];
                        skincol = GameData.npcColourSkin[character.npcId];
                    } else if (col === 2) {
                        col = GameData.npcColourTop[character.npcId];
                        skincol = GameData.npcColourSkin[character.npcId];
                    } else if (col === 3) {
                        col = GameData.npcColorBottom[character.npcId];
                        skincol = GameData.npcColourSkin[character.npcId];
                    }

                    this.surface._spriteClipping_from9(x + i4, y + j4, i5, h, l4, col, skincol, tx, flag);
                }
            }
        }

        if (character.messageTimeout > 0) {
            this.receivedMessageMidPoint[this.receivedMessagesCount] = (this.surface.textWidth(character.message, 1) / 2) | 0;

            if (this.receivedMessageMidPoint[this.receivedMessagesCount] > 150) {
                this.receivedMessageMidPoint[this.receivedMessagesCount] = 150;
            }

            this.receivedMessageHeight[this.receivedMessagesCount] = ((this.surface.textWidth(character.message, 1) / 300) | 0) * this.surface.textHeight(1);
            this.receivedMessageX[this.receivedMessagesCount] = x + ((w / 2) | 0);
            this.receivedMessageY[this.receivedMessagesCount] = y;
            this.receivedMessages[this.receivedMessagesCount++] = character.message;
        }

        if (character.animationCurrent === 8 || character.animationCurrent === 9 || character.combatTimer !== 0) {
            if (character.combatTimer > 0) {
                let i3 = x;

                if (character.animationCurrent === 8) {
                    i3 -= ((20 * ty) / 100) | 0;
                } else if (character.animationCurrent === 9) {
                    i3 += ((20 * ty) / 100) | 0;
                }

                let l3 = ((character.healthCurrent * 30) / character.healthMax) | 0;

                this.healthBarX[this.healthBarCount] = i3 + ((w / 2) | 0);
                this.healthBarY[this.healthBarCount] = y;
                this.healthBarMissing[this.healthBarCount++] = l3;
            }

            if (character.combatTimer > 150) {
                let j3 = x;

                if (character.animationCurrent === 8) {
                    j3 -= ((10 * ty) / 100) | 0;
                } else if (character.animationCurrent === 9) {
                    j3 += ((10 * ty) / 100) | 0;
                }

                this.surface._drawSprite_from3((j3 + ((w / 2) | 0)) - 12, (y + ((h / 2) | 0)) - 12, this.spriteMedia + 12);
                this.surface.drawStringCenter(character.damageTaken.toString(), (j3 + ((w / 2) | 0)) - 1, y + ((h / 2) | 0) + 5, 3, 0xffffff);
            }
        }
    }

    walkToWallObject(i, j, k) {
        if (k === 0) {
            this._walkToActionSource_from8(this.localRegionX, this.localRegionY, i, j - 1, i, j, false, true);
        } else if (k === 1) {
            this._walkToActionSource_from8(this.localRegionX, this.localRegionY, i - 1, j, i, j, false, true);
        } else {
            this._walkToActionSource_from8(this.localRegionX, this.localRegionY, i, j, i, j, true, true);
        }
    }

    async loadGameConfig() {
        const configJag = await this.readDataFile(
            `config${version.CONFIG}.jag`,
            'Configuration',
            10
        );

        if (!configJag) {
            this.errorLoadingData = true;
            return;
        }

        GameData.loadData(configJag, this.members);

        const filterJag = await this.readDataFile(
            `filter${version.FILTER}.jag`,
            'Chat system',
            15
        );

        if (!filterJag) {
            this.errorLoadingData = true;
            return;
        }

        const fragments = new GameBuffer(
            Utility.loadData('fragmentsenc.txt', 0, filterJag)
        );

        const badWords = new GameBuffer(
            Utility.loadData('badenc.txt', 0, filterJag)
        );

        const hosts = new GameBuffer(
            Utility.loadData('hostenc.txt', 0, filterJag)
        );

        const tlds = new GameBuffer(
            Utility.loadData('tldlist.txt', 0, filterJag)
        );

        WordFilter.loadFilters(fragments, badWords, hosts, tlds);
    }

    addNpc(serverIndex, x, y, sprite, type) {
        if (this.npcsServer[serverIndex] === null) {
            this.npcsServer[serverIndex] = new GameCharacter();
            this.npcsServer[serverIndex].serverIndex = serverIndex;
        }

        let character = this.npcsServer[serverIndex];
        let foundNpc = false;

        for (let i = 0; i < this.npcCacheCount; i++) {
            if (this.npcsCache[i].serverIndex !== serverIndex) {
                continue;
            }

            foundNpc = true;
            break;
        }

        if (foundNpc) {
            character.npcId = type;
            character.animationNext = sprite;
            let waypointIdx = character.waypointCurrent;

            if (x !== character.waypointsX[waypointIdx] || y !== character.waypointsY[waypointIdx]) {
                character.waypointCurrent = waypointIdx = (waypointIdx + 1) % 10;
                character.waypointsX[waypointIdx] = x;
                character.waypointsY[waypointIdx] = y;
            }
        } else {
            character.serverIndex = serverIndex;
            character.movingStep = 0;
            character.waypointCurrent = 0;
            character.waypointsX[0] = character.currentX = x;
            character.waypointsY[0] = character.currentY = y;
            character.npcId = type;
            character.animationNext = character.animationCurrent = sprite;
            character.stepCount = 0;
        }

        this.npcs[this.npcCount++] = character;
        return character;
    }

    resetLoginVars() {
        this.systemUpdate = 0;
        this.loginScreen = 0;
        this.loggedIn = 0;
        this.logoutTimeout = 0;
    }

    drawDialogDuel() {
        if (this.mouseButtonClick !== 0 && this.mouseButtonItemCountIncrement === 0) {
            this.mouseButtonItemCountIncrement = 1;
        }

        if (this.mouseButtonItemCountIncrement > 0) {
            let mouseX = this.mouseX - 22;
            let mouseY = this.mouseY - 36;

            if (mouseX >= 0 && mouseY >= 0 && mouseX < 468 && mouseY < 262) {
                if (mouseX > 216 && mouseY > 30 && mouseX < 462 && mouseY < 235) {
                    let slot = ((((mouseX - 217) | 0) / 49) | 0) + (((mouseY - 31) / 34) | 0) * 5;
                    if (slot >= 0 && slot < this.inventoryItemsCount) {
                        let sendUpdate = false;
                        let l1 = 0;
                        let item = this.inventoryItemId[slot];

                        for (let k3 = 0; k3 < this.duelOfferItemCount; k3++) {
                            if (this.duelOfferItemId[k3] === item) {
                                if (GameData.itemStackable[item] === 0) {
                                    for (let i4 = 0; i4 < this.mouseButtonItemCountIncrement; i4++) {
                                        if (this.duelOfferItemStack[k3] < this.inventoryItemStackCount[slot]) {
                                            this.duelOfferItemStack[k3]++;
                                        }

                                        sendUpdate = true;
                                    }
                                } else {
                                    l1++;
                                }
                            }
                        }

                        if (this.getInventoryCount(item) <= l1) {
                            sendUpdate = true;
                        }

                        if (GameData.itemSpecial[item] === 1) {
                            this.showMessage('This object cannot be added to a duel offer', 3);
                            sendUpdate = true;
                        }

                        if (!sendUpdate && this.duelOfferItemCount < 8) {
                            this.duelOfferItemId[this.duelOfferItemCount] = item;
                            this.duelOfferItemStack[this.duelOfferItemCount] = 1;
                            this.duelOfferItemCount++;
                            sendUpdate = true;
                        }

                        if (sendUpdate) {
                            this.packetStream.newPacket(clientOpcodes.DUEL_ITEM_UPDATE);
                            this.packetStream.putByte(this.duelOfferItemCount);

                            for (let j4 = 0; j4 < this.duelOfferItemCount; j4++) {
                                this.packetStream.putShort(this.duelOfferItemId[j4]);
                                this.packetStream.putInt(this.duelOfferItemStack[j4]);
                            }

                            this.packetStream.sendPacket();
                            this.duelOfferOpponentAccepted = false;
                            this.duelOfferAccepted = false;
                        }
                    }
                }

                if (mouseX > 8 && mouseY > 30 && mouseX < 205 && mouseY < 129) {
                    let slot = (((mouseX - 9) / 49) | 0) + (((mouseY - 31) / 34) | 0) * 4;

                    if (slot >= 0 && slot < this.duelOfferItemCount) {
                        let j1 = this.duelOfferItemId[slot];
                        for (let i2 = 0; i2 < this.mouseButtonItemCountIncrement; i2++) {
                            if (GameData.itemStackable[j1] === 0 && this.duelOfferItemStack[slot] > 1) {
                                this.duelOfferItemStack[slot]--;
                                continue;
                            }

                            this.duelOfferItemCount--;
                            this.mouseButtonDownTime = 0;

                            for (let l2 = slot; l2 < this.duelOfferItemCount; l2++) {
                                this.duelOfferItemId[l2] = this.duelOfferItemId[l2 + 1];
                                this.duelOfferItemStack[l2] = this.duelOfferItemStack[l2 + 1];
                            }

                            break;
                        }

                        this.packetStream.newPacket(clientOpcodes.DUEL_ITEM_UPDATE);
                        this.packetStream.putByte(this.duelOfferItemCount);

                        for (let i3 = 0; i3 < this.duelOfferItemCount; i3++) {
                            this.packetStream.putShort(this.duelOfferItemId[i3]);
                            this.packetStream.putInt(this.duelOfferItemStack[i3]);
                        }

                        this.packetStream.sendPacket();
                        this.duelOfferOpponentAccepted = false;
                        this.duelOfferAccepted = false;
                    }
                }

                let flag = false;

                if (mouseX >= 93 && mouseY >= 221 && mouseX <= 104 && mouseY <= 232) {
                    this.duelSettingsRetreat = !this.duelSettingsRetreat;
                    flag = true;
                }

                if (mouseX >= 93 && mouseY >= 240 && mouseX <= 104 && mouseY <= 251) {
                    this.duelSettingsMagic = !this.duelSettingsMagic;
                    flag = true;
                }

                if (mouseX >= 191 && mouseY >= 221 && mouseX <= 202 && mouseY <= 232) {
                    this.duelSettingsPrayer = !this.duelSettingsPrayer;
                    flag = true;
                }

                if (mouseX >= 191 && mouseY >= 240 && mouseX <= 202 && mouseY <= 251) {
                    this.duelSettingsWeapons = !this.duelSettingsWeapons;
                    flag = true;
                }

                if (flag) {
                    this.packetStream.newPacket(clientOpcodes.DUEL_SETTINGS);
                    this.packetStream.putByte(this.duelSettingsRetreat ? 1 : 0);
                    this.packetStream.putByte(this.duelSettingsMagic ? 1 : 0);
                    this.packetStream.putByte(this.duelSettingsPrayer ? 1 : 0);
                    this.packetStream.putByte(this.duelSettingsWeapons ? 1 : 0);
                    this.packetStream.sendPacket();
                    this.duelOfferOpponentAccepted = false;
                    this.duelOfferAccepted = false;
                }

                if (mouseX >= 217 && mouseY >= 238 && mouseX <= 286 && mouseY <= 259) {
                    this.duelOfferAccepted = true;
                    this.packetStream.newPacket(clientOpcodes.DUEL_ACCEPT);
                    this.packetStream.sendPacket();
                }

                if (mouseX >= 394 && mouseY >= 238 && mouseX < 463 && mouseY < 259) {
                    this.showDialogDuel = false;
                    this.packetStream.newPacket(clientOpcodes.DUEL_DECLINE);
                    this.packetStream.sendPacket();
                }
            } else if (this.mouseButtonClick !== 0) {
                this.showDialogDuel = false;
                this.packetStream.newPacket(clientOpcodes.DUEL_DECLINE);
                this.packetStream.sendPacket();
            }

            this.mouseButtonClick = 0;
            this.mouseButtonItemCountIncrement = 0;
        }

        if (!this.showDialogDuel) {
            return;
        }

        //let dialogX = this.gameWidth / 2 - 468 / 2 + 22;
        //let dialogY = this.gameHeight / 2 - 262 / 2 + 22;
        let dialogX = 22;
        let dialogY = 36;

        this.surface.drawBox(dialogX, dialogY, 468, 12, 0xc90b1d);
        this.surface.drawBoxAlpha(dialogX, dialogY + 12, 468, 18, 0x989898, 160);
        this.surface.drawBoxAlpha(dialogX, dialogY + 30, 8, 248, 0x989898, 160);
        this.surface.drawBoxAlpha(dialogX + 205, dialogY + 30, 11, 248, 0x989898, 160);
        this.surface.drawBoxAlpha(dialogX + 462, dialogY + 30, 6, 248, 0x989898, 160);
        this.surface.drawBoxAlpha(dialogX + 8, dialogY + 99, 197, 24, 0x989898, 160);
        this.surface.drawBoxAlpha(dialogX + 8, dialogY + 192, 197, 23, 0x989898, 160);
        this.surface.drawBoxAlpha(dialogX + 8, dialogY + 258, 197, 20, 0x989898, 160);
        this.surface.drawBoxAlpha(dialogX + 216, dialogY + 235, 246, 43, 0x989898, 160);
        this.surface.drawBoxAlpha(dialogX + 8, dialogY + 30, 197, 69, 0xd0d0d0, 160);
        this.surface.drawBoxAlpha(dialogX + 8, dialogY + 123, 197, 69, 0xd0d0d0, 160);
        this.surface.drawBoxAlpha(dialogX + 8, dialogY + 215, 197, 43, 0xd0d0d0, 160);
        this.surface.drawBoxAlpha(dialogX + 216, dialogY + 30, 246, 205, 0xd0d0d0, 160);

        for (let j2 = 0; j2 < 3; j2++) {
            this.surface.drawLineHoriz(dialogX + 8, dialogY + 30 + j2 * 34, 197, 0);
        }

        for (let j3 = 0; j3 < 3; j3++) {
            this.surface.drawLineHoriz(dialogX + 8, dialogY + 123 + j3 * 34, 197, 0);
        }

        for (let l3 = 0; l3 < 7; l3++) {
            this.surface.drawLineHoriz(dialogX + 216, dialogY + 30 + l3 * 34, 246, 0);
        }

        for (let k4 = 0; k4 < 6; k4++) {
            if (k4 < 5) {
                this.surface.drawLineVert(dialogX + 8 + k4 * 49, dialogY + 30, 69, 0);
            }

            if (k4 < 5) {
                this.surface.drawLineVert(dialogX + 8 + k4 * 49, dialogY + 123, 69, 0);
            }

            this.surface.drawLineVert(dialogX + 216 + k4 * 49, dialogY + 30, 205, 0);
        }

        this.surface.drawLineHoriz(dialogX + 8, dialogY + 215, 197, 0);
        this.surface.drawLineHoriz(dialogX + 8, dialogY + 257, 197, 0);
        this.surface.drawLineVert(dialogX + 8, dialogY + 215, 43, 0);
        this.surface.drawLineVert(dialogX + 204, dialogY + 215, 43, 0);
        this.surface.drawString('Preparing to duel with: ' + this.duelOpponentName, dialogX + 1, dialogY + 10, 1, 0xffffff);
        this.surface.drawString('Your Stake', dialogX + 9, dialogY + 27, 4, 0xffffff);
        this.surface.drawString('Opponent\'s Stake', dialogX + 9, dialogY + 120, 4, 0xffffff);
        this.surface.drawString('Duel Options', dialogX + 9, dialogY + 212, 4, 0xffffff);
        this.surface.drawString('Your Inventory', dialogX + 216, dialogY + 27, 4, 0xffffff);
        this.surface.drawString('No retreating', dialogX + 8 + 1, dialogY + 215 + 16, 3, 0xffff00);
        this.surface.drawString('No magic', dialogX + 8 + 1, dialogY + 215 + 35, 3, 0xffff00);
        this.surface.drawString('No prayer', dialogX + 8 + 102, dialogY + 215 + 16, 3, 0xffff00);
        this.surface.drawString('No weapons', dialogX + 8 + 102, dialogY + 215 + 35, 3, 0xffff00);
        this.surface.drawBoxEdge(dialogX + 93, dialogY + 215 + 6, 11, 11, 0xffff00);

        if (this.duelSettingsRetreat) {
            this.surface.drawBox(dialogX + 95, dialogY + 215 + 8, 7, 7, 0xffff00);
        }

        this.surface.drawBoxEdge(dialogX + 93, dialogY + 215 + 25, 11, 11, 0xffff00);

        if (this.duelSettingsMagic) {
            this.surface.drawBox(dialogX + 95, dialogY + 215 + 27, 7, 7, 0xffff00);
        }

        this.surface.drawBoxEdge(dialogX + 191, dialogY + 215 + 6, 11, 11, 0xffff00);

        if (this.duelSettingsPrayer) {
            this.surface.drawBox(dialogX + 193, dialogY + 215 + 8, 7, 7, 0xffff00);
        }

        this.surface.drawBoxEdge(dialogX + 191, dialogY + 215 + 25, 11, 11, 0xffff00);

        if (this.duelSettingsWeapons) {
            this.surface.drawBox(dialogX + 193, dialogY + 215 + 27, 7, 7, 0xffff00);
        }

        if (!this.duelOfferAccepted) {
            this.surface._drawSprite_from3(dialogX + 217, dialogY + 238, this.spriteMedia + 25);
        }

        this.surface._drawSprite_from3(dialogX + 394, dialogY + 238, this.spriteMedia + 26);

        if (this.duelOfferOpponentAccepted) {
            this.surface.drawStringCenter('Other player', dialogX + 341, dialogY + 246, 1, 0xffffff);
            this.surface.drawStringCenter('has accepted', dialogX + 341, dialogY + 256, 1, 0xffffff);
        }

        if (this.duelOfferAccepted) {
            this.surface.drawStringCenter('Waiting for', dialogX + 217 + 35, dialogY + 246, 1, 0xffffff);
            this.surface.drawStringCenter('other player', dialogX + 217 + 35, dialogY + 256, 1, 0xffffff);
        }

        for (let i = 0; i < this.inventoryItemsCount; i++) {
            let x = 217 + dialogX + (i % 5) * 49;
            let y = 31 + dialogY + ((i / 5) | 0) * 34;
            this.surface._spriteClipping_from9(x, y, 48, 32, this.spriteItem + GameData.itemPicture[this.inventoryItemId[i]], GameData.itemMask[this.inventoryItemId[i]], 0, 0, false);

            if (GameData.itemStackable[this.inventoryItemId[i]] === 0) {
                this.surface.drawString(this.inventoryItemStackCount[i].toString(), x + 1, y + 10, 1, 0xffff00);
            }
        }

        for (let i = 0; i < this.duelOfferItemCount; i++) {
            let x = 9 + dialogX + (i % 4) * 49;
            let y = 31 + dialogY + ((i / 4) | 0) * 34;

            this.surface._spriteClipping_from9(x, y, 48, 32, this.spriteItem + GameData.itemPicture[this.duelOfferItemId[i]], GameData.itemMask[this.duelOfferItemId[i]], 0, 0, false);

            if (GameData.itemStackable[this.duelOfferItemId[i]] === 0) {
                this.surface.drawString(this.duelOfferItemStack[i].toString(), x + 1, y + 10, 1, 0xffff00);
            }

            if (this.mouseX > x && this.mouseX < x + 48 && this.mouseY > y && this.mouseY < y + 32) {
                this.surface.drawString(GameData.itemName[this.duelOfferItemId[i]] + ': @whi@' + GameData.itemDescription[this.duelOfferItemId[i]], dialogX + 8, dialogY + 273, 1, 0xffff00);
            }
        }

        for (let i = 0; i < this.duelOfferOpponentItemCount; i++) {
            let x = 9 + dialogX + (i % 4) * 49;
            let y = 124 + dialogY + ((i / 4) | 0) * 34;

            this.surface._spriteClipping_from9(x, y, 48, 32, this.spriteItem + GameData.itemPicture[this.duelOfferOpponentItemId[i]], GameData.itemMask[this.duelOfferOpponentItemId[i]], 0, 0, false);

            if (GameData.itemStackable[this.duelOfferOpponentItemId[i]] === 0) {
                this.surface.drawString(this.duelOfferOpponentItemStack[i].toString(), x + 1, y + 10, 1, 0xffff00);
            }

            if (this.mouseX > x && this.mouseX < x + 48 && this.mouseY > y && this.mouseY < y + 32) {
                this.surface.drawString(GameData.itemName[this.duelOfferOpponentItemId[i]] + ': @whi@' + GameData.itemDescription[this.duelOfferOpponentItemId[i]], dialogX + 8, dialogY + 273, 1, 0xffff00);
            }
        }
    }

    loadNextRegion(lx, ly) {
        if (this.deathScreenTimeout !== 0) {
            this.world.playerAlive = false;
            return false;
        }

        this.loadingArea = false;
        lx += this.planeWidth;
        ly += this.planeHeight;

        if (this.lastHeightOffset === this.planeIndex && lx > this.localLowerX && lx < this.localUpperX && ly > this.localLowerY && ly < this.localUpperY) {
            this.world.playerAlive = true;
            return false;
        }

        this.surface.drawStringCenter('Loading... Please wait', 256, 192, 1, 0xffffff);
        this.drawChatMessageTabs();
        this.surface.draw(this.graphics, 0, 0);

        let ax = this.regionX;
        let ay = this.regionY;
        let sectionX = ((lx + 24) / 48) | 0;
        let sectionY = ((ly + 24) / 48) | 0;

        this.lastHeightOffset = this.planeIndex;
        this.regionX = sectionX * 48 - 48;
        this.regionY = sectionY * 48 - 48;
        this.localLowerX = sectionX * 48 - 32;
        this.localLowerY = sectionY * 48 - 32;
        this.localUpperX = sectionX * 48 + 32;
        this.localUpperY = sectionY * 48 + 32;

        this.world._loadSection_from3(lx, ly, this.lastHeightOffset);

        this.regionX -= this.planeWidth;
        this.regionY -= this.planeHeight;

        let offsetX = this.regionX - ax;
        let offsetY = this.regionY - ay;

        for (let objIdx = 0; objIdx < this.objectCount; objIdx++) {
            this.objectX[objIdx] -= offsetX;
            this.objectY[objIdx] -= offsetY;

            let objx = this.objectX[objIdx];
            let objy = this.objectY[objIdx];
            let objid = this.objectId[objIdx];

            let gameModel = this.objectModel[objIdx];

            try {
                let objType = this.objectDirection[objIdx];
                let objW = 0;
                let objH = 0;

                if (objType === 0 || objType === 4) {
                    objW = GameData.objectWidth[objid];
                    objH = GameData.objectHeight[objid];
                } else {
                    objH = GameData.objectWidth[objid];
                    objW = GameData.objectHeight[objid];
                }

                let j6 = (((objx + objx + objW) * this.magicLoc) / 2) | 0;
                let k6 = (((objy + objy + objH) * this.magicLoc) / 2) | 0;

                if (objx >= 0 && objy >= 0 && objx < 96 && objy < 96) {
                    this.scene.addModel(gameModel);
                    gameModel.place(j6, -this.world.getElevation(j6, k6), k6);
                    this.world.removeObject2(objx, objy, objid);

                    if (objid === 74) {
                        gameModel.translate(0, -480, 0);
                    }
                }
            } catch (e) {
                console.log('Loc Error: ' + e.message);
                console.error(e);
            }
        }

        for (let k2 = 0; k2 < this.wallObjectCount; k2++) {
            this.wallObjectX[k2] -= offsetX;
            this.wallObjectY[k2] -= offsetY;

            let i3 = this.wallObjectX[k2];
            let l3 = this.wallObjectY[k2];
            let j4 = this.wallObjectId[k2];
            let i5 = this.wallObjectDirection[k2];

            try {
                this.world._setObjectAdjacency_from4(i3, l3, i5, j4);
                let gameModel_1 = this.createModel(i3, l3, i5, j4, k2);
                this.wallObjectModel[k2] = gameModel_1;
            } catch (e) {
                console.log('Bound Error: ' + e.message);
                console.error(e);
            }
        }

        for (let j3 = 0; j3 < this.groundItemCount; j3++) {
            this.groundItemX[j3] -= offsetX;
            this.groundItemY[j3] -= offsetY;
        }

        for (let i4 = 0; i4 < this.playerCount; i4++) {
            let character = this.players[i4];

            character.currentX -= offsetX * this.magicLoc;
            character.currentY -= offsetY * this.magicLoc;

            for (let j5 = 0; j5 <= character.waypointCurrent; j5++) {
                character.waypointsX[j5] -= offsetX * this.magicLoc;
                character.waypointsY[j5] -= offsetY * this.magicLoc;
            }

        }

        for (let k4 = 0; k4 < this.npcCount; k4++) {
            let character_1 = this.npcs[k4];

            character_1.currentX -= offsetX * this.magicLoc;
            character_1.currentY -= offsetY * this.magicLoc;

            for (let l5 = 0; l5 <= character_1.waypointCurrent; l5++) {
                character_1.waypointsX[l5] -= offsetX * this.magicLoc;
                character_1.waypointsY[l5] -= offsetY * this.magicLoc;
            }
        }

        this.world.playerAlive = true;

        return true;
    }

    drawPlayer(x, y, w, h, id, tx, ty) {
        let character = this.players[id];

        // this means the character is invisible! MOD!!!
        if (character.colourBottom === 255)  {
            return;
        }

        let l1 = character.animationCurrent + (this.cameraRotation + 16) / 32 & 7;
        let flag = false;
        let i2 = l1;

        if (i2 === 5) {
            i2 = 3;
            flag = true;
        } else if (i2 === 6) {
            i2 = 2;
            flag = true;
        } else if (i2 === 7) {
            i2 = 1;
            flag = true;
        }

        let j2 = i2 * 3 + this.npcWalkModel[((character.stepCount / 6) | 0) % 4];

        if (character.animationCurrent === 8) {
            i2 = 5;
            l1 = 2;
            flag = false;
            x -= ((5 * ty) / 100) | 0;
            j2 = i2 * 3 + this.npcCombatModelArray1[((this.loginTimer / 5) | 0) % 8];
        } else if (character.animationCurrent === 9) {
            i2 = 5;
            l1 = 2;
            flag = true;
            x += ((5 * ty) / 100) | 0;
            j2 = i2 * 3 + this.npcCombatModelArray2[((this.loginTimer / 6) | 0) % 8];
        }

        for (let k2 = 0; k2 < 12; k2++) {
            let l2 = this.npcAnimationArray[l1][k2];
            let l3 = character.equippedItem[l2] - 1;

            if (l3 >= 0) {
                let k4 = 0;
                let i5 = 0;
                let j5 = j2;

                if (flag && i2 >= 1 && i2 <= 3) {
                    if (GameData.animationHasF[l3] === 1) {
                        j5 += 15;
                    } else if (l2 === 4 && i2 === 1) {
                        k4 = -22;
                        i5 = -3;
                        j5 = i2 * 3 + this.npcWalkModel[(2 + ((character.stepCount / 6) | 0)) % 4];
                    } else if (l2 === 4 && i2 === 2) {
                        k4 = 0;
                        i5 = -8;
                        j5 = i2 * 3 + this.npcWalkModel[(2 + ((character.stepCount / 6) | 0)) % 4];
                    } else if (l2 === 4 && i2 === 3) {
                        k4 = 26;
                        i5 = -5;
                        j5 = i2 * 3 + this.npcWalkModel[(2 + ((character.stepCount / 6) | 0)) % 4];
                    } else if (l2 === 3 && i2 === 1) {
                        k4 = 22;
                        i5 = 3;
                        j5 = i2 * 3 + this.npcWalkModel[(2 + ((character.stepCount / 6) | 0)) % 4];
                    } else if (l2 === 3 && i2 === 2) {
                        k4 = 0;
                        i5 = 8;
                        j5 = i2 * 3 + this.npcWalkModel[(2 + ((character.stepCount / 6) | 0)) % 4];
                    } else if (l2 === 3 && i2 === 3) {
                        k4 = -26;
                        i5 = 5;
                        j5 = i2 * 3 + this.npcWalkModel[(2 + ((character.stepCount / 6) | 0)) % 4];
                    }
                }

                if (i2 !== 5 || GameData.animationHasA[l3] === 1) {
                    let k5 = j5 + GameData.animationNumber[l3];

                    k4 = ((k4 * w) / this.surface.spriteWidthFull[k5]) | 0;
                    i5 = ((i5 * h) / this.surface.spriteHeightFull[k5]) | 0;

                    let l5 = ((w * this.surface.spriteWidthFull[k5]) / this.surface.spriteWidthFull[GameData.animationNumber[l3]]) | 0;

                    k4 -= ((l5 - w) / 2) | 0;

                    let i6 = GameData.animationCharacterColour[l3];
                    const skinColour =
                        this.characterSkinColours[character.colourSkin];

                    if (i6 === 1) {
                        i6 = this.characterHairColours[character.colourHair];
                    } else if (i6 === 2) {
                        i6 = this.characterTopBottomColours[character.colourTop];
                    } else if (i6 === 3) {
                        i6 = this.characterTopBottomColours[character.colourBottom];
                    }

                    this.surface._spriteClipping_from9(x + k4, y + i5, l5, h, k5, i6, skinColour, tx, flag);
                }
            }
        }

        if (character.messageTimeout > 0) {
            this.receivedMessageMidPoint[this.receivedMessagesCount] = (this.surface.textWidth(character.message, 1) / 2) | 0;

            if (this.receivedMessageMidPoint[this.receivedMessagesCount] > 150) {
                this.receivedMessageMidPoint[this.receivedMessagesCount] = 150;
            }

            this.receivedMessageHeight[this.receivedMessagesCount] = ((this.surface.textWidth(character.message, 1) / 300) | 0) * this.surface.textHeight(1);
            this.receivedMessageX[this.receivedMessagesCount] = x + ((w / 2) | 0);
            this.receivedMessageY[this.receivedMessagesCount] = y;
            this.receivedMessages[this.receivedMessagesCount++] = character.message;
        }

        if (character.bubbleTimeout > 0) {
            this.actionBubbleX[this.itemsAboveHeadCount] = x + ((w / 2) | 0);
            this.actionBubbleY[this.itemsAboveHeadCount] = y;
            this.actionBubbleScale[this.itemsAboveHeadCount] = ty;
            this.actionBubbleItem[this.itemsAboveHeadCount++] = character.bubbleItem;
        }

        if (character.animationCurrent === 8 || character.animationCurrent === 9 || character.combatTimer !== 0) {
            if (character.combatTimer > 0) {
                let i3 = x;

                if (character.animationCurrent === 8) {
                    i3 -= ((20 * ty) / 100) | 0;
                } else if (character.animationCurrent === 9) {
                    i3 += ((20 * ty) / 100) | 0;
                }

                let i4 = ((character.healthCurrent * 30) / character.healthMax) | 0;

                this.healthBarX[this.healthBarCount] = i3 + ((w / 2) | 0);
                this.healthBarY[this.healthBarCount] = y;
                this.healthBarMissing[this.healthBarCount++] = i4;
            }

            if (character.combatTimer > 150) {
                let j3 = x;

                if (character.animationCurrent === 8) {
                    j3 -= ((10 * ty) / 100) | 0;
                } else if (character.animationCurrent === 9) {
                    j3 += ((10 * ty) / 100) | 0;
                }

                this.surface._drawSprite_from3((j3 + ((w / 2) | 0)) - 12, (y + ((h / 2) | 0)) - 12, this.spriteMedia + 11);
                this.surface.drawStringCenter(character.damageTaken.toString(), (j3 + ((w / 2) | 0)) - 1, y + ((h / 2) | 0) + 5, 3, 0xffffff);
            }
        }

        if (character.skullVisible === 1 && character.bubbleTimeout === 0) {
            let k3 = tx + x + ((w / 2) | 0);

            if (character.animationCurrent === 8) {
                k3 -= ((20 * ty) / 100) | 0;
            } else if (character.animationCurrent === 9) {
                k3 += ((20 * ty) / 100) | 0;
            }

            let j4 = ((16 * ty) / 100) | 0;
            let l4 = ((16 * ty) / 100) | 0;

            this.surface._spriteClipping_from5(k3 - ((j4 / 2) | 0), y - ((l4 / 2) | 0) - (((10 * ty) / 100) | 0), j4, l4, this.spriteMedia + 13);
        }
    }

    async loadMedia() {
        const mediaJag = await this.readDataFile(
            `media${version.MEDIA}.jag`,
            '2d graphics',
            20
        );

        if (mediaJag === null) {
            this.errorLoadingData = true;
            return;
        }

        const indexDat = Utility.loadData('index.dat', 0, mediaJag);

        this.surface.parseSprite(this.spriteMedia, Utility.loadData('inv1.dat', 0, mediaJag), indexDat, 1);
        this.surface.parseSprite(this.spriteMedia + 1, Utility.loadData('inv2.dat', 0, mediaJag), indexDat, 6);
        this.surface.parseSprite(this.spriteMedia + 9, Utility.loadData('bubble.dat', 0, mediaJag), indexDat, 1);
        this.surface.parseSprite(this.spriteMedia + 10, Utility.loadData('runescape.dat', 0, mediaJag), indexDat, 1);
        this.surface.parseSprite(this.spriteMedia + 11, Utility.loadData('splat.dat', 0, mediaJag), indexDat, 3);
        this.surface.parseSprite(this.spriteMedia + 14, Utility.loadData('icon.dat', 0, mediaJag), indexDat, 8);
        this.surface.parseSprite(this.spriteMedia + 22, Utility.loadData('hbar.dat', 0, mediaJag), indexDat, 1);
        this.surface.parseSprite(this.spriteMedia + 23, Utility.loadData('hbar2.dat', 0, mediaJag), indexDat, 1);
        this.surface.parseSprite(this.spriteMedia + 24, Utility.loadData('compass.dat', 0, mediaJag), indexDat, 1);
        this.surface.parseSprite(this.spriteMedia + 25, Utility.loadData('buttons.dat', 0, mediaJag), indexDat, 2);
        this.surface.parseSprite(this.spriteUtil, Utility.loadData('scrollbar.dat', 0, mediaJag), indexDat, 2);
        this.surface.parseSprite(this.spriteUtil + 2, Utility.loadData('corners.dat', 0, mediaJag), indexDat, 4);
        this.surface.parseSprite(this.spriteUtil + 6, Utility.loadData('arrows.dat', 0, mediaJag), indexDat, 2);
        this.surface.parseSprite(this.spriteProjectile, Utility.loadData('projectile.dat', 0, mediaJag), indexDat, GameData.projectileSprite);

        let spriteCount = GameData.itemSpriteCount;

        for (let i = 1; spriteCount > 0; i++) {
            let currentSpriteCount = spriteCount;
            spriteCount -= 30;

            if (currentSpriteCount > 30) {
                currentSpriteCount = 30;
            }

            this.surface.parseSprite(
                this.spriteItem + (i - 1) * 30,
                Utility.loadData(`objects${i}.dat`, 0, mediaJag),
                indexDat,
                currentSpriteCount
            );
        }

        this.surface.loadSprite(this.spriteMedia);
        this.surface.loadSprite(this.spriteMedia + 9);

        for (let i = 11; i <= 26; i++) {
            this.surface.loadSprite(this.spriteMedia + i);
        }

        for (let i = 0; i < GameData.projectileSprite; i++) {
            this.surface.loadSprite(this.spriteProjectile + i);
        }

        for (let i = 0; i < GameData.itemSpriteCount; i++) {
            this.surface.loadSprite(this.spriteItem + i);
        }
    }

    drawChatMessageTabs() {
        this.surface._drawSprite_from3(0, this.gameHeight - 4, this.spriteMedia + 23);

        let colour = Surface.rgbToInt(200, 200, 255);

        if (this.messageTabSelected === 0) {
            colour = Surface.rgbToInt(255, 200, 50);
        }

        if (this.messageTabFlashAll % 30 > 15) {
            colour = Surface.rgbToInt(255, 50, 50);
        }

        this.surface.drawStringCenter('All messages', 54, this.gameHeight + 6, 0, colour);
        colour = Surface.rgbToInt(200, 200, 255);

        if (this.messageTabSelected === 1) {
            colour = Surface.rgbToInt(255, 200, 50);
        }

        if (this.messageTabFlashHistory % 30 > 15) {
            colour = Surface.rgbToInt(255, 50, 50);
        }

        this.surface.drawStringCenter('Chat history', 155, this.gameHeight + 6, 0, colour);
        colour = Surface.rgbToInt(200, 200, 255);

        if (this.messageTabSelected === 2) {
            colour = Surface.rgbToInt(255, 200, 50);
        }

        if (this.messageTabFlashQuest % 30 > 15) {
            colour = Surface.rgbToInt(255, 50, 50);
        }

        this.surface.drawStringCenter('Quest history', 255, this.gameHeight + 6, 0, colour);
        colour = Surface.rgbToInt(200, 200, 255);

        if (this.messageTabSelected === 3) {
            colour = Surface.rgbToInt(255, 200, 50);
        }

        if (this.messageTabFlashPrivate % 30 > 15) {
            colour = Surface.rgbToInt(255, 50, 50);
        }

        this.surface.drawStringCenter('Private history', 355, this.gameHeight + 6, 0, colour);
        this.surface.drawStringCenter('Report abuse', 457, this.gameHeight + 6, 0, 0xffffff);
    }

    async startGame() {
        this.port = this.port || 43595;
        this.maxReadTries = 1000;
        GameConnection.clientVersion = version.CLIENT;

        await this.loadGameConfig();

        if (this.errorLoadingData) {
            return;
        }

        this.spriteMedia = 2000;
        this.spriteUtil = this.spriteMedia + 100;
        this.spriteItem = this.spriteUtil + 50;
        this.spriteLogo = this.spriteItem + 1000;
        this.spriteProjectile = this.spriteLogo + 10;
        this.spriteTexture = this.spriteProjectile + 50;
        this.spriteTextureWorld = this.spriteTexture + 10;

        this.graphics = this.getGraphics();

        this.setTargetFps(50);

        this.surface = new Surface(this.gameWidth, this.gameHeight + 12, 4000,
            this);
        this.surface.mudclientref = this;
        this.surface.setBounds(0, 0, this.gameWidth, this.gameHeight + 12);

        Panel.drawBackgroundArrow = false;
        Panel.baseSpriteStart = this.spriteUtil;

        this.panelMagic = new Panel(this.surface, 5);

        let x = this.surface.width2 - 199;
        let y = 36;

        this.controlListMagic = this.panelMagic.addTextListInteractive(x, y + 24, 196, 90, 1, 500, true);
        this.panelSocialList = new Panel(this.surface, 5);
        this.controlListSocialPlayers = this.panelSocialList.addTextListInteractive(x, y + 40, 196, 126, 1, 500, true);
        this.panelQuestList = new Panel(this.surface, 5);
        this.controlListQuest = this.panelQuestList.addTextListInteractive(x, y + 24, 196, 251, 1, 500, true);

        await this.loadMedia();

        if (this.errorLoadingData) {
            return;
        }

        await this.loadEntities();

        if (this.errorLoadingData) {
            return;
        }

        this.scene = new Scene(this.surface, 15000, 15000, 1000);
        this.scene.view = GameModel._from2(1000 * 1000, 1000);

        this.scene.setBounds((this.gameWidth / 2) | 0, (this.gameHeight / 2) | 0, (this.gameWidth / 2) | 0, (this.gameHeight / 2) | 0, this.gameWidth, this.const_9);
        this.scene.clipFar3d = 2400;
        this.scene.clipFar2d = 2400;
        this.scene.fogZFalloff = 1;
        this.scene.fogZDistance = 2300;
        this.scene._setLight_from3(-50, -10, -50);
        this.world = new World(this.scene, this.surface);
        this.world.baseMediaSprite = this.spriteMedia;

        await this.loadTextures();

        if (this.errorLoadingData) {
            return;
        }

        await this.loadModels();

        if (this.errorLoadingData) {
            return;
        }

        await this.loadMaps();

        if (this.errorLoadingData) {
            return;
        }

        if (this.members) {
            await this.loadSounds();
        }

        if (!this.errorLoadingData) {
            this.showLoadingProgress(100, 'Starting game...');
            this.createMessageTabPanel();
            this.createLoginPanels();
            this.createAppearancePanel();
            this.resetLoginScreenVariables();
            this.renderLoginScreenViewports();
        }
    }

    hasInventoryItems(id, mincount) {
        if (id === 31 && (this.isItemEquipped(197) || this.isItemEquipped(615) || this.isItemEquipped(682))) {
            return true;
        }

        if (id === 32 && (this.isItemEquipped(102) || this.isItemEquipped(616) || this.isItemEquipped(683))) {
            return true;
        }

        if (id === 33 && (this.isItemEquipped(101) || this.isItemEquipped(617) || this.isItemEquipped(684))) {
            return true;
        }

        if (id === 34 && (this.isItemEquipped(103) || this.isItemEquipped(618) || this.isItemEquipped(685))) {
            return true;
        }

        return this.getInventoryCount(id) >= mincount;
    }

    getHostnameIP(i) {
        return Utility.ipToString(i);
    }

    cantLogout() {
        this.logoutTimeout = 0;
        this.showMessage('@cya@Sorry, you can\'t logout at the moment', 3);
    }

    drawGame() {
        if (this.deathScreenTimeout !== 0) {
            this.surface.fadeToBlack();
            this.surface.drawStringCenter('Oh dear! You are dead...', (this.gameWidth / 2) | 0, (this.gameHeight / 2) | 0, 7, 0xff0000);
            this.drawChatMessageTabs();
            this.surface.draw(this.graphics, 0, 0);

            return;
        }

        if (this.showAppearanceChange) {
            this.drawAppearancePanelCharacterSprites();
            return;
        }

        if (this.isSleeping) {
            this.drawSleep();
            return;
        }

        if (!this.world.playerAlive) {
            return;
        }

        for (let i = 0; i < 64; i++) {
            this.scene.removeModel(this.world.roofModels[this.lastHeightOffset][i]);

            if (this.lastHeightOffset === 0) {
                this.scene.removeModel(this.world.wallModels[1][i]);
                this.scene.removeModel(this.world.roofModels[1][i]);
                this.scene.removeModel(this.world.wallModels[2][i]);
                this.scene.removeModel(this.world.roofModels[2][i]);
            }

            if (this.options.showRoofs) {
                this.fogOfWar = true;

                if (this.lastHeightOffset === 0 && (this.world.objectAdjacency.get((this.localPlayer.currentX / 128) | 0, (this.localPlayer.currentY / 128) | 0) & 128) === 0) {
                    this.scene.addModel(this.world.roofModels[this.lastHeightOffset][i]);

                    if (this.lastHeightOffset === 0) {
                        this.scene.addModel(this.world.wallModels[1][i]);
                        this.scene.addModel(this.world.roofModels[1][i]);
                        this.scene.addModel(this.world.wallModels[2][i]);
                        this.scene.addModel(this.world.roofModels[2][i]);
                    }

                    this.fogOfWar = false;
                }
            }
        }

        if (this.objectAnimationNumberFireLightningSpell !== this.lastObjectAnimationNumberFireLightningSpell) {
            this.lastObjectAnimationNumberFireLightningSpell = this.objectAnimationNumberFireLightningSpell;

            for (let i = 0; i < this.objectCount; i++) {
                if (this.objectId[i] === 97) {
                    this.updateObjectAnimation(i, 'firea' + (this.objectAnimationNumberFireLightningSpell + 1));
                }

                if (this.objectId[i] === 274) {
                    this.updateObjectAnimation(i, 'fireplacea' + (this.objectAnimationNumberFireLightningSpell + 1));
                }

                if (this.objectId[i] === 1031) {
                    this.updateObjectAnimation(i, 'lightning' + (this.objectAnimationNumberFireLightningSpell + 1));
                }

                if (this.objectId[i] === 1036) {
                    this.updateObjectAnimation(i, 'firespell' + (this.objectAnimationNumberFireLightningSpell + 1));
                }

                if (this.objectId[i] === 1147) {
                    this.updateObjectAnimation(i, 'spellcharge' + (this.objectAnimationNumberFireLightningSpell + 1));
                }
            }
        }

        if (this.objectAnimationNumberTorch !== this.lastObjectAnimationNumberTorch) {
            this.lastObjectAnimationNumberTorch = this.objectAnimationNumberTorch;

            for (let i = 0; i < this.objectCount; i++) {
                if (this.objectId[i] === 51) {
                    this.updateObjectAnimation(i, 'torcha' + (this.objectAnimationNumberTorch + 1));
                }

                if (this.objectId[i] === 143) {
                    this.updateObjectAnimation(i, 'skulltorcha' + (this.objectAnimationNumberTorch + 1));
                }
            }
        }

        if (this.objectAnimationNumberClaw !== this.lastObjectAnimationNumberClaw) {
            this.lastObjectAnimationNumberClaw = this.objectAnimationNumberClaw;

            for (let i = 0; i < this.objectCount; i++) {
                if (this.objectId[i] === 1142) {
                    this.updateObjectAnimation(i, 'clawspell' + (this.objectAnimationNumberClaw + 1));
                }
            }

        }

        this.scene.reduceSprites(this.spriteCount);
        this.spriteCount = 0;

        for (let i = 0; i < this.playerCount; i++) {
            const player = this.players[i];

            if (player.colourBottom !== 255) {
                const x = player.currentX;
                const y = player.currentY;
                const elevation = -this.world.getElevation(x, y);
                const id = this.scene.addSprite(5000 + i, x, elevation, y, 145, 220, i + 10000);

                this.spriteCount++;

                if (player === this.localPlayer) {
                    this.scene.setLocalPlayer(id);
                }

                if (player.animationCurrent === 8) {
                    this.scene.setSpriteTranslateX(id, -30);
                }

                if (player.animationCurrent === 9) {
                    this.scene.setSpriteTranslateX(id, 30);
                }
            }
        }

        for (let i = 0; i < this.playerCount; i++) {
            const player = this.players[i];

            if (player.projectileRange > 0) {
                let character = null;

                if (player.attackingNpcServerIndex !== -1) {
                    character = this.npcsServer[player.attackingNpcServerIndex];
                } else if (player.attackingPlayerServerIndex !== -1) {
                    character = this.playerServer[player.attackingPlayerServerIndex];
                }

                if (character !== null) {
                    const sx = player.currentX;
                    const sy = player.currentY;
                    const selev = -this.world.getElevation(sx, sy) - 110;
                    const dx = character.currentX;
                    const dy = character.currentY;
                    const delev = -((this.world.getElevation(dx, dy) - GameData.npcHeight[character.npcId] / 2) | 0);
                    const rx = ((sx * player.projectileRange + dx * (this.projectileMaxRange - player.projectileRange)) / this.projectileMaxRange) | 0;
                    const rz = ((selev * player.projectileRange + delev * (this.projectileMaxRange - player.projectileRange)) / this.projectileMaxRange) | 0;
                    const ry = ((sy * player.projectileRange + dy * (this.projectileMaxRange - player.projectileRange)) / this.projectileMaxRange) | 0;

                    this.scene.addSprite(this.spriteProjectile + player.incomingProjectileSprite, rx, rz, ry, 32, 32, 0);
                    this.spriteCount++;
                }
            }
        }

        for (let i = 0; i < this.npcCount; i++) {
            const npc = this.npcs[i];
            const i3 = npc.currentX;
            const j4 = npc.currentY;
            const i7 = -this.world.getElevation(i3, j4);
            const i9 = this.scene.addSprite(20000 + i, i3, i7, j4, GameData.npcWidth[npc.npcId], GameData.npcHeight[npc.npcId], i + 30000);

            this.spriteCount++;

            if (npc.animationCurrent === 8) {
                this.scene.setSpriteTranslateX(i9, -30);
            }

            if (npc.animationCurrent === 9) {
                this.scene.setSpriteTranslateX(i9, 30);
            }
        }

        for (let i = 0; i < this.groundItemCount; i++) {
            const x = this.groundItemX[i] * this.magicLoc + 64;
            const y = this.groundItemY[i] * this.magicLoc + 64;

            this.scene.addSprite(40000 + this.groundItemID[i], x, -this.world.getElevation(x, y) - this.groundItemZ[i], y, 96, 64, i + 20000);
            this.spriteCount++;
        }

        for (let i = 0; i < this.teleportBubbleCount; i++) {
            const x = this.teleportBubbleX[i] * this.magicLoc + 64;
            const y = this.teleportBubbleY[i] * this.magicLoc + 64;
            const type = this.teleportBubbleType[i];

            if (type === 0) {
                this.scene.addSprite(50000 + i, x, -this.world.getElevation(x, y), y, 128, 256, i + 50000);
                this.spriteCount++;
            }

            if (type === 1) {
                this.scene.addSprite(50000 + i, x, -this.world.getElevation(x, y), y, 128, 64, i + 50000);
                this.spriteCount++;
            }
        }

        this.surface.interlace = false;
        this.surface.blackScreen();
        this.surface.interlace = this.interlace;

        if (this.lastHeightOffset === 3) {
            const i5 = 40 + ((Math.random() * 3) | 0);
            const k7 = 40 + ((Math.random() * 7) | 0);

            this.scene._setLight_from5(i5, k7, -50, -10, -50);
        }

        this.itemsAboveHeadCount = 0;
        this.receivedMessagesCount = 0;
        this.healthBarCount = 0;

        if (this.cameraAutoAngleDebug) {
            if (this.optionCameraModeAuto && !this.fogOfWar) {
                const oldAngle = this.cameraAngle;

                this.autoRotateCamera();

                if (this.cameraAngle !== oldAngle) {
                    this.cameraAutoRotatePlayerX = this.localPlayer.currentX;
                    this.cameraAutoRotatePlayerY = this.localPlayer.currentY;
                }
            }

            this.scene.clipFar3d = 3000;
            this.scene.clipFar2d = 3000;
            this.scene.fogZFalloff = 1;
            this.scene.fogZDistance = 2800;
            this.cameraRotation = this.cameraAngle * 32;

            const x = this.cameraAutoRotatePlayerX + this.cameraRotationX;
            const y = this.cameraAutoRotatePlayerY + this.cameraRotationY;

            this.scene.setCamera(x, -this.world.getElevation(x, y), y, 912, this.cameraRotation * 4, 0, 2000);
        } else {
            if (this.optionCameraModeAuto && !this.fogOfWar) {
                this.autoRotateCamera();
            }

            if (!this.interlace) {
                this.scene.clipFar3d = 2400;
                this.scene.clipFar2d = 2400;
                this.scene.fogZFalloff = 1;
                this.scene.fogZDistance = 2300;
            } else {
                this.scene.clipFar3d = 2200;
                this.scene.clipFar2d = 2200;
                this.scene.fogZFalloff = 1;
                this.scene.fogZDistance = 2100;
            }

            if (this.cameraZoom > ZOOM_OUTDOORS) {
                this.scene.clipFar3d += 1400;
                this.scene.clipFar2d += 1400;
                this.scene.fogZDistance += 1400;
            }

            let x = this.cameraAutoRotatePlayerX + this.cameraRotationX;
            let y = this.cameraAutoRotatePlayerY + this.cameraRotationY;

            this.scene.setCamera(x, -this.world.getElevation(x, y), y, 912, this.cameraRotation * 4, 0, this.cameraZoom * 2);
        }

        this.scene.render();
        this.drawAboveHeadStuff();

        if (this.mouseClickXStep > 0) {
            this.surface._drawSprite_from3(this.mouseClickXX - 8, this.mouseClickXY - 8, this.spriteMedia + 14 + (((24 - this.mouseClickXStep) / 6) | 0));
        }

        if (this.mouseClickXStep < 0) {
            this.surface._drawSprite_from3(this.mouseClickXX - 8, this.mouseClickXY - 8, this.spriteMedia + 18 + (((24 + this.mouseClickXStep) / 6) | 0));
        }

        // retro fps counter
        if (this.options.retroFPSCounter) {
            // how much the wilderness skull needs to move for the fps counter
            const offset = this.isInWild ? 70 : 0;

            this.surface.drawString(
                'Fps: ' + (this.fps | 0),
                this.gameWidth - 62 - offset,
                this.gameHeight - 10,
                1,
                0xffff00
            );
        }

        if (this.systemUpdate !== 0) {
            let seconds = ((this.systemUpdate / 50) | 0);
            const minutes = (seconds / 60) | 0;

            seconds %= 60;

            if (seconds < 10) {
                this.surface.drawStringCenter('System update in: ' + minutes + ':0' + seconds, 256, this.gameHeight - 7, 1, 0xffff00);
            } else {
                this.surface.drawStringCenter('System update in: ' + minutes + ':' + seconds, 256, this.gameHeight - 7, 1, 0xffff00);
            }
        }

        if (!this.loadingArea) {
            let j6 = 2203 - (this.localRegionY + this.planeHeight + this.regionY);

            if (this.localRegionX + this.planeWidth + this.regionX >= 2640) {
                j6 = -50;
            }

            this.isInWild = j6 > 0;

            if (this.isInWild) {
                let wildlvl = 1 + ((j6 / 6) | 0);

                // wilderness skull placement made independent of gameWidth
                this.surface._drawSprite_from3(this.gameWidth - 59, this.gameHeight - 56, this.spriteMedia + 13);
                this.surface.drawStringCenter('Wilderness', this.gameWidth - 47, this.gameHeight - 20, 1, 0xffff00);
                this.surface.drawStringCenter('Level: ' + wildlvl, this.gameWidth - 47, this.gameHeight - 7, 1, 0xffff00);

                if (this.showUiWildWarn === 0) {
                    this.showUiWildWarn = 2;
                }
            }

            if (this.showUiWildWarn === 0 && j6 > -10 && j6 <= 0) {
                this.showUiWildWarn = 1;
            }
        }

        if (this.messageTabSelected === 0) {
            for (let k6 = 0; k6 < 5; k6++) {
                if (this.messageHistoryTimeout[k6] > 0) {
                    let s = this.messageHistory[k6];
                    this.surface.drawString(s, 7, this.gameHeight - 18 - k6 * 12, 1, 0xffff00);
                }
            }
        }

        this.panelMessageTabs.hide(this.controlTextListChat);
        this.panelMessageTabs.hide(this.controlTextListQuest);
        this.panelMessageTabs.hide(this.controlTextListPrivate);

        if (this.messageTabSelected === 1) {
            this.panelMessageTabs.show(this.controlTextListChat);
        } else if (this.messageTabSelected === 2) {
            this.panelMessageTabs.show(this.controlTextListQuest);
        } else if (this.messageTabSelected === 3) {
            this.panelMessageTabs.show(this.controlTextListPrivate);
        }

        Panel.textListEntryHeightMod = 2;
        this.panelMessageTabs.drawPanel();
        Panel.textListEntryHeightMod = 0;
        this.surface._drawSpriteAlpha_from4(this.surface.width2 - 3 - 197, 3, this.spriteMedia, 128);
        this.drawUi();
        this.surface.loggedIn = false;
        this.drawChatMessageTabs();
        this.surface.draw(this.graphics, 0, 0);
    }

    async loadSounds() {
        try {
            this.soundData = await this.readDataFile(
                `sounds${version.SOUNDS}.mem`,
                'Sound effects',
                90
            );

            this.audioPlayer = new StreamAudioPlayer();
        } catch (e) {
            console.error(e);
        }
    }

    isItemEquipped(id) {
        for (let i = 0; i < this.inventoryItemsCount; i++) {
            if (
                this.inventoryItemId[i] === id &&
                this.inventoryEquipped[i] === 1
            ) {
                return true;
            }
        }

        return false;
    }

    async loadEntities() {
        const entityJag = await this.readDataFile(
            `entity${version.ENTITY}.jag`,
            'people and monsters',
            30
        );

        if (!entityJag) {
            this.errorLoadingData = true;
            return;
        }

        const indexDat = Utility.loadData('index.dat', 0, entityJag);

        let entityJagMem = null;
        let indexDatMem = null;

        if (this.members) {
            entityJagMem = await this.readDataFile('entity' + version.ENTITY + '.mem', 'member graphics', 45);

            if (!entityJagMem) {
                this.errorLoadingData = true;
                return;
            }

            indexDatMem = Utility.loadData('index.dat', 0, entityJagMem);
        }

        let frameCount = 0;
        this.animationIndex = 0;

        label0:
        for (let j = 0; j < GameData.animationCount; j++) {
            let animationName = GameData.animationName[j];

            for (let k = 0; k < j; k++) {
                if (GameData.animationName[k].toLowerCase() !== animationName.toLowerCase()) {
                    continue;
                }

                GameData.animationNumber[j] = GameData.animationNumber[k];
                continue label0;
            }

            let animationDat = Utility.loadData(animationName + '.dat', 0, entityJag);
            let animationIndex = indexDat;

            if (animationDat === null && this.members) {
                animationDat = Utility.loadData(animationName + '.dat', 0, entityJagMem);
                animationIndex = indexDatMem;
            }

            if (animationDat !== null) {
                this.surface.parseSprite(this.animationIndex, animationDat, animationIndex, 15);

                frameCount += 15;

                if (GameData.animationHasA[j] === 1) {
                    let aDat = Utility.loadData(animationName + 'a.dat', 0, entityJag);
                    let aIndex = indexDat;

                    if (aDat === null && this.members) {
                        aDat = Utility.loadData(animationName + 'a.dat', 0, entityJagMem);
                        aIndex = indexDatMem;
                    }

                    this.surface.parseSprite(this.animationIndex + 15, aDat, aIndex, 3);
                    frameCount += 3;
                }

                if (GameData.animationHasF[j] === 1) {
                    let fDat = Utility.loadData(animationName + 'f.dat', 0, entityJag);
                    let fIndex = indexDat;

                    if (fDat === null && this.members) {
                        fDat = Utility.loadData(animationName + 'f.dat', 0, entityJagMem);
                        fIndex = indexDatMem;
                    }

                    this.surface.parseSprite(this.animationIndex + 18, fDat, fIndex, 9);
                    frameCount += 9;
                }

                if (GameData.animationGender[j] !== 0) {
                    for (let l = this.animationIndex; l < this.animationIndex + 27; l++) {
                        this.surface.loadSprite(l);
                    }
                }
            }

            GameData.animationNumber[j] = this.animationIndex;
            this.animationIndex += 27;
        }

        console.log('Loaded: ' + frameCount + ' frames of animation');
    }

    draw() {
        if (this.errorLoadingData) {
            const g = this.getGraphics();

            g.setColor(Color.black);
            g.fillRect(0, 0, 512, 356);
            g.setFont(new Font('Helvetica', 1, 16));
            g.setColor(Color.yellow);

            let y = 35;

            g.drawString('Sorry, an error has occured whilst loading RuneScape', 30, y);
            y += 50;
            g.setColor(Color.white);
            g.drawString('To fix this try the following (in order):', 30, y);
            y += 50;
            g.setColor(Color.white);
            g.setFont(new Font('Helvetica', 1, 12));
            g.drawString('1: Try closing ALL open web-browser windows, and reloading', 30, y);
            y += 30;
            g.drawString('2: Try clearing your web-browsers cache from tools->internet options', 30, y);
            y += 30;
            g.drawString('3: Try using a different game-world', 30, y);
            y += 30;
            g.drawString('4: Try rebooting your computer', 30, y);
            y += 30;
            g.drawString('5: Try selecting a different version of Java from the play-game menu', 30, y);

            this.setTargetFps(1);

            return;
        }

        if (this.errorLoadingCodebase) {
            const g = this.getGraphics();

            g.setColor(Color.black);
            g.fillRect(0, 0, 512, 356);
            g.setFont(new Font('Helvetica', 1, 20));
            g.setColor(Color.white);
            g.drawString('Error - unable to load game!', 50, 50);
            g.drawString('To play RuneScape make sure you play from', 50, 100);
            g.drawString('http://www.runescape.com', 50, 150);

            this.setTargetFps(1);

            return;
        }

        if (this.errorLoadingMemory) {
            const g = this.getGraphics();

            g.setColor(Color.black);
            g.fillRect(0, 0, 512, 356);
            g.setFont(new Font('Helvetica', 1, 20));
            g.setColor(Color.white);
            g.drawString('Error - out of memory!', 50, 50);
            g.drawString('Close ALL unnecessary programs', 50, 100);
            g.drawString('and windows before loading the game', 50, 150);
            g.drawString('RuneScape needs about 48meg of spare RAM', 50, 200);

            this.setTargetFps(1);

            return;
        }

        try {
            if (this.loggedIn === 0) {
                this.surface.loggedIn = false;
                this.drawLoginScreens();
            } else if (this.loggedIn === 1) {
                this.surface.loggedIn = true;
                this.drawGame();
            }
        } catch (e) {
            // OutOfMemory
            console.error(e);
            this.disposeAndCollect();
            this.errorLoadingMemory = true;
        }
    }

    onClosing() {
        this.closeConnection();
        this.disposeAndCollect();

        if (this.audioPlayer) {
            this.audioPlayer.stopPlayer();
        }
    }

    drawDialogDuelConfirm() {
        let dialogX = 22;
        let dialogY = 36;

        this.surface.drawBox(dialogX, dialogY, 468, 16, 192);
        this.surface.drawBoxAlpha(dialogX, dialogY + 16, 468, 246, 0x989898, 160);
        this.surface.drawStringCenter('Please confirm your duel with @yel@' + Utility.hashToUsername(this.duelOpponentNameHash), dialogX + 234, dialogY + 12, 1, 0xffffff);
        this.surface.drawStringCenter('Your stake:', dialogX + 117, dialogY + 30, 1, 0xffff00);

        for (let itemIndex = 0; itemIndex < this.duelItemsCount; itemIndex++) {
            let s = GameData.itemName[this.duelItems[itemIndex]];

            if (GameData.itemStackable[this.duelItems[itemIndex]] === 0) {
                s = s + ' x ' + Utility.formatConfirmAmount(this.duelItemCount[itemIndex]);
            }

            this.surface.drawStringCenter(s, dialogX + 117, dialogY + 42 + itemIndex * 12, 1, 0xffffff);
        }

        if (this.duelItemsCount === 0) {
            this.surface.drawStringCenter('Nothing!', dialogX + 117, dialogY + 42, 1, 0xffffff);
        }

        this.surface.drawStringCenter('Your opponent\'s stake:', dialogX + 351, dialogY + 30, 1, 0xffff00);

        for (let itemIndex = 0; itemIndex < this.duelOpponentItemsCount; itemIndex++) {
            let s1 = GameData.itemName[this.duelOpponentItems[itemIndex]];

            if (GameData.itemStackable[this.duelOpponentItems[itemIndex]] === 0) {
                s1 = s1 + ' x ' + Utility.formatConfirmAmount(this.duelOpponentItemCount[itemIndex]);
            }

            this.surface.drawStringCenter(s1, dialogX + 351, dialogY + 42 + itemIndex * 12, 1, 0xffffff);
        }

        if (this.duelOpponentItemsCount === 0) {
            this.surface.drawStringCenter('Nothing!', dialogX + 351, dialogY + 42, 1, 0xffffff);
        }

        if (this.duelOptionRetreat === 0) {
            this.surface.drawStringCenter('You can retreat from this duel', dialogX + 234, dialogY + 180, 1, 65280);
        } else {
            this.surface.drawStringCenter('No retreat is possible!', dialogX + 234, dialogY + 180, 1, 0xff0000);
        }

        if (this.duelOptionMagic === 0) {
            this.surface.drawStringCenter('Magic may be used', dialogX + 234, dialogY + 192, 1, 65280);
        } else {
            this.surface.drawStringCenter('Magic cannot be used', dialogX + 234, dialogY + 192, 1, 0xff0000);
        }

        if (this.duelOptionPrayer === 0) {
            this.surface.drawStringCenter('Prayer may be used', dialogX + 234, dialogY + 204, 1, 65280);
        } else {
            this.surface.drawStringCenter('Prayer cannot be used', dialogX + 234, dialogY + 204, 1, 0xff0000);
        }

        if (this.duelOptionWeapons === 0) {
            this.surface.drawStringCenter('Weapons may be used', dialogX + 234, dialogY + 216, 1, 65280);
        } else {
            this.surface.drawStringCenter('Weapons cannot be used', dialogX + 234, dialogY + 216, 1, 0xff0000);
        }

        this.surface.drawStringCenter('If you are sure click \'Accept\' to begin the duel', dialogX + 234, dialogY + 230, 1, 0xffffff);

        if (!this.duelAccepted) {
            this.surface._drawSprite_from3((dialogX + 118) - 35, dialogY + 238, this.spriteMedia + 25);
            this.surface._drawSprite_from3((dialogX + 352) - 35, dialogY + 238, this.spriteMedia + 26);
        } else {
            this.surface.drawStringCenter('Waiting for other player...', dialogX + 234, dialogY + 250, 1, 0xffff00);
        }

        if (this.mouseButtonClick === 1) {
            if (this.mouseX < dialogX || this.mouseY < dialogY || this.mouseX > dialogX + 468 || this.mouseY > dialogY + 262) {
                this.showDialogDuelConfirm = false;
                this.packetStream.newPacket(clientOpcodes.TRADE_DECLINE);
                this.packetStream.sendPacket();
            }

            if (this.mouseX >= (dialogX + 118) - 35 && this.mouseX <= dialogX + 118 + 70 && this.mouseY >= dialogY + 238 && this.mouseY <= dialogY + 238 + 21) {
                this.duelAccepted = true;
                this.packetStream.newPacket(clientOpcodes.DUEL_CONFIRM_ACCEPT);
                this.packetStream.sendPacket();
            }

            if (this.mouseX >= (dialogX + 352) - 35 && this.mouseX <= dialogX + 353 + 70 && this.mouseY >= dialogY + 238 && this.mouseY <= dialogY + 238 + 21) {
                this.showDialogDuelConfirm = false;
                this.packetStream.newPacket(clientOpcodes.DUEL_DECLINE);
                this.packetStream.sendPacket();
            }

            this.mouseButtonClick = 0;
        }
    }

    walkToGroundItem(startX, startY, k, l, walkToAction) {
        if (this.walkTo(startX, startY, k, l, k, l, false, walkToAction)) {
            return;
        } else {
            this._walkToActionSource_from8(startX, startY, k, l, k, l, true, walkToAction);
            return;
        }
    }

    async loadModels() {
        for (const modelName of ANIMATED_MODELS) {
            GameData.getModelIndex(modelName);
        }

        const modelsJag = await this.readDataFile(
            `models${version.MODELS}.jag`,
            '3d models',
            60
        );

        if (!modelsJag) {
            this.errorLoadingData = true;
            return;
        }

        for (let i = 0; i < GameData.modelCount; i++) {
            const offset = Utility.getDataFileOffset(
                `${GameData.modelName[i]}.ob3`,
                modelsJag
            );

            if (offset !== 0) {
                this.gameModels[i] = GameModel.fromBytes(modelsJag, offset);
            } else {
                this.gameModels[i] = GameModel._from2(1, 1);
            }

            if (GameData.modelName[i].toLowerCase() === 'giantcrystal') {
                this.gameModels[i].transparent = true;
            }
        }
    }

    showMessage(message, type) {
        if (type === 2 || type === 4 || type === 6) {
            for (; message.length > 5 && message[0] === '@' && message[4] === '@'; message = message.substring(5)) ;

            let j = message.indexOf(':');

            if (j !== -1) {
                let s1 = message.substring(0, j);
                let l = Utility.usernameToHash(s1);

                for (let i1 = 0; i1 < this.ignoreListCount; i1++) {
                    if (this.ignoreList[i1].equals(l)) {
                        return;
                    }
                }
            }
        }

        if (type === 2) {
            message = '@yel@' + message;
        } else if (type === 3 || type === 4) {
            message = '@whi@' + message;
        } else if (type === 6) {
            message = '@cya@' + message;
        }

        if (this.messageTabSelected !== 0) {
            if (type === 4 || type === 3) {
                this.messageTabFlashAll = 200;
            }

            if (type === 2 && this.messageTabSelected !== 1) {
                this.messageTabFlashHistory = 200;
            }

            if (type === 5 && this.messageTabSelected !== 2) {
                this.messageTabFlashQuest = 200;
            }

            if (type === 6 && this.messageTabSelected !== 3) {
                this.messageTabFlashPrivate = 200;
            }

            if (type === 3 && this.messageTabSelected !== 0) {
                this.messageTabSelected = 0;
            }

            if (type === 6 && this.messageTabSelected !== 3 && this.messageTabSelected !== 0) {
                this.messageTabSelected = 0;
            }
        }

        for (let k = 4; k > 0; k--) {
            this.messageHistory[k] = this.messageHistory[k - 1];
            this.messageHistoryTimeout[k] = this.messageHistoryTimeout[k - 1];
        }

        this.messageHistory[0] = message;
        this.messageHistoryTimeout[0] = 300;

        if (type === 2) {
            if (this.panelMessageTabs.controlFlashText[this.controlTextListChat] === this.panelMessageTabs.controlListEntryCount[this.controlTextListChat] - 4) {
                this.panelMessageTabs.removeListEntry(this.controlTextListChat, message, true);
            } else {
                this.panelMessageTabs.removeListEntry(this.controlTextListChat, message, false);
            }
        } else if (type === 5) {
            if (this.panelMessageTabs.controlFlashText[this.controlTextListQuest] === this.panelMessageTabs.controlListEntryCount[this.controlTextListQuest] - 4) {
                this.panelMessageTabs.removeListEntry(this.controlTextListQuest, message, true);
            } else {
                this.panelMessageTabs.removeListEntry(this.controlTextListQuest, message, false);
            }
        } else if (type === 6) {
            if (this.panelMessageTabs.controlFlashText[this.controlTextListPrivate] === this.panelMessageTabs.controlListEntryCount[this.controlTextListPrivate] - 4) {
                this.panelMessageTabs.removeListEntry(this.controlTextListPrivate, message, true);
                return;
            }

            this.panelMessageTabs.removeListEntry(this.controlTextListPrivate, message, false);
        }
    }

    walkToObject(x, y, id, index) {
        let width = 0;
        let height = 0;

        if (id === 0 || id === 4) {
            width = GameData.objectWidth[index];
            height = GameData.objectHeight[index];
        } else {
            height = GameData.objectWidth[index];
            width = GameData.objectHeight[index];
        }

        if (GameData.objectType[index] === 2 || GameData.objectType[index] === 3) {
            if (id === 0) {
                x--;
                width++;
            } else if (id === 2) {
                height++;
            } else if (id === 4) {
                width++;
            } else if (id === 6) {
                y--;
                height++;
            }

            this._walkToActionSource_from8(this.localRegionX, this.localRegionY, x, y, (x + width) - 1, (y + height) - 1, false, true);
            return;
        } else {
            this._walkToActionSource_from8(this.localRegionX, this.localRegionY, x, y, (x + width) - 1, (y + height) - 1, true, true);
            return;
        }
    }

    getInventoryCount(id) {
        let count = 0;

        for (let i = 0; i < this.inventoryItemsCount; i++) {
            if (this.inventoryItemId[i] === id) {
                if (GameData.itemStackable[id] === 1) {
                    count++;
                } else {
                    count += this.inventoryItemStackCount[i];
                }
            }
        }

        return count;
    }

    async loadTextures() {
        const texturesJag = await this.readDataFile(
            `textures${version.TEXTURES}.jag`,
            'Textures',
            50
        );

        if (!texturesJag) {
            this.errorLoadingData = true;
            return;
        }

        const indexDat = Utility.loadData('index.dat', 0, texturesJag);
        this.scene.allocateTextures(GameData.textureCount, 7, 11);

        for (let i = 0; i < GameData.textureCount; i++) {
            const name = GameData.textureName[i];

            let buff1 = Utility.loadData(`${name}.dat`, 0, texturesJag);

            this.surface.parseSprite(this.spriteTexture, buff1, indexDat, 1);
            this.surface.drawBox(0, 0, 128, 128, 0xff00ff);
            this.surface._drawSprite_from3(0, 0, this.spriteTexture);

            let wh = this.surface.spriteWidthFull[this.spriteTexture];
            let nameSub = GameData.textureSubtypeName[i];

            if (nameSub !== null && nameSub.length > 0) {
                let buff2 = Utility.loadData(`${nameSub}.dat`, 0, texturesJag);

                this.surface.parseSprite(this.spriteTexture, buff2, indexDat, 1);
                this.surface._drawSprite_from3(0, 0, this.spriteTexture);
            }

            this.surface._drawSprite_from5(this.spriteTextureWorld + i, 0, 0, wh, wh);

            let area = wh * wh;

            for (let j = 0; j < area; j++) {
                if (this.surface.surfacePixels[this.spriteTextureWorld + i][j] === 65280) {
                    this.surface.surfacePixels[this.spriteTextureWorld + i][j] = 0xff00ff;
                }
            }

            this.surface.drawWorld(this.spriteTextureWorld + i);
            this.scene.defineTexture(i, this.surface.spriteColoursUsed[this.spriteTextureWorld + i], this.surface.spriteColourList[this.spriteTextureWorld + i], ((wh / 64) | 0) - 1);
        }
    }

    handleMouseDown(i, x, y) {
        this.mouseClickXHistory[this.mouseClickCount] = x;
        this.mouseClickYHistory[this.mouseClickCount] = y;
        this.mouseClickCount = this.mouseClickCount + 1 & 8191;

        for (let l = 10; l < 4000; l++) {
            let i1 = this.mouseClickCount - l & 8191;

            if (this.mouseClickXHistory[i1] === x && this.mouseClickYHistory[i1] === y) {
                let flag = false;

                for (let j1 = 1; j1 < l; j1++) {
                    let k1 = this.mouseClickCount - j1 & 8191;
                    let l1 = i1 - j1 & 8191;

                    if (this.mouseClickXHistory[l1] !== x || this.mouseClickYHistory[l1] !== y) {
                        flag = true;
                    }

                    if (this.mouseClickXHistory[k1] !== this.mouseClickXHistory[l1] || this.mouseClickYHistory[k1] !== this.mouseClickYHistory[l1]) {
                        break;
                    }

                    if (j1 === l - 1 && flag && this.combatTimeout === 0 && this.logoutTimeout === 0) {
                        this.sendLogout();
                        return;
                    }
                }
            }
        }
    }

    drawTeleportBubble(x, y, w, h, id) {
        const type = this.teleportBubbleType[id];
        const time = this.teleportBubbleTime[id];

        if (type === 0) {
            // blue bubble used for teleports
            const colour = 255 + time * 5 * 256;
            this.surface.drawCircle(x + ((w / 2) | 0), y + ((h / 2) | 0), 20 + time * 2, colour, 255 - time * 5);
        } else if (type === 1) {
            // red bubble used for telegrab
            const colour = 0xff0000 + time * 5 * 256;
            this.surface.drawCircle(x + ((w / 2) | 0), y + ((h / 2) | 0), 10 + time, colour, 255 - time * 5);
        }
    }

    showServerMessage(s) {
        if (/^@bor@/.test(s)) {
            this.showMessage(s, 4);
        } else if (/^@que@/.test(s)) {
            this.showMessage(`@whi@${s}`, 5);
        } else if (/^@pri@/.test(s)) {
            this.showMessage(s, 6);
        } else {
            this.showMessage(s, 3);
        }
    }

    // looks like it just updates objects like torches etc to flip between the
    // different models and appear "animated"
    updateObjectAnimation(objectIndex, modelName) {
        const objectX = this.objectX[objectIndex];
        const objectY = this.objectY[objectIndex];
        const distanceX = objectX - ((this.localPlayer.currentX / 128) | 0);
        const distanceY = objectY - ((this.localPlayer.currentY / 128) | 0);
        const maxDistance = 7;

        if (objectX >= 0 && objectY >= 0 && objectX < 96 && objectY < 96 && distanceX > -maxDistance && distanceX < maxDistance && distanceY > -maxDistance && distanceY < maxDistance) {
            this.scene.removeModel(this.objectModel[objectIndex]);

            const modelIndex = GameData.getModelIndex(modelName);
            const gameModel = this.gameModels[modelIndex].copy();

            this.scene.addModel(gameModel);
            gameModel._setLight_from6(true, 48, 48, -50, -10, -50);
            gameModel.copyPosition(this.objectModel[objectIndex]);
            gameModel.key = objectIndex;
            this.objectModel[objectIndex] = gameModel;
        }
    }

    createTopMouseMenu() {
        if (this.selectedSpell >= 0 || this.selectedItemInventoryIndex >= 0) {
            this.menuItemText1[this.menuItemsCount] = 'Cancel';
            this.menuItemText2[this.menuItemsCount] = '';
            this.menuType[this.menuItemsCount] = 4000;
            this.menuItemsCount++;
        }

        for (let i = 0; i < this.menuItemsCount; i++) {
            this.menuIndices[i] = i;
        }

        for (let flag = false; !flag; ) {
            flag = true;

            for (let j = 0; j < this.menuItemsCount - 1; j++) {
                let l = this.menuIndices[j];
                let j1 = this.menuIndices[j + 1];

                if (this.menuType[l] > this.menuType[j1]) {
                    this.menuIndices[j] = j1;
                    this.menuIndices[j + 1] = l;
                    flag = false;
                }
            }

        }

        if (this.menuItemsCount > 20) {
            this.menuItemsCount = 20;
        }

        if (this.menuItemsCount > 0) {
            let k = -1;

            for (let i1 = 0; i1 < this.menuItemsCount; i1++) {
                if (this.menuItemText2[this.menuIndices[i1]] === null || this.menuItemText2[this.menuIndices[i1]].length <= 0) {
                    continue;
                }

                k = i1;
                break;
            }

            let s = null;

            if ((this.selectedItemInventoryIndex >= 0 || this.selectedSpell >= 0) && this.menuItemsCount === 1) {
                s = 'Choose a target';
            } else if ((this.selectedItemInventoryIndex >= 0 || this.selectedSpell >= 0) && this.menuItemsCount > 1) {
                s = '@whi@' + this.menuItemText1[this.menuIndices[0]] + ' ' + this.menuItemText2[this.menuIndices[0]];
            } else if (k !== -1) {
                s = this.menuItemText2[this.menuIndices[k]] + ': @whi@' + this.menuItemText1[this.menuIndices[0]];
            }

            if (this.menuItemsCount === 2 && s !== null) {
                s = s + '@whi@ / 1 more option';
            }

            if (this.menuItemsCount > 2 && s !== null) {
                s = s + '@whi@ / ' + (this.menuItemsCount - 1) + ' more options';
            }

            if (s !== null) {
                this.surface.drawString(s, 6, 14, 1, 0xffff00);
            }

            if (!this.optionMouseButtonOne && this.mouseButtonClick === 1 || this.optionMouseButtonOne && this.mouseButtonClick === 1 && this.menuItemsCount === 1) {
                this.menuItemClick(this.menuIndices[0]);
                this.mouseButtonClick = 0;
                return;
            }

            if (!this.optionMouseButtonOne && this.mouseButtonClick === 2 || this.optionMouseButtonOne && this.mouseButtonClick === 1) {
                this.menuHeight = (this.menuItemsCount + 1) * 15;
                this.menuWidth = this.surface.textWidth('Choose option', 1) + 5;

                for (let k1 = 0; k1 < this.menuItemsCount; k1++) {
                    let l1 = this.surface.textWidth(this.menuItemText1[k1] + ' ' + this.menuItemText2[k1], 1) + 5;

                    if (l1 > this.menuWidth) {
                        this.menuWidth = l1;
                    }
                }

                this.menuX = this.mouseX - ((this.menuWidth / 2) | 0);
                this.menuY = this.mouseY - 7;
                this.showRightClickMenu = true;

                if (this.menuX < 0) {
                    this.menuX = 0;
                }

                if (this.menuY < 0) {
                    this.menuY = 0;
                }

                if (this.menuX + this.menuWidth > 510) {
                    this.menuX = 510 - this.menuWidth;
                }

                if (this.menuY + this.menuHeight > 315) {
                    this.menuY = 315 - this.menuHeight;
                }

                this.mouseButtonClick = 0;
            }
        }
    }

    menuItemClick(i) {
        const menuX = this.menuItemX[i];
        const menuY = this.menuItemY[i];
        const menuIndex = this.menuIndex[i];
        const menuSourceIndex = this.menuSourceIndex[i];
        const menuTargetIndex = this.menuTargetIndex[i];
        const menuType = this.menuType[i];

        switch (menuType) {
            case 200:
                this.walkToGroundItem(this.localRegionX, this.localRegionY, menuX,
                    menuY, true);
                this.packetStream.newPacket(clientOpcodes.CAST_GROUNDITEM);
                this.packetStream.putShort(menuX + this.regionX);
                this.packetStream.putShort(menuY + this.regionY);
                this.packetStream.putShort(menuIndex);
                this.packetStream.putShort(menuSourceIndex);
                this.packetStream.sendPacket();
                this.selectedSpell = -1;
                break;
            case 210:
                this.walkToGroundItem(this.localRegionX, this.localRegionY,
                    menuX, menuY, true);
                this.packetStream.newPacket(clientOpcodes.USEWITH_GROUNDITEM);
                this.packetStream.putShort(menuX + this.regionX);
                this.packetStream.putShort(menuY + this.regionY);
                this.packetStream.putShort(menuIndex);
                this.packetStream.putShort(menuSourceIndex);
                this.packetStream.sendPacket();
                this.selectedItemInventoryIndex = -1;
                break;
            case 220:
                this.walkToGroundItem(this.localRegionX, this.localRegionY, menuX,
                    menuY, true);
                this.packetStream.newPacket(clientOpcodes.GROUNDITEM_TAKE);
                this.packetStream.putShort(menuX + this.regionX);
                this.packetStream.putShort(menuY + this.regionY);
                this.packetStream.putShort(menuIndex);
                this.packetStream.putShort(menuSourceIndex);
                this.packetStream.sendPacket();
                break;
            case 3200:
                this.showMessage(GameData.itemDescription[menuIndex], 3);
                break;
            case 300:
                this.walkToWallObject(menuX, menuY, menuIndex);
                this.packetStream.newPacket(clientOpcodes.CAST_WALLOBJECT);
                this.packetStream.putShort(menuX + this.regionX);
                this.packetStream.putShort(menuY + this.regionY);
                this.packetStream.putByte(menuIndex);
                this.packetStream.putShort(menuSourceIndex);
                this.packetStream.sendPacket();
                this.selectedSpell = -1;
                break;
            case 310:
                this.walkToWallObject(menuX, menuY, menuIndex);
                this.packetStream.newPacket(clientOpcodes.USEWITH_WALLOBJECT);
                this.packetStream.putShort(menuX + this.regionX);
                this.packetStream.putShort(menuY + this.regionY);
                this.packetStream.putByte(menuIndex);
                this.packetStream.putShort(menuSourceIndex);
                this.packetStream.sendPacket();
                this.selectedItemInventoryIndex = -1;
                break;
            case 320:
                this.walkToWallObject(menuX, menuY, menuIndex);
                this.packetStream.newPacket(clientOpcodes.WALL_OBJECT_COMMAND1);
                this.packetStream.putShort(menuX + this.regionX);
                this.packetStream.putShort(menuY + this.regionY);
                this.packetStream.putByte(menuIndex);
                this.packetStream.sendPacket();
                break;
            case 2300:
                this.walkToWallObject(menuX, menuY, menuIndex);
                this.packetStream.newPacket(clientOpcodes.WALL_OBJECT_COMMAND2);
                this.packetStream.putShort(menuX + this.regionX);
                this.packetStream.putShort(menuY + this.regionY);
                this.packetStream.putByte(menuIndex);
                this.packetStream.sendPacket();
                break;
            case 3300:
                this.showMessage(GameData.wallObjectDescription[menuIndex], 3);
                break;
            case 400:
                this.walkToObject(menuX, menuY, menuIndex, menuSourceIndex);
                this.packetStream.newPacket(clientOpcodes.CAST_OBJECT);
                this.packetStream.putShort(menuX + this.regionX);
                this.packetStream.putShort(menuY + this.regionY);
                this.packetStream.putShort(menuTargetIndex);
                this.packetStream.sendPacket();
                this.selectedSpell = -1;
                break;
            case 410:
                this.walkToObject(menuX, menuY, menuIndex, menuSourceIndex);
                this.packetStream.newPacket(clientOpcodes.USEWITH_OBJECT);
                this.packetStream.putShort(menuX + this.regionX);
                this.packetStream.putShort(menuY + this.regionY);
                this.packetStream.putShort(menuTargetIndex);
                this.packetStream.sendPacket();
                this.selectedItemInventoryIndex = -1;
                break;
            case 420:
                this.walkToObject(menuX, menuY, menuIndex, menuSourceIndex);
                this.packetStream.newPacket(clientOpcodes.OBJECT_CMD1);
                this.packetStream.putShort(menuX + this.regionX);
                this.packetStream.putShort(menuY + this.regionY);
                this.packetStream.sendPacket();
                break;
            case 2400:
                this.walkToObject(menuX, menuY, menuIndex, menuSourceIndex);
                this.packetStream.newPacket(clientOpcodes.OBJECT_CMD2);
                this.packetStream.putShort(menuX + this.regionX);
                this.packetStream.putShort(menuY + this.regionY);
                this.packetStream.sendPacket();
                break;
            case 3400:
                this.showMessage(GameData.objectDescription[menuIndex], 3);
                break;
            case 600:
                this.packetStream.newPacket(clientOpcodes.CAST_INVITEM);
                this.packetStream.putShort(menuIndex);
                this.packetStream.putShort(menuSourceIndex);
                this.packetStream.sendPacket();
                this.selectedSpell = -1;
                break;
            case 610:
                this.packetStream.newPacket(clientOpcodes.USEWITH_INVITEM);
                this.packetStream.putShort(menuIndex);
                this.packetStream.putShort(menuSourceIndex);
                this.packetStream.sendPacket();
                this.selectedItemInventoryIndex = -1;
                break;
            case 620:
                this.packetStream.newPacket(clientOpcodes.INV_UNEQUIP);
                this.packetStream.putShort(menuIndex);
                this.packetStream.sendPacket();
                break;
            case 630:
                this.packetStream.newPacket(clientOpcodes.INV_WEAR);
                this.packetStream.putShort(menuIndex);
                this.packetStream.sendPacket();
                break;
            case 640:
                this.packetStream.newPacket(clientOpcodes.INV_CMD);
                this.packetStream.putShort(menuIndex);
                this.packetStream.sendPacket();
                break;
            case 650:
                this.selectedItemInventoryIndex = menuIndex;
                this.showUiTab = 0;
                this.selectedItemName =
                        GameData.itemName[this.inventoryItemId[
                            this.selectedItemInventoryIndex]];
                break;
            case 660:
                this.packetStream.newPacket(clientOpcodes.INV_DROP);
                this.packetStream.putShort(menuIndex);
                this.packetStream.sendPacket();
                this.selectedItemInventoryIndex = -1;
                this.showUiTab = 0;
                this.showMessage(
                    'Dropping ' +
                        GameData.itemName[this.inventoryItemId[menuIndex]],
                    4
                );
                break;
            case 3600:
                this.showMessage(GameData.itemDescription[menuIndex], 3);
                break;
            case 700: {
                const x = ((menuX - 64) / this.magicLoc) | 0;
                const y = ((menuY - 64) / this.magicLoc) | 0;

                this._walkToActionSource_from5(this.localRegionX, this.localRegionY,
                    x, y, true);
                this.packetStream.newPacket(clientOpcodes.CAST_NPC);
                this.packetStream.putShort(menuIndex);
                this.packetStream.putShort(menuSourceIndex);
                this.packetStream.sendPacket();
                this.selectedSpell = -1;
                break;
            }
            case 710: {
                const x = ((menuX - 64) / this.magicLoc) | 0;
                const y = ((menuY - 64) / this.magicLoc) | 0;

                this._walkToActionSource_from5(this.localRegionX, this.localRegionY,
                    x, y, true);
                this.packetStream.newPacket(clientOpcodes.USEWITH_NPC);
                this.packetStream.putShort(menuIndex);
                this.packetStream.putShort(menuSourceIndex);
                this.packetStream.sendPacket();
                this.selectedItemInventoryIndex = -1;
                break;
            }
            case 720: {
                const x = ((menuX - 64) / this.magicLoc) | 0;
                const y = ((menuY - 64) / this.magicLoc) | 0;

                this._walkToActionSource_from5(this.localRegionX, this.localRegionY,
                    x, y, true);
                this.packetStream.newPacket(clientOpcodes.NPC_TALK);
                this.packetStream.putShort(menuIndex);
                this.packetStream.sendPacket();
                break;
            }
            case 725: {
                const x = ((menuX - 64) / this.magicLoc) | 0;
                const y = ((menuY - 64) / this.magicLoc) | 0;

                this._walkToActionSource_from5(this.localRegionX, this.localRegionY,
                    x, y, true);
                this.packetStream.newPacket(clientOpcodes.NPC_CMD);
                this.packetStream.putShort(menuIndex);
                this.packetStream.sendPacket();
                break;
            }
            case 715:
            case 2715: {
                const x = ((menuX - 64) / this.magicLoc) | 0;
                const y = ((menuY - 64) / this.magicLoc) | 0;

                this._walkToActionSource_from5(this.localRegionX, this.localRegionY,
                    x, y, true);
                this.packetStream.newPacket(clientOpcodes.NPC_ATTACK);
                this.packetStream.putShort(menuIndex);
                this.packetStream.sendPacket();
                break;
            }
            case 3700:
                this.showMessage(GameData.npcDescription[menuIndex], 3);
                break;
            case 800: {
                const x = ((menuX - 64) / this.magicLoc) | 0;
                const y = ((menuY - 64) / this.magicLoc) | 0;

                this._walkToActionSource_from5(this.localRegionX, this.localRegionY,
                    x, y, true);
                this.packetStream.newPacket(clientOpcodes.CAST_PLAYER);
                this.packetStream.putShort(menuIndex);
                this.packetStream.putShort(menuSourceIndex);
                this.packetStream.sendPacket();
                this.selectedSpell = -1;
                break;
            }
            case 810: {
                const x = ((menuX - 64) / this.magicLoc) | 0;
                const y = ((menuY - 64) / this.magicLoc) | 0;

                this._walkToActionSource_from5(this.localRegionX, this.localRegionY,
                    x, y, true);
                this.packetStream.newPacket(clientOpcodes.USEWITH_PLAYER);
                this.packetStream.putShort(menuIndex);
                this.packetStream.putShort(menuSourceIndex);
                this.packetStream.sendPacket();
                this.selectedItemInventoryIndex = -1;
                break;
            }
            case 805:
            case 2805: {
                const x = ((menuX - 64) / this.magicLoc) | 0;
                const y = ((menuY - 64) / this.magicLoc) | 0;

                this._walkToActionSource_from5(this.localRegionX, this.localRegionY,
                    x, y, true);
                this.packetStream.newPacket(clientOpcodes.PLAYER_ATTACK);
                this.packetStream.putShort(menuIndex);
                this.packetStream.sendPacket();
                break;
            }
            case 2806:
                this.packetStream.newPacket(clientOpcodes.PLAYER_DUEL);
                this.packetStream.putShort(menuIndex);
                this.packetStream.sendPacket();
                break;
            case 2810:
                this.packetStream.newPacket(clientOpcodes.PLAYER_TRADE);
                this.packetStream.putShort(menuIndex);
                this.packetStream.sendPacket();
                break;
            case 2820:
                this.packetStream.newPacket(clientOpcodes.PLAYER_FOLLOW);
                this.packetStream.putShort(menuIndex);
                this.packetStream.sendPacket();
                break;
            case 900:
                this._walkToActionSource_from5(this.localRegionX, this.localRegionY,
                    menuX, menuY, true);
                this.packetStream.newPacket(clientOpcodes.CAST_GROUND);
                this.packetStream.putShort(menuX + this.regionX);
                this.packetStream.putShort(menuY + this.regionY);
                this.packetStream.putShort(menuIndex);
                this.packetStream.sendPacket();
                this.selectedSpell = -1;
                break;
            case 920:
                this._walkToActionSource_from5(this.localRegionX, this.localRegionY,
                    menuX, menuY, false);

                if (this.mouseClickXStep === -24) {
                    this.mouseClickXStep = 24;
                }
                break;
            case 1000:
                this.packetStream.newPacket(clientOpcodes.CAST_SELF);
                this.packetStream.putShort(menuIndex);
                this.packetStream.sendPacket();
                this.selectedSpell = -1;
                break;
            case 4000:
                this.selectedItemInventoryIndex = -1;
                this.selectedSpell = -1;
                break;
        }
    }

    showLoginScreenStatus(s, s1) {
        if (this.loginScreen === 1) {
            this.panelLoginNewUser.updateText(this.controlRegisterStatus, s + ' ' + s1);
        } else if (this.loginScreen === 2) {
            this.panelLoginExistingUser.updateText(this.controlLoginStatus, s + ' ' + s1);
        }

        this.loginUserDisp = s1;
        this.drawLoginScreens();
        this.resetTimings();
    }

    async lostConnection() {
        this.systemUpdate = 0;

        if (this.logoutTimeout !== 0) {
            this.resetLoginVars();
        } else {
            await super.lostConnection();
        }
    }

    isValidCameraAngle(angle) {
        const x = (this.localPlayer.currentX / 128) | 0;
        const y = (this.localPlayer.currentY / 128) | 0;

        for (let l = 2; l >= 1; l--) {
            if (angle === 1 && ((this.world.objectAdjacency.get(x, y - l) & 128) === 128 || (this.world.objectAdjacency.get(x - l, y) & 128) === 128 || (this.world.objectAdjacency.get(x - l, y - l) & 128) === 128)) {
                return false;
            }

            if (angle === 3 && ((this.world.objectAdjacency.get(x, y + l) & 128) === 128 || (this.world.objectAdjacency.get(x - l, y) & 128) === 128 || (this.world.objectAdjacency.get(x - l, y + l) & 128) === 128)) {
                return false;
            }

            if (angle === 5 && ((this.world.objectAdjacency.get(x, y + l) & 128) === 128 || (this.world.objectAdjacency.get(x + l, y) & 128) === 128 || (this.world.objectAdjacency.get(x + l, y + l) & 128) === 128)) {
                return false;
            }

            if (angle === 7 && ((this.world.objectAdjacency.get(x, y - l) & 128) === 128 || (this.world.objectAdjacency.get(x + l, y) & 128) === 128 || (this.world.objectAdjacency.get(x + l, y - l) & 128) === 128)) {
                return false;
            }

            if (angle === 0 && (this.world.objectAdjacency.get(x, y - l) & 128) === 128) {
                return false;
            }

            if (angle === 2 && (this.world.objectAdjacency.get(x - l, y) & 128) === 128) {
                return false;
            }

            if (angle === 4 && (this.world.objectAdjacency.get(x, y + l) & 128) === 128) {
                return false;
            }

            if (angle === 6 && (this.world.objectAdjacency.get(x + l, y) & 128) === 128) {
                return false;
            }
        }

        return true;
    }

    resetLoginScreenVariables() {
        this.loggedIn = 0;
        this.loginScreen = 0;
        this.loginUser = '';
        this.loginPass = '';
        this.loginUserDesc = 'Please enter a username:';
        this.loginUserDisp = `*${this.loginUser}*`;
        this.playerCount = 0;
        this.npcCount = 0;
    }

    handleIncomingPacket(opcode, size, data) {
        try {
            if (opcode === serverOpcodes.REGION_PLAYER_UPDATE) {
                const length = Utility.getUnsignedShort(data, 1);
                let offset = 3;

                for (let i = 0; i < length; i++) {
                    const playerIndex = Utility.getUnsignedShort(data, offset);
                    offset += 2;

                    const player = this.playerServer[playerIndex];

                    const updateType = data[offset];
                    offset++;

                    // speech bubble with an item in it
                    if (updateType === 0) {
                        const itemID = Utility.getUnsignedShort(data, offset);
                        offset += 2;

                        if (player !== null) {
                            player.bubbleTimeout = 150;
                            player.bubbleItem = itemID;
                        }
                    // chat
                    } else if (updateType === 1) {
                        const messageLength = data[offset];
                        offset++;

                        if (player !== null) {
                            let message =
                                ChatMessage.descramble(
                                    data,
                                    offset,
                                    messageLength
                                );

                            if (this.options.wordFilter) {
                                message = WordFilter.filter(message);
                            }

                            let ignored = false;

                            for (let i = 0; i < this.ignoreListCount; i++) {
                                if (this.ignoreList[i] === player.hash) {
                                    ignored = true;
                                    break;
                                }
                            }

                            if (!ignored) {
                                player.messageTimeout = 150;
                                player.message = message;
                                this.showMessage(
                                    `${player.name}: ${player.message}`,
                                    2
                                );
                            }
                        }

                        offset += messageLength;
                    // combat damage and hp
                    } else if (updateType === 2) {
                        const damage = Utility.getUnsignedByte(data[offset]);
                        offset++;

                        const current = Utility.getUnsignedByte(data[offset]);
                        offset++;

                        const max = Utility.getUnsignedByte(data[offset]);
                        offset++;

                        if (player !== null) {
                            player.damageTaken = damage;
                            player.healthCurrent = current;
                            player.healthMax = max;
                            player.combatTimer = 200;

                            if (player === this.localPlayer) {
                                this.playerStatCurrent[3] = current;
                                this.playerStatBase[3] = max;
                                this.showDialogWelcome = false;
                                this.showDialogServerMessage = false;
                            }
                        }
                    // new incoming projectile to npc
                    } else if (updateType === 3) {
                        const projectileSprite = Utility.getUnsignedShort(data, offset);
                        offset += 2;

                        const npcIndex = Utility.getUnsignedShort(data, offset);
                        offset += 2;

                        if (player !== null) {
                            player.incomingProjectileSprite = projectileSprite;
                            player.attackingNpcServerIndex = npcIndex;
                            player.attackingPlayerServerIndex = -1;
                            player.projectileRange = this.projectileMaxRange;
                        }
                    // new incoming projectile from player
                    } else if (updateType === 4) {
                        const projectileSprite = Utility.getUnsignedShort(data, offset);
                        offset += 2;

                        const opponentIndex = Utility.getUnsignedShort(data, offset);
                        offset += 2;

                        if (player !== null) {
                            player.incomingProjectileSprite = projectileSprite;
                            player.attackingPlayerServerIndex = opponentIndex;
                            player.attackingNpcServerIndex = -1;
                            player.projectileRange = this.projectileMaxRange;
                        }
                    // player appearance update
                    } else if (updateType === 5) {
                        if (player !== null) {
                            player.serverId = Utility.getUnsignedShort(data, offset);
                            offset += 2;
                            player.hash = Utility.getUnsignedLong(data, offset);
                            offset += 8;
                            player.name = Utility.hashToUsername(player.hash);

                            const equippedCount = Utility.getUnsignedByte(data[offset]);
                            offset++;

                            for (let j = 0; j < equippedCount; j++) {
                                player.equippedItem[j] = Utility.getUnsignedByte(data[offset]);
                                offset++;
                            }

                            for (let j = equippedCount; j < 12; j++) {
                                player.equippedItem[j] = 0;
                            }

                            player.colourHair = data[offset++] & 0xff;
                            player.colourTop = data[offset++] & 0xff;
                            player.colourBottom = data[offset++] & 0xff;
                            player.colourSkin = data[offset++] & 0xff;
                            player.level = data[offset++] & 0xff;
                            player.skullVisible = data[offset++] & 0xff;
                        } else {
                            offset += 14;

                            const unused = Utility.getUnsignedByte(data[offset]);
                            offset += unused + 1;
                        }
                    // public chat
                    } else if (updateType === 6) {
                        const messageLength = data[offset];
                        offset++;

                        if (player !== null) {
                            const message = ChatMessage.descramble(data, offset, messageLength);

                            player.messageTimeout = 150;
                            player.message = message;

                            if (player === this.localPlayer) {
                                this.showMessage(
                                    `${player.name}: ${player.message}`,
                                    5
                                );
                            }
                        }

                        offset += messageLength;
                    }
                }

                return;
            }

            if (opcode === serverOpcodes.REGION_WALL_OBJECTS) {
                for (let offset = 1; offset < size; )
                    if (Utility.getUnsignedByte(data[offset]) === 255) {
                        let count = 0;
                        let lX = this.localRegionX + data[offset + 1] >> 3;
                        let lY = this.localRegionY + data[offset + 2] >> 3;

                        offset += 3;

                        for (let i = 0; i < this.wallObjectCount; i++) {
                            let sX = (this.wallObjectX[i] >> 3) - lX;
                            let sY = (this.wallObjectY[i] >> 3) - lY;

                            if (sX !== 0 || sY !== 0) {
                                if (i !== count) {
                                    this.wallObjectModel[count] = this.wallObjectModel[i];
                                    this.wallObjectModel[count].key = count + 10000;
                                    this.wallObjectX[count] = this.wallObjectX[i];
                                    this.wallObjectY[count] = this.wallObjectY[i];
                                    this.wallObjectDirection[count] = this.wallObjectDirection[i];
                                    this.wallObjectId[count] = this.wallObjectId[i];
                                }

                                count++;
                            } else {
                                this.scene.removeModel(this.wallObjectModel[i]);
                                this.world.removeWallObject(this.wallObjectX[i], this.wallObjectY[i], this.wallObjectDirection[i], this.wallObjectId[i]);
                            }
                        }

                        this.wallObjectCount = count;
                    } else {
                        const id = Utility.getUnsignedShort(data, offset);
                        offset += 2;

                        const lX = this.localRegionX + data[offset++];
                        const lY = this.localRegionY + data[offset++];
                        const direction = data[offset++];
                        let count = 0;

                        for (let i = 0; i < this.wallObjectCount; i++) {
                            if (this.wallObjectX[i] !== lX || this.wallObjectY[i] !== lY || this.wallObjectDirection[i] !== direction) {
                                if (i !== count) {
                                    this.wallObjectModel[count] = this.wallObjectModel[i];
                                    this.wallObjectModel[count].key = count + 10000;
                                    this.wallObjectX[count] = this.wallObjectX[i];
                                    this.wallObjectY[count] = this.wallObjectY[i];
                                    this.wallObjectDirection[count] = this.wallObjectDirection[i];
                                    this.wallObjectId[count] = this.wallObjectId[i];
                                }

                                count++;
                            } else {
                                this.scene.removeModel(this.wallObjectModel[i]);
                                this.world.removeWallObject(this.wallObjectX[i], this.wallObjectY[i], this.wallObjectDirection[i], this.wallObjectId[i]);
                            }
                        }

                        this.wallObjectCount = count;

                        if (id !== 65535) {
                            this.world._setObjectAdjacency_from4(lX, lY, direction, id);

                            const model = this.createModel(lX, lY, direction, id, this.wallObjectCount);
                            this.wallObjectModel[this.wallObjectCount] = model;
                            this.wallObjectX[this.wallObjectCount] = lX;
                            this.wallObjectY[this.wallObjectCount] = lY;
                            this.wallObjectId[this.wallObjectCount] = id;
                            this.wallObjectDirection[this.wallObjectCount++] = direction;
                        }
                    }

                return;
            }

            if (opcode === serverOpcodes.REGION_NPC_UPDATE) {
                const length = Utility.getUnsignedShort(data, 1);
                let offset = 3;

                for (let i = 0; i < length; i++) {
                    const serverIndex = Utility.getUnsignedShort(data, offset);
                    offset += 2;

                    const npc = this.npcsServer[serverIndex];
                    const updateType = Utility.getUnsignedByte(data[offset]);
                    offset++;

                    if (updateType === 1) {
                        let target = Utility.getUnsignedShort(data, offset);
                        offset += 2;

                        let scrambledLength = data[offset];
                        offset++;

                        if (npc !== null) {
                            const message =
                                ChatMessage.descramble(data, offset, scrambledLength);

                            npc.messageTimeout = 150;
                            npc.message = message;

                            if (target === this.localPlayer.serverIndex) {
                                this.showMessage(
                                    '@yel@' +
                                        GameData.npcName[npc.npcId] + ': ' +
                                        npc.message,
                                    5
                                );
                            }
                        }

                        offset += scrambledLength;
                    } else if (updateType === 2) {
                        const damageTaken = Utility.getUnsignedByte(data[offset]);
                        offset++;

                        const currentHealth = Utility.getUnsignedByte(data[offset]);
                        offset++;

                        const maxHealth = Utility.getUnsignedByte(data[offset]);
                        offset++;

                        if (npc !== null) {
                            npc.damageTaken = damageTaken;
                            npc.healthCurrent = currentHealth;
                            npc.healthMax = maxHealth;
                            npc.combatTimer = 200;
                        }
                    }
                }

                return;
            }

            if (opcode === serverOpcodes.WORLD_INFO) {
                this.loadingArea = true;
                this.localPlayerServerIndex = Utility.getUnsignedShort(data, 1);
                this.planeWidth = Utility.getUnsignedShort(data, 3);
                this.planeHeight = Utility.getUnsignedShort(data, 5);
                this.planeIndex = Utility.getUnsignedShort(data, 7);
                this.planeMultiplier = Utility.getUnsignedShort(data, 9);
                this.planeHeight -= this.planeIndex * this.planeMultiplier;

                return;
            }

            if (opcode === serverOpcodes.PLAYER_DIED) {
                this.deathScreenTimeout = 250;
                return;
            }

            if (opcode === serverOpcodes.REGION_ENTITY_UPDATE) {
                const length = ((size - 1) / 4) | 0;

                for (let i = 0; i < length; i++) {
                    const deltaX = this.localRegionX + Utility.getSignedShort(data, 1 + i * 4) >> 3;
                    const deltaY = this.localRegionY + Utility.getSignedShort(data, 3 + i * 4) >> 3;
                    let entityCount = 0;

                    for (let j = 0; j < this.groundItemCount; j++) {
                        const x = (this.groundItemX[j] >> 3) - deltaX;
                        const y = (this.groundItemY[j] >> 3) - deltaY;

                        if (x !== 0 || y !== 0) {
                            if (j !== entityCount) {
                                this.groundItemX[entityCount] = this.groundItemX[j];
                                this.groundItemY[entityCount] = this.groundItemY[j];
                                this.groundItemID[entityCount] = this.groundItemID[j];
                                this.groundItemZ[entityCount] = this.groundItemZ[j];
                            }

                            entityCount++;
                        }
                    }

                    this.groundItemCount = entityCount;
                    entityCount = 0;

                    for (let j = 0; j < this.objectCount; j++) {
                        const x = (this.objectX[j] >> 3) - deltaX;
                        const y = (this.objectY[j] >> 3) - deltaY;

                        if (x !== 0 || y !== 0) {
                            if (j !== entityCount) {
                                this.objectModel[entityCount] = this.objectModel[j];
                                this.objectModel[entityCount].key = entityCount;
                                this.objectX[entityCount] = this.objectX[j];
                                this.objectY[entityCount] = this.objectY[j];
                                this.objectId[entityCount] = this.objectId[j];
                                this.objectDirection[entityCount] = this.objectDirection[j];
                            }

                            entityCount++;
                        } else {
                            this.scene.removeModel(this.objectModel[j]);
                            this.world.removeObject(this.objectX[j], this.objectY[j], this.objectId[j]);
                        }
                    }

                    this.objectCount = entityCount;
                    entityCount = 0;

                    for (let j = 0; j < this.wallObjectCount; j++) {
                        const x = (this.wallObjectX[j] >> 3) - deltaX;
                        const y = (this.wallObjectY[j] >> 3) - deltaY;

                        if (x !== 0 || y !== 0) {
                            if (j !== entityCount) {
                                this.wallObjectModel[entityCount] = this.wallObjectModel[j];
                                this.wallObjectModel[entityCount].key = entityCount + 10000;
                                this.wallObjectX[entityCount] = this.wallObjectX[j];
                                this.wallObjectY[entityCount] = this.wallObjectY[j];
                                this.wallObjectDirection[entityCount] = this.wallObjectDirection[j];
                                this.wallObjectId[entityCount] = this.wallObjectId[j];
                            }

                            entityCount++;
                        } else {
                            this.scene.removeModel(this.wallObjectModel[j]);
                            this.world.removeWallObject(this.wallObjectX[j], this.wallObjectY[j], this.wallObjectDirection[j], this.wallObjectId[j]);
                        }
                    }

                    this.wallObjectCount = entityCount;
                }

                return;
            }

            if (opcode === serverOpcodes.APPEARANCE) {
                this.showAppearanceChange = true;
                return;
            }

            if (opcode === serverOpcodes.TRADE_OPEN) {
                const playerIndex = Utility.getUnsignedShort(data, 1);

                if (this.playerServer[playerIndex] !== null) {
                    this.tradeRecipientName = this.playerServer[playerIndex].name;
                }

                this.showDialogTrade = true;
                this.tradeRecipientAccepted = false;
                this.tradeAccepted = false;
                this.tradeItemsCount = 0;
                this.tradeRecipientItemsCount = 0;
                return;
            }

            if (opcode === serverOpcodes.TRADE_CLOSE) {
                this.showDialogTrade = false;
                this.showDialogTradeConfirm = false;
                return;
            }

            if (opcode === serverOpcodes.TRADE_ITEMS) {
                this.tradeRecipientItemsCount = data[1] & 0xff;

                let offset = 2;

                for (let i = 0; i < this.tradeRecipientItemsCount; i++) {
                    this.tradeRecipientItems[i] = Utility.getUnsignedShort(data, offset);
                    offset += 2;

                    this.tradeRecipientItemCount[i] = Utility.getUnsignedInt(data, offset);
                    offset += 4;
                }

                this.tradeRecipientAccepted = false;
                this.tradeAccepted = false;
                return;
            }

            if (opcode === serverOpcodes.TRADE_RECIPIENT_STATUS) {
                this.tradeRecipientAccepted = !!data[1];
                return;
            }

            if (opcode === serverOpcodes.SHOP_OPEN) {
                this.showDialogShop = true;

                let offset = 1;
                const newItemCount = data[offset++] & 0xff;
                const isGeneral = data[offset++];

                this.shopSellPriceMod = data[offset++] & 0xff;
                this.shopBuyPriceMod = data[offset++] & 0xff;

                for (let itemIndex = 0; itemIndex < 40; itemIndex++) {
                    this.shopItem[itemIndex] = -1;
                }

                for (let itemIndex = 0; itemIndex < newItemCount; itemIndex++) {
                    this.shopItem[itemIndex] = Utility.getUnsignedShort(data, offset);
                    offset += 2;

                    this.shopItemCount[itemIndex] = Utility.getUnsignedShort(data, offset);
                    offset += 2;

                    this.shopItemPrice[itemIndex] = data[offset++];
                }

                if (isGeneral === 1) {
                    let l28 = 39;

                    for (let i = 0; i < this.inventoryItemsCount; i++) {
                        if (l28 < newItemCount) {
                            break;
                        }

                        let unsellable = false;

                        for (let j = 0; j < 40; j++) {
                            if (this.shopItem[j] !== this.inventoryItemId[i]) {
                                continue;
                            }

                            unsellable = true;
                            break;
                        }

                        if (this.inventoryItemId[i] === 10) {
                            unsellable = true;
                        }

                        if (!unsellable) {
                            this.shopItem[l28] = this.inventoryItemId[i] & 32767;
                            this.shopItemCount[l28] = 0;
                            this.shopItemPrice[l28] = 0;
                            l28--;
                        }
                    }

                }

                if (this.shopSelectedItemIndex >= 0 && this.shopSelectedItemIndex < 40 && this.shopItem[this.shopSelectedItemIndex] !== this.shopSelectedItemType) {
                    this.shopSelectedItemIndex = -1;
                    this.shopSelectedItemType = -2;
                }

                return;
            }

            if (opcode === serverOpcodes.SHOP_CLOSE) {
                this.showDialogShop = false;
                return;
            }

            if (opcode === serverOpcodes.TRADE_STATUS) {
                this.tradeAccepted = !!data[1];
                return;
            }

            if (opcode === serverOpcodes.PRAYER_STATUS) {
                for (let i = 0; i < size - 1; i++) {
                    const on = data[i + 1] === 1;

                    if (!this.prayerOn[i] && on) {
                        this.playSoundFile('prayeron');
                    }

                    if (this.prayerOn[i] && !on) {
                        this.playSoundFile('prayeroff');
                    }

                    this.prayerOn[i] = on;
                }

                return;
            }

            if (opcode === serverOpcodes.BANK_OPEN) {
                this.showDialogBank = true;

                let offset = 1;

                this.newBankItemCount = data[offset++] & 0xff;
                this.bankItemsMax = data[offset++] & 0xff;

                for (let i = 0; i < this.newBankItemCount; i++) {
                    this.newBankItems[i] = Utility.getUnsignedShort(data, offset);
                    offset += 2;

                    this.newBankItemsCount[i] = Utility.getStackInt(data, offset);

                    if (this.newBankItemsCount[i] >= 128) {
                        offset += 4;
                    } else {
                        offset++;
                    }
                }

                this.updateBankItems();
                return;
            }

            if (opcode === serverOpcodes.BANK_CLOSE) {
                this.showDialogBank = false;
                return;
            }

            if (opcode === serverOpcodes.DUEL_OPEN) {
                const playerIndex = Utility.getUnsignedShort(data, 1);

                if (this.playerServer[playerIndex] !== null) {
                    this.duelOpponentName = this.playerServer[playerIndex].name;
                }

                this.showDialogDuel = true;
                this.duelOfferItemCount = 0;
                this.duelOfferOpponentItemCount = 0;
                this.duelOfferOpponentAccepted = false;
                this.duelOfferAccepted = false;
                this.duelSettingsRetreat = false;
                this.duelSettingsMagic = false;
                this.duelSettingsPrayer = false;
                this.duelSettingsWeapons = false;
                return;
            }

            if (opcode === serverOpcodes.DUEL_CLOSE) {
                this.showDialogDuel = false;
                this.showDialogDuelConfirm = false;
                return;
            }

            if (opcode === serverOpcodes.TRADE_CONFIRM_OPEN) {
                this.showDialogTradeConfirm = true;
                this.tradeConfirmAccepted = false;
                this.showDialogTrade = false;

                let offset = 1;

                this.tradeRecipientConfirmHash = Utility.getUnsignedLong(data, offset);
                offset += 8;

                this.tradeRecipientConfirmItemsCount = data[offset++] & 0xff;

                for (let i = 0; i < this.tradeRecipientConfirmItemsCount; i++) {
                    this.tradeRecipientConfirmItems[i] = Utility.getUnsignedShort(data, offset);
                    offset += 2;

                    this.tradeRecipientConfirmItemCount[i] = Utility.getUnsignedInt(data, offset);
                    offset += 4;
                }

                this.tradeConfirmItemsCount = data[offset++] & 0xff;

                for (let i = 0; i < this.tradeConfirmItemsCount; i++) {
                    this.tradeConfirmItems[i] = Utility.getUnsignedShort(data, offset);
                    offset += 2;

                    this.tradeConfirmItemCount[i] = Utility.getUnsignedInt(data, offset);
                    offset += 4;
                }

                return;
            }

            if (opcode === serverOpcodes.DUEL_UPDATE) {
                this.duelOfferOpponentItemCount = data[1] & 0xff;

                let offset = 2;

                for (let i = 0; i < this.duelOfferOpponentItemCount; i++) {
                    this.duelOfferOpponentItemId[i] = Utility.getUnsignedShort(data, offset);
                    offset += 2;
                    this.duelOfferOpponentItemStack[i] = Utility.getUnsignedInt(data, offset);
                    offset += 4;
                }

                this.duelOfferOpponentAccepted = false;
                this.duelOfferAccepted = false;
                return;
            }

            if (opcode === serverOpcodes.DUEL_SETTINGS) {
                this.duelSettingsRetreat = !!data[1];
                this.duelSettingsMagic = !!data[2];
                this.duelSettingsPrayer = !!data[3];
                this.duelSettingsWeapons = !!data[4];
                this.duelOfferOpponentAccepted = false;
                this.duelOfferAccepted = false;
                return;
            }

            if (opcode === serverOpcodes.BANK_UPDATE) {
                let offset = 1;
                const itemIndex = data[offset++] & 0xff;
                const item = Utility.getUnsignedShort(data, offset);

                offset += 2;

                const itemCount = Utility.getStackInt(data, offset);

                if (itemCount >= 128) {
                    offset += 4;
                } else {
                    offset++;
                }

                if (itemCount === 0) {
                    this.newBankItemCount--;

                    for (let i = itemIndex; i < this.newBankItemCount; i++) {
                        this.newBankItems[i] = this.newBankItems[i + 1];
                        this.newBankItemsCount[i] = this.newBankItemsCount[i + 1];
                    }
                } else {
                    this.newBankItems[itemIndex] = item;
                    this.newBankItemsCount[itemIndex] = itemCount;

                    if (itemIndex >= this.newBankItemCount) {
                        this.newBankItemCount = itemIndex + 1;
                    }
                }

                this.updateBankItems();
                return;
            }

            if (opcode === serverOpcodes.DUEL_OPPONENT_ACCEPTED) {
                this.duelOfferOpponentAccepted = !!data[1];
                return;
            }

            if (opcode === serverOpcodes.DUEL_ACCEPTED) {
                this.duelOfferAccepted = !!data[1];
                return;
            }

            if (opcode === serverOpcodes.DUEL_CONFIRM_OPEN) {
                this.showDialogDuelConfirm = true;
                this.duelAccepted = false;
                this.showDialogDuel = false;

                let offset = 1;

                this.duelOpponentNameHash = Utility.getUnsignedLong(data, offset);
                offset += 8;

                this.duelOpponentItemsCount = data[offset++] & 0xff;

                for (let i = 0; i < this.duelOpponentItemsCount; i++) {
                    this.duelOpponentItems[i] = Utility.getUnsignedShort(data, offset);
                    offset += 2;

                    this.duelOpponentItemCount[i] = Utility.getUnsignedInt(data, offset);
                    offset += 4;
                }

                this.duelItemsCount = data[offset++] & 0xff;

                for (let i = 0; i < this.duelItemsCount; i++) {
                    this.duelItems[i] = Utility.getUnsignedShort(data, offset);
                    offset += 2;

                    this.duelItemCount[i] = Utility.getUnsignedInt(data, offset);
                    offset += 4;
                }

                this.duelOptionRetreat = data[offset++] & 0xff;
                this.duelOptionMagic = data[offset++] & 0xff;
                this.duelOptionPrayer = data[offset++] & 0xff;
                this.duelOptionWeapons = data[offset++] & 0xff;
                return;
            }

            if (opcode === serverOpcodes.SOUND) {
                const soundName = fromCharArray(data.slice(1, size));
                this.playSoundFile(soundName);
                return;
            }

            if (opcode === serverOpcodes.TELEPORT_BUBBLE) {
                if (this.teleportBubbleCount < 50) {
                    const type = data[1] & 0xff;
                    const x = data[2] + this.localRegionX;
                    const y = data[3] + this.localRegionY;

                    this.teleportBubbleType[this.teleportBubbleCount] = type;
                    this.teleportBubbleTime[this.teleportBubbleCount] = 0;
                    this.teleportBubbleX[this.teleportBubbleCount] = x;
                    this.teleportBubbleY[this.teleportBubbleCount] = y;
                    this.teleportBubbleCount++;
                }

                return;
            }

            if (opcode === serverOpcodes.WELCOME) {
                if (!this.welcomScreenAlreadyShown) {
                    this.welcomeLastLoggedInIP = Utility.getUnsignedInt(data, 1);
                    this.welcomeLastLoggedInDays = Utility.getUnsignedShort(data, 5);
                    this.welcomeRecoverySetDays = data[7] & 0xff;
                    this.welcomeUnreadMessages = Utility.getUnsignedShort(data, 8);
                    this.showDialogWelcome = true;
                    this.welcomScreenAlreadyShown = true;
                    this.welcomeLastLoggedInHost = null;
                }

                return;
            }

            if (opcode === serverOpcodes.SYSTEM_UPDATE) {
                this.systemUpdate = Utility.getUnsignedShort(data, 1) * 32;
                return;
            }

            const handler = this.packetHandlers[opcode];

            if (handler) {
                handler(data, size);
            } else {
                //throw new Error(`unhandled packet opcode ${opcode}`);
            }
        } catch (e) {
            console.error(e);

            if (this.packetErrorCount < 3) {
                let errorMessage = e.stack;
                let messageLength = errorMessage.length;

                this.packetStream.newPacket(clientOpcodes.PACKET_EXCEPTION);
                this.packetStream.putShort(messageLength);
                this.packetStream.putString(errorMessage);
                this.packetStream.putShort(messageLength = (errorMessage = 'p-type: ' + opcode + ' p-size:' + size).length);
                this.packetStream.putString(errorMessage);
                this.packetStream.putShort(messageLength = (errorMessage = 'rx:' + this.localRegionX + ' ry:' + this.localRegionY + ' num3l:' + this.objectCount).length);
                this.packetStream.putString(errorMessage);

                errorMessage = '';

                for (let i = 0; i < 80 && i < size; i++) {
                    errorMessage = errorMessage + data[i] + ' ';
                }

                this.packetStream.putShort(errorMessage.length);
                this.packetStream.putString(errorMessage);
                this.packetStream.sendPacket();
                this.packetErrorCount++;
            }

            this.packetStream.closeStream();
            this.resetLoginVars();
        }
    }

    createRightClickMenu() {
        let i = 2203 - (this.localRegionY + this.planeHeight + this.regionY);

        if (this.localRegionX + this.planeWidth + this.regionX >= 2640) {
            i = -50;
        }

        let j = -1;

        for (let k = 0; k < this.objectCount; k++) {
            this.objectAlreadyInMenu[k] = false;
        }

        for (let l = 0; l < this.wallObjectCount; l++) {
            this.wallObjectAlreadyInMenu[l] = false;
        }

        let i1 = this.scene.getMousePickedCount();
        let objs = this.scene.getMousePickedModels();
        let plyrs = this.scene.getMousePickedFaces();

        for (let menuIdx = 0; menuIdx < i1; menuIdx++) {
            if (this.menuItemsCount > 200) {
                break;
            }

            let pid = plyrs[menuIdx];
            let gameModel = objs[menuIdx];

            if (gameModel.faceTag[pid] <= 65535 || gameModel.faceTag[pid] >= 200000 && gameModel.faceTag[pid] <= 300000)  {
                if (gameModel === this.scene.view) {
                    let idx = gameModel.faceTag[pid] % 10000;
                    const type = (gameModel.faceTag[pid] / 10000) | 0;

                    if (type === 1) {
                        let menuText = '';
                        let k3 = 0;

                        if (this.localPlayer.level > 0 && this.players[idx].level > 0) {
                            k3 = this.localPlayer.level - this.players[idx].level;
                        }

                        if (k3 < 0) {
                            menuText = '@or1@';
                        }

                        if (k3 < -3) {
                            menuText = '@or2@';
                        }

                        if (k3 < -6) {
                            menuText = '@or3@';
                        }

                        if (k3 < -9) {
                            menuText = '@red@';
                        }

                        if (k3 > 0) {
                            menuText = '@gr1@';
                        }

                        if (k3 > 3) {
                            menuText = '@gr2@';
                        }

                        if (k3 > 6) {
                            menuText = '@gr3@';
                        }

                        if (k3 > 9) {
                            menuText = '@gre@';
                        }

                        menuText = ' ' + menuText + '(level-' + this.players[idx].level + ')';

                        if (this.selectedSpell >= 0) {
                            if (GameData.spellType[this.selectedSpell] === 1 || GameData.spellType[this.selectedSpell] === 2) {
                                this.menuItemText1[this.menuItemsCount] = 'Cast ' + GameData.spellName[this.selectedSpell] + ' on';
                                this.menuItemText2[this.menuItemsCount] = '@whi@' + this.players[idx].name + menuText;
                                this.menuType[this.menuItemsCount] = 800;
                                this.menuItemX[this.menuItemsCount] = this.players[idx].currentX;
                                this.menuItemY[this.menuItemsCount] = this.players[idx].currentY;
                                this.menuIndex[this.menuItemsCount] = this.players[idx].serverIndex;
                                this.menuSourceIndex[this.menuItemsCount] = this.selectedSpell;
                                this.menuItemsCount++;
                            }
                        } else if (this.selectedItemInventoryIndex >= 0) {
                            this.menuItemText1[this.menuItemsCount] = 'Use ' + this.selectedItemName + ' with';
                            this.menuItemText2[this.menuItemsCount] = '@whi@' + this.players[idx].name + menuText;
                            this.menuType[this.menuItemsCount] = 810;
                            this.menuItemX[this.menuItemsCount] = this.players[idx].currentX;
                            this.menuItemY[this.menuItemsCount] = this.players[idx].currentY;
                            this.menuIndex[this.menuItemsCount] = this.players[idx].serverIndex;
                            this.menuSourceIndex[this.menuItemsCount] = this.selectedItemInventoryIndex;
                            this.menuItemsCount++;
                        } else {
                            if (i > 0 && (((this.players[idx].currentY - 64) / this.magicLoc + this.planeHeight + this.regionY) | 0) < 2203) {
                                this.menuItemText1[this.menuItemsCount] = 'Attack';
                                this.menuItemText2[this.menuItemsCount] = '@whi@' + this.players[idx].name + menuText;

                                if (k3 >= 0 && k3 < 5) {
                                    this.menuType[this.menuItemsCount] = 805;
                                } else {
                                    this.menuType[this.menuItemsCount] = 2805;
                                }

                                this.menuItemX[this.menuItemsCount] = this.players[idx].currentX;
                                this.menuItemY[this.menuItemsCount] = this.players[idx].currentY;
                                this.menuIndex[this.menuItemsCount] = this.players[idx].serverIndex;
                                this.menuItemsCount++;
                            } else if (this.members) {
                                this.menuItemText1[this.menuItemsCount] = 'Duel with';
                                this.menuItemText2[this.menuItemsCount] = '@whi@' + this.players[idx].name + menuText;
                                this.menuItemX[this.menuItemsCount] = this.players[idx].currentX;
                                this.menuItemY[this.menuItemsCount] = this.players[idx].currentY;
                                this.menuType[this.menuItemsCount] = 2806;
                                this.menuIndex[this.menuItemsCount] = this.players[idx].serverIndex;
                                this.menuItemsCount++;
                            }

                            this.menuItemText1[this.menuItemsCount] = 'Trade with';
                            this.menuItemText2[this.menuItemsCount] = '@whi@' + this.players[idx].name + menuText;
                            this.menuType[this.menuItemsCount] = 2810;
                            this.menuIndex[this.menuItemsCount] = this.players[idx].serverIndex;
                            this.menuItemsCount++;
                            this.menuItemText1[this.menuItemsCount] = 'Follow';
                            this.menuItemText2[this.menuItemsCount] = '@whi@' + this.players[idx].name + menuText;
                            this.menuType[this.menuItemsCount] = 2820;
                            this.menuIndex[this.menuItemsCount] = this.players[idx].serverIndex;
                            this.menuItemsCount++;
                        }
                    } else if (type === 2) {
                        if (this.selectedSpell >= 0) {
                            if (GameData.spellType[this.selectedSpell] === 3) {
                                this.menuItemText1[this.menuItemsCount] = 'Cast ' + GameData.spellName[this.selectedSpell] + ' on';
                                this.menuItemText2[this.menuItemsCount] = '@lre@' + GameData.itemName[this.groundItemID[idx]];
                                this.menuType[this.menuItemsCount] = 200;
                                this.menuItemX[this.menuItemsCount] = this.groundItemX[idx];
                                this.menuItemY[this.menuItemsCount] = this.groundItemY[idx];
                                this.menuIndex[this.menuItemsCount] = this.groundItemID[idx];
                                this.menuSourceIndex[this.menuItemsCount] = this.selectedSpell;
                                this.menuItemsCount++;
                            }
                        } else if (this.selectedItemInventoryIndex >= 0) {
                            this.menuItemText1[this.menuItemsCount] = 'Use ' + this.selectedItemName + ' with';
                            this.menuItemText2[this.menuItemsCount] = '@lre@' + GameData.itemName[this.groundItemID[idx]];
                            this.menuType[this.menuItemsCount] = 210;
                            this.menuItemX[this.menuItemsCount] = this.groundItemX[idx];
                            this.menuItemY[this.menuItemsCount] = this.groundItemY[idx];
                            this.menuIndex[this.menuItemsCount] = this.groundItemID[idx];
                            this.menuSourceIndex[this.menuItemsCount] = this.selectedItemInventoryIndex;
                            this.menuItemsCount++;
                        } else {
                            this.menuItemText1[this.menuItemsCount] = 'Take';
                            this.menuItemText2[this.menuItemsCount] = '@lre@' + GameData.itemName[this.groundItemID[idx]];
                            this.menuType[this.menuItemsCount] = 220;
                            this.menuItemX[this.menuItemsCount] = this.groundItemX[idx];
                            this.menuItemY[this.menuItemsCount] = this.groundItemY[idx];
                            this.menuIndex[this.menuItemsCount] = this.groundItemID[idx];
                            this.menuItemsCount++;
                            this.menuItemText1[this.menuItemsCount] = 'Examine';
                            this.menuItemText2[this.menuItemsCount] = '@lre@' + GameData.itemName[this.groundItemID[idx]];
                            this.menuType[this.menuItemsCount] = 3200;
                            this.menuIndex[this.menuItemsCount] = this.groundItemID[idx];
                            this.menuItemsCount++;
                        }
                    } else if (type === 3) {
                        let menuText = '';
                        let levelDiff = -1;
                        const id = this.npcs[idx].npcId;

                        if (GameData.npcAttackable[id] > 0) {
                            const npcLevel = ((GameData.npcAttack[id] + GameData.npcDefense[id] + GameData.npcStrength[id] + GameData.npcHits[id]) / 4) | 0;
                            const playerLevel = ((this.playerStatBase[0] + this.playerStatBase[1] + this.playerStatBase[2] + this.playerStatBase[3] + 27) / 4) | 0;

                            levelDiff = playerLevel - npcLevel;
                            menuText = '@yel@';

                            if (levelDiff < 0) {
                                menuText = '@or1@';
                            }

                            if (levelDiff < -3) {
                                menuText = '@or2@';
                            }

                            if (levelDiff < -6) {
                                menuText = '@or3@';
                            }

                            if (levelDiff < -9) {
                                menuText = '@red@';
                            }

                            if (levelDiff > 0) {
                                menuText = '@gr1@';
                            }

                            if (levelDiff > 3) {
                                menuText = '@gr2@';
                            }

                            if (levelDiff > 6) {
                                menuText = '@gr3@';
                            }

                            if (levelDiff > 9) {
                                menuText = '@gre@';
                            }

                            menuText = ' ' + menuText + '(level-' + npcLevel + ')';
                        }

                        if (this.selectedSpell >= 0) {
                            if (GameData.spellType[this.selectedSpell] === 2) {
                                this.menuItemText1[this.menuItemsCount] = 'Cast ' + GameData.spellName[this.selectedSpell] + ' on';
                                this.menuItemText2[this.menuItemsCount] = '@yel@' + GameData.npcName[this.npcs[idx].npcId];
                                this.menuType[this.menuItemsCount] = 700;
                                this.menuItemX[this.menuItemsCount] = this.npcs[idx].currentX;
                                this.menuItemY[this.menuItemsCount] = this.npcs[idx].currentY;
                                this.menuIndex[this.menuItemsCount] = this.npcs[idx].serverIndex;
                                this.menuSourceIndex[this.menuItemsCount] = this.selectedSpell;
                                this.menuItemsCount++;
                            }
                        } else if (this.selectedItemInventoryIndex >= 0) {
                            this.menuItemText1[this.menuItemsCount] = 'Use ' + this.selectedItemName + ' with';
                            this.menuItemText2[this.menuItemsCount] = '@yel@' + GameData.npcName[this.npcs[idx].npcId];
                            this.menuType[this.menuItemsCount] = 710;
                            this.menuItemX[this.menuItemsCount] = this.npcs[idx].currentX;
                            this.menuItemY[this.menuItemsCount] = this.npcs[idx].currentY;
                            this.menuIndex[this.menuItemsCount] = this.npcs[idx].serverIndex;
                            this.menuSourceIndex[this.menuItemsCount] = this.selectedItemInventoryIndex;
                            this.menuItemsCount++;
                        } else {
                            if (GameData.npcAttackable[id] > 0) {
                                this.menuItemText1[this.menuItemsCount] = 'Attack';
                                this.menuItemText2[this.menuItemsCount] = '@yel@' + GameData.npcName[this.npcs[idx].npcId] + menuText;

                                if (levelDiff >= 0) {
                                    this.menuType[this.menuItemsCount] = 715;
                                } else {
                                    this.menuType[this.menuItemsCount] = 2715;
                                }

                                this.menuItemX[this.menuItemsCount] = this.npcs[idx].currentX;
                                this.menuItemY[this.menuItemsCount] = this.npcs[idx].currentY;
                                this.menuIndex[this.menuItemsCount] = this.npcs[idx].serverIndex;
                                this.menuItemsCount++;
                            }

                            this.menuItemText1[this.menuItemsCount] = 'Talk-to';
                            this.menuItemText2[this.menuItemsCount] = '@yel@' + GameData.npcName[this.npcs[idx].npcId];
                            this.menuType[this.menuItemsCount] = 720;
                            this.menuItemX[this.menuItemsCount] = this.npcs[idx].currentX;
                            this.menuItemY[this.menuItemsCount] = this.npcs[idx].currentY;
                            this.menuIndex[this.menuItemsCount] = this.npcs[idx].serverIndex;
                            this.menuItemsCount++;

                            if (GameData.npcCommand[id] !== '') {
                                this.menuItemText1[this.menuItemsCount] = GameData.npcCommand[id];
                                this.menuItemText2[this.menuItemsCount] = '@yel@' + GameData.npcName[this.npcs[idx].npcId];
                                this.menuType[this.menuItemsCount] = 725;
                                this.menuItemX[this.menuItemsCount] = this.npcs[idx].currentX;
                                this.menuItemY[this.menuItemsCount] = this.npcs[idx].currentY;
                                this.menuIndex[this.menuItemsCount] = this.npcs[idx].serverIndex;
                                this.menuItemsCount++;
                            }

                            this.menuItemText1[this.menuItemsCount] = 'Examine';
                            this.menuItemText2[this.menuItemsCount] = '@yel@' + GameData.npcName[this.npcs[idx].npcId];
                            this.menuType[this.menuItemsCount] = 3700;
                            this.menuIndex[this.menuItemsCount] = this.npcs[idx].npcId;
                            this.menuItemsCount++;
                        }
                    }
                } else if (gameModel !== null && gameModel.key >= 10000) {
                    const index = gameModel.key - 10000;
                    const id = this.wallObjectId[index];

                    if (!this.wallObjectAlreadyInMenu[index]) {
                        if (this.selectedSpell >= 0) {
                            if (GameData.spellType[this.selectedSpell] === 4) {
                                this.menuItemText1[this.menuItemsCount] = 'Cast ' + GameData.spellName[this.selectedSpell] + ' on';
                                this.menuItemText2[this.menuItemsCount] = '@cya@' + GameData.wallObjectName[id];
                                this.menuType[this.menuItemsCount] = 300;
                                this.menuItemX[this.menuItemsCount] = this.wallObjectX[index];
                                this.menuItemY[this.menuItemsCount] = this.wallObjectY[index];
                                this.menuIndex[this.menuItemsCount] = this.wallObjectDirection[index];
                                this.menuSourceIndex[this.menuItemsCount] = this.selectedSpell;
                                this.menuItemsCount++;
                            }
                        } else if (this.selectedItemInventoryIndex >= 0) {
                            this.menuItemText1[this.menuItemsCount] = 'Use ' + this.selectedItemName + ' with';
                            this.menuItemText2[this.menuItemsCount] = '@cya@' + GameData.wallObjectName[id];
                            this.menuType[this.menuItemsCount] = 310;
                            this.menuItemX[this.menuItemsCount] = this.wallObjectX[index];
                            this.menuItemY[this.menuItemsCount] = this.wallObjectY[index];
                            this.menuIndex[this.menuItemsCount] = this.wallObjectDirection[index];
                            this.menuSourceIndex[this.menuItemsCount] = this.selectedItemInventoryIndex;
                            this.menuItemsCount++;
                        } else {
                            if (!/^WalkTo$/i.test(GameData.wallObjectCommand1[id])) {
                                this.menuItemText1[this.menuItemsCount] = GameData.wallObjectCommand1[id];
                                this.menuItemText2[this.menuItemsCount] = '@cya@' + GameData.wallObjectName[id];
                                this.menuType[this.menuItemsCount] = 320;
                                this.menuItemX[this.menuItemsCount] = this.wallObjectX[index];
                                this.menuItemY[this.menuItemsCount] = this.wallObjectY[index];
                                this.menuIndex[this.menuItemsCount] = this.wallObjectDirection[index];
                                this.menuItemsCount++;
                            }

                            if (!/^Examine$/i.test(GameData.wallObjectCommand2[id])) {
                                this.menuItemText1[this.menuItemsCount] = GameData.wallObjectCommand2[id];
                                this.menuItemText2[this.menuItemsCount] = '@cya@' + GameData.wallObjectName[id];
                                this.menuType[this.menuItemsCount] = 2300;
                                this.menuItemX[this.menuItemsCount] = this.wallObjectX[index];
                                this.menuItemY[this.menuItemsCount] = this.wallObjectY[index];
                                this.menuIndex[this.menuItemsCount] = this.wallObjectDirection[index];
                                this.menuItemsCount++;
                            }

                            this.menuItemText1[this.menuItemsCount] = 'Examine';
                            this.menuItemText2[this.menuItemsCount] = '@cya@' + GameData.wallObjectName[id];
                            this.menuType[this.menuItemsCount] = 3300;
                            this.menuIndex[this.menuItemsCount] = id;
                            this.menuItemsCount++;
                        }

                        this.wallObjectAlreadyInMenu[index] = true;
                    }
                } else if (gameModel !== null && gameModel.key >= 0) {
                    const index = gameModel.key;
                    const id = this.objectId[index];

                    if (!this.objectAlreadyInMenu[index]) {
                        if (this.selectedSpell >= 0) {
                            if (GameData.spellType[this.selectedSpell] === 5) {
                                this.menuItemText1[this.menuItemsCount] = 'Cast ' + GameData.spellName[this.selectedSpell] + ' on';
                                this.menuItemText2[this.menuItemsCount] = '@cya@' + GameData.objectName[id];
                                this.menuType[this.menuItemsCount] = 400;
                                this.menuItemX[this.menuItemsCount] = this.objectX[index];
                                this.menuItemY[this.menuItemsCount] = this.objectY[index];
                                this.menuIndex[this.menuItemsCount] = this.objectDirection[index];
                                this.menuSourceIndex[this.menuItemsCount] = this.objectId[index];
                                this.menuTargetIndex[this.menuItemsCount] = this.selectedSpell;
                                this.menuItemsCount++;
                            }
                        } else if (this.selectedItemInventoryIndex >= 0) {
                            this.menuItemText1[this.menuItemsCount] = 'Use ' + this.selectedItemName + ' with';
                            this.menuItemText2[this.menuItemsCount] = '@cya@' + GameData.objectName[id];
                            this.menuType[this.menuItemsCount] = 410;
                            this.menuItemX[this.menuItemsCount] = this.objectX[index];
                            this.menuItemY[this.menuItemsCount] = this.objectY[index];
                            this.menuIndex[this.menuItemsCount] = this.objectDirection[index];
                            this.menuSourceIndex[this.menuItemsCount] = this.objectId[index];
                            this.menuTargetIndex[this.menuItemsCount] = this.selectedItemInventoryIndex;
                            this.menuItemsCount++;
                        } else {
                            if (!/^WalkTo$/i.test(GameData.objectCommand1[id])) {
                                this.menuItemText1[this.menuItemsCount] = GameData.objectCommand1[id];
                                this.menuItemText2[this.menuItemsCount] = '@cya@' + GameData.objectName[id];
                                this.menuType[this.menuItemsCount] = 420;
                                this.menuItemX[this.menuItemsCount] = this.objectX[index];
                                this.menuItemY[this.menuItemsCount] = this.objectY[index];
                                this.menuIndex[this.menuItemsCount] = this.objectDirection[index];
                                this.menuSourceIndex[this.menuItemsCount] = this.objectId[index];
                                this.menuItemsCount++;
                            }

                            if (!/^Examine$/i.test(GameData.objectCommand2[id])) {
                                this.menuItemText1[this.menuItemsCount] = GameData.objectCommand2[id];
                                this.menuItemText2[this.menuItemsCount] = '@cya@' + GameData.objectName[id];
                                this.menuType[this.menuItemsCount] = 2400;
                                this.menuItemX[this.menuItemsCount] = this.objectX[index];
                                this.menuItemY[this.menuItemsCount] = this.objectY[index];
                                this.menuIndex[this.menuItemsCount] = this.objectDirection[index];
                                this.menuSourceIndex[this.menuItemsCount] = this.objectId[index];
                                this.menuItemsCount++;
                            }

                            this.menuItemText1[this.menuItemsCount] = 'Examine';
                            this.menuItemText2[this.menuItemsCount] = '@cya@' + GameData.objectName[id];
                            this.menuType[this.menuItemsCount] = 3400;
                            this.menuIndex[this.menuItemsCount] = id;
                            this.menuItemsCount++;
                        }

                        this.objectAlreadyInMenu[index] = true;
                    }
                } else {
                    if (pid >= 0) {
                        pid = gameModel.faceTag[pid] - 200000;
                    }

                    if (pid >= 0) {
                        j = pid;
                    }
                }
            }
        }

        if (this.selectedSpell >= 0 && GameData.spellType[this.selectedSpell] <= 1) {
            this.menuItemText1[this.menuItemsCount] = 'Cast ' + GameData.spellName[this.selectedSpell] + ' on self';
            this.menuItemText2[this.menuItemsCount] = '';
            this.menuType[this.menuItemsCount] = 1000;
            this.menuIndex[this.menuItemsCount] = this.selectedSpell;
            this.menuItemsCount++;
        }

        if (j !== -1) {
            if (this.selectedSpell >= 0) {
                if (GameData.spellType[this.selectedSpell] === 6) {
                    this.menuItemText1[this.menuItemsCount] = 'Cast ' + GameData.spellName[this.selectedSpell] + ' on ground';
                    this.menuItemText2[this.menuItemsCount] = '';
                    this.menuType[this.menuItemsCount] = 900;
                    this.menuItemX[this.menuItemsCount] = this.world.localX[j];
                    this.menuItemY[this.menuItemsCount] = this.world.localY[j];
                    this.menuIndex[this.menuItemsCount] = this.selectedSpell;
                    this.menuItemsCount++;
                    return;
                }
            } else if (this.selectedItemInventoryIndex < 0) {
                this.menuItemText1[this.menuItemsCount] = 'Walk here';
                this.menuItemText2[this.menuItemsCount] = '';
                this.menuType[this.menuItemsCount] = 920;
                this.menuItemX[this.menuItemsCount] = this.world.localX[j];
                this.menuItemY[this.menuItemsCount] = this.world.localY[j];
                this.menuItemsCount++;
            }
        }
    }

    async handleInputs() {
        if (this.errorLoadingCodebase || this.errorLoadingMemory ||
            this.errorLoadingData) {
            return;
        }

        try {
            this.loginTimer++;

            if (this.loggedIn === 0) {
                this.mouseActionTimeout = 0;
                await this.handleLoginScreenInput();
            } else if (this.loggedIn === 1) {
                this.mouseActionTimeout++;
                await this.handleGameInput();
            }

            this.lastMouseButtonDown = 0;
            this.cameraRotationTime++;

            if (this.cameraRotationTime > 500) {
                this.cameraRotationTime = 0;

                const roll = (Math.random() * 4) | 0;

                if ((roll & 1) === 1) {
                    this.cameraRotationX += this.cameraRotationXIncrement;
                }

                if ((roll & 2) === 2) {
                    this.cameraRotationY += this.cameraRotationYIncrement;
                }
            }

            if (this.cameraRotationX < -50) {
                this.cameraRotationXIncrement = 2;
            } else if (this.cameraRotationX > 50) {
                this.cameraRotationXIncrement = -2;
            }

            if (this.cameraRotationY < -50) {
                this.cameraRotationYIncrement = 2;
            } else if (this.cameraRotationY > 50) {
                this.cameraRotationYIncrement = -2;
            }

            if (this.messageTabFlashAll > 0) {
                this.messageTabFlashAll--;
            }

            if (this.messageTabFlashHistory > 0) {
                this.messageTabFlashHistory--;
            }

            if (this.messageTabFlashQuest > 0) {
                this.messageTabFlashQuest--;
            }

            if (this.messageTabFlashPrivate > 0) {
                this.messageTabFlashPrivate--;
                return;
            }
        } catch (e) {
            // OutOfMemory
            console.error(e);
            this.disposeAndCollect();
            this.errorLoadingMemory = true;
        }
    }

    async loadMaps() {
        this.world.mapPack = await this.readDataFile(
            `maps${version.MAPS}.jag`,
            'map',
            70
        );

        if (this.members) {
            this.world.memberMapPack = await this.readDataFile(
                `maps${version.MAPS}.mem`,
                'members map',
                75
            );
        }

        this.world.landscapePack = await this.readDataFile(
            `land${version.MAPS}.jag`,
            'landscape',
            80
        );

        if (this.members) {
            this.world.memberLandscapePack = await this.readDataFile(
                `land${version.MAPS}.mem`,
                'members landscape',
                85
            );
        }
    }

    createModel(x, y, direction, id, count) {
        let x1 = x;
        let y1 = y;
        let x2 = x;
        let y2 = y;

        const frontTexture = GameData.wallObjectTextureFront[id];
        const backTexture = GameData.wallObjectTextureBack[id];
        const height = GameData.wallObjectHeight[id];
        const gameModel = GameModel._from2(4, 1);

        if (direction === 0) {
            x2 = x + 1;
        } else if (direction === 1) {
            y2 = y + 1;
        } else if (direction === 2) {
            x1 = x + 1;
            y2 = y + 1;
        } else if (direction === 3) {
            x2 = x + 1;
            y2 = y + 1;
        }

        x1 *= this.magicLoc;
        y1 *= this.magicLoc;
        x2 *= this.magicLoc;
        y2 *= this.magicLoc;

        const vertices = new Int32Array([
            gameModel.vertexAt(x1, -this.world.getElevation(x1, y1), y1),
            gameModel.vertexAt(x1, -this.world.getElevation(x1, y1) - height, y1),
            gameModel.vertexAt(x2, -this.world.getElevation(x2, y2) - height, y2),
            gameModel.vertexAt(x2, -this.world.getElevation(x2, y2), y2)
        ]);

        gameModel.createFace(4, vertices, frontTexture, backTexture);
        gameModel._setLight_from6(false, 60, 24, -50, -10, -50);

        if (x >= 0 && y >= 0 && x < 96 && y < 96) {
            this.scene.addModel(gameModel);
        }

        gameModel.key = count + 10000;

        return gameModel;
    }
}

module.exports = mudclient;

},{"./chat-message":40,"./game-buffer":41,"./game-character":42,"./game-connection":43,"./game-data":44,"./game-model":45,"./lib/graphics/color":47,"./lib/graphics/font":48,"./lib/keycodes":50,"./opcodes/client":54,"./opcodes/server":55,"./packet-handlers":56,"./panel":69,"./scene":72,"./stream-audio-player":73,"./surface":74,"./ui":79,"./utility":100,"./version":101,"./word-filter":102,"./world":103,"long":33}],54:[function(require,module,exports){
module.exports={
    "APPEARANCE": 235,
    "BANK_CLOSE": 212,
    "BANK_DEPOSIT": 23,
    "BANK_WITHDRAW": 22,
    "CAST_GROUND": 158,
    "CAST_GROUNDITEM": 249,
    "CAST_INVITEM": 4,
    "CAST_NPC": 50,
    "CAST_OBJECT": 99,
    "CAST_PLAYER": 229,
    "CAST_SELF": 137,
    "CAST_WALLOBJECT": 180,
    "CHANGE_PASSWORD": 25,
    "CHAT": 216,
    "CHOOSE_OPTION": 116,
    "CLOSE_CONNECTION": 31,
    "COMBAT_STYLE": 29,
    "COMMAND": 38,
    "DUEL_ACCEPT": 176,
    "DUEL_CONFIRM_ACCEPT": 77,
    "DUEL_DECLINE": 197,
    "DUEL_ITEM_UPDATE": 33,
    "DUEL_SETTINGS": 8,
    "FRIEND_ADD": 195,
    "FRIEND_REMOVE": 167,
    "GROUNDITEM_TAKE": 247,
    "IGNORE_ADD": 132,
    "IGNORE_REMOVE": 241,
    "INV_CMD": 90,
    "INV_DROP": 246,
    "INV_UNEQUIP": 170,
    "INV_WEAR": 169,
    "KNOWN_PLAYERS": 163,
    "LOGIN": 0,
    "LOGOUT": 102,
    "NPC_ATTACK": 190,
    "NPC_CMD": 202,
    "NPC_TALK": 153,
    "OBJECT_CMD1": 136,
    "OBJECT_CMD2": 79,
    "PACKET_EXCEPTION": 3,
    "PING": 67,
    "PLAYER_ATTACK": 171,
    "PLAYER_DUEL": 103,
    "PLAYER_FOLLOW": 165,
    "PLAYER_TRADE": 142,
    "PM": 218,
    "PRAYER_OFF": 254,
    "PRAYER_ON": 60,
    "RECOVER_CANCEL": 196,
    "RECOVER_GET_QUESTIONS": 233,
    "RECOVER_REQUEST": 220,
    "RECOVER_SET": 208,
    "RECOVER_SET_REQUEST": 203,
    "REGISTER": 2,
    "REPORT_ABUSE": 206,
    "SESSION": 32,
    "SETTINGS_GAME": 111,
    "SETTINGS_PRIVACY": 64,
    "SHOP_BUY": 236,
    "SHOP_CLOSE": 166,
    "SHOP_SELL": 221,
    "SLEEP_WORD": 45,
    "TRADE_ACCEPT": 55,
    "TRADE_CONFIRM_ACCEPT": 104,
    "TRADE_DECLINE": 230,
    "TRADE_ITEM_UPDATE": 46,
    "USEWITH_GROUNDITEM": 53,
    "USEWITH_INVITEM": 91,
    "USEWITH_NPC": 135,
    "USEWITH_OBJECT": 115,
    "USEWITH_PLAYER": 113,
    "USEWITH_WALLOBJECT": 161,
    "WALK": 187,
    "WALK_ACTION": 16,
    "WALL_OBJECT_COMMAND1": 14,
    "WALL_OBJECT_COMMAND2": 127
}


},{}],55:[function(require,module,exports){
module.exports={
    "APPEARANCE": 59,
    "BANK_CLOSE": 203,
    "BANK_OPEN": 42,
    "BANK_UPDATE": 249,
    "CLOSE_CONNECTION": 4,
    "DUEL_ACCEPTED": 210,
    "DUEL_CLOSE": 225,
    "DUEL_CONFIRM_OPEN": 172,
    "DUEL_OPEN": 176,
    "DUEL_OPPONENT_ACCEPTED": 253,
    "DUEL_SETTINGS": 30,
    "DUEL_UPDATE": 6,
    "FRIEND_LIST": 71,
    "FRIEND_MESSAGE": 120,
    "FRIEND_STATUS_CHANGE": 149,
    "GAME_SETTINGS": 240,
    "IGNORE_LIST": 109,
    "INVENTORY_ITEMS": 53,
    "INVENTORY_ITEM_REMOVE": 123,
    "INVENTORY_ITEM_UPDATE": 90,
    "LOGOUT_DENY": 183,
    "MESSAGE": 131,
    "OPTION_LIST": 245,
    "OPTION_LIST_CLOSE": 252,
    "PLAYER_DIED": 83,
    "PLAYER_QUEST_LIST": 5,
    "PLAYER_STAT_EQUIPMENT_BONUS": 153,
    "PLAYER_STAT_EXPERIENCE_UPDATE": 33,
    "PLAYER_STAT_FATIGUE": 114,
    "PLAYER_STAT_FATIGUE_ASLEEP": 244,
    "PLAYER_STAT_LIST": 156,
    "PLAYER_STAT_UPDATE": 159,
    "PRAYER_STATUS": 206,
    "PRIVACY_SETTINGS": 51,
    "REGION_ENTITY_UPDATE": 211,
    "REGION_GROUND_ITEMS": 99,
    "REGION_NPCS": 79,
    "REGION_NPC_UPDATE": 104,
    "REGION_OBJECTS": 48,
    "REGION_PLAYERS": 191,
    "REGION_PLAYER_UPDATE": 234,
    "REGION_WALL_OBJECTS": 91,
    "SERVER_MESSAGE": 89,
    "SERVER_MESSAGE_ONTOP": 222,
    "SHOP_CLOSE": 137,
    "SHOP_OPEN": 101,
    "SLEEP_CLOSE": 84,
    "SLEEP_INCORRECT": 194,
    "SLEEP_OPEN": 117,
    "SOUND": 204,
    "SYSTEM_UPDATE": 52,
    "TELEPORT_BUBBLE": 36,
    "TRADE_CLOSE": 128,
    "TRADE_CONFIRM_OPEN": 20,
    "TRADE_ITEMS": 97,
    "TRADE_OPEN": 92,
    "TRADE_RECIPIENT_STATUS": 162,
    "TRADE_STATUS": 15,
    "WELCOME": 182,
    "WORLD_INFO": 25
}
},{}],56:[function(require,module,exports){


function getPacketHandlers(mudclient) {
    const handlers = (function () {var f = require("./index.js");f["index"]=require("./index.js");f["inventory"]=require("./inventory.js");f["messages"]=require("./messages.js");f["option-list"]=require("./option-list.js");f["player-stats"]=require("./player-stats.js");f["region-ground-items"]=require("./region-ground-items.js");f["region-npcs"]=require("./region-npcs.js");f["region-objects"]=require("./region-objects.js");f["region-players"]=require("./region-players.js");f["settings"]=require("./settings.js");f["sleep"]=require("./sleep.js");f["social"]=require("./social.js");return f;})();
    const packetMap = {};

    for (const [handlerName, handlerMap] of Object.entries(handlers)) {
        if (/^_|index/.test(handlerName)) {
            continue;
        }

        for (const [id, handler] of Object.entries(handlerMap)) {
            packetMap[id] = handler.bind(mudclient);
        }
    }

    return packetMap;
}

module.exports = getPacketHandlers;

},{"./index.js":56,"./inventory.js":57,"./messages.js":58,"./option-list.js":59,"./player-stats.js":60,"./region-ground-items.js":61,"./region-npcs.js":62,"./region-objects.js":63,"./region-players.js":64,"./settings.js":65,"./sleep.js":66,"./social.js":67}],57:[function(require,module,exports){
const GameData = require('../game-data');
const Utility = require('../utility');
const serverOpcodes = require('../opcodes/server');

const handlers = {
    [serverOpcodes.INVENTORY_ITEMS]: function (data) {
        let offset = 1;

        this.inventoryItemsCount = data[offset++] & 0xff;

        for (let i = 0; i < this.inventoryItemsCount; i++) {
            const idEquip = Utility.getUnsignedShort(data, offset);
            offset += 2;

            this.inventoryItemId[i] = idEquip & 32767;
            this.inventoryEquipped[i] = (idEquip / 32768) | 0;

            if (GameData.itemStackable[idEquip & 32767] === 0) {
                this.inventoryItemStackCount[i] = Utility.getStackInt(
                    data,
                    offset
                );

                if (this.inventoryItemStackCount[i] >= 128) {
                    offset += 4;
                } else {
                    offset++;
                }
            } else {
                this.inventoryItemStackCount[i] = 1;
            }
        }
    },
    [serverOpcodes.INVENTORY_ITEM_UPDATE]: function (data) {
        let offset = 1;
        let stack = 1;

        const index = data[offset++] & 0xff;

        const id = Utility.getUnsignedShort(data, offset);
        offset += 2;

        if (GameData.itemStackable[id & 32767] === 0) {
            stack = Utility.getStackInt(data, offset);

            if (stack >= 128) {
                offset += 4;
            } else {
                offset++;
            }
        }

        this.inventoryItemId[index] = id & 32767;
        this.inventoryEquipped[index] = (id / 32768) | 0;
        this.inventoryItemStackCount[index] = stack;

        if (index >= this.inventoryItemsCount) {
            this.inventoryItemsCount = index + 1;
        }
    },
    [serverOpcodes.INVENTORY_ITEM_REMOVE]: function (data) {
        const index = data[1] & 0xff;

        this.inventoryItemsCount--;

        for (let i = index; i < this.inventoryItemsCount; i++) {
            this.inventoryItemId[i] = this.inventoryItemId[i + 1];

            this.inventoryItemStackCount[i] = this.inventoryItemStackCount[
                i + 1
            ];

            this.inventoryEquipped[i] = this.inventoryEquipped[i + 1];
        }
    }
};

module.exports = handlers;

},{"../game-data":44,"../opcodes/server":55,"../utility":100}],58:[function(require,module,exports){
const serverOpcodes = require('../opcodes/server');

function fromCharArray(a) {
    return Array.from(a)
        .map((c) => String.fromCharCode(c))
        .join('');
}

const handlers = {
    [serverOpcodes.MESSAGE]: function (data, size) {
        const message = fromCharArray(data.slice(1, size));
        this.showServerMessage(message);
    },
    [serverOpcodes.SERVER_MESSAGE]: function (data, size) {
        this.serverMessage = fromCharArray(data.slice(1, size));
        this.showDialogServerMessage = true;
        this.serverMessageBoxTop = false;
    },
    [serverOpcodes.SERVER_MESSAGE_ONTOP]: function (data, size) {
        this.serverMessage = fromCharArray(data.slice(1, size));
        this.showDialogServerMessage = true;
        this.serverMessageBoxTop = true;
    }
};

module.exports = handlers;

},{"../opcodes/server":55}],59:[function(require,module,exports){
const Utility = require('../utility');
const serverOpcodes = require('../opcodes/server');

function fromCharArray(a) {
    return Array.from(a).map(c => String.fromCharCode(c)).join('');
}

const handlers = {
    [serverOpcodes.OPTION_LIST]: function (data) {
        this.showOptionMenu = true;

        const count = Utility.getUnsignedByte(data[1]);
        this.optionMenuCount = count;

        let offset = 2;

        for (let i = 0; i < count; i++) {
            const entryLength = Utility.getUnsignedByte(data[offset++]);

            this.optionMenuEntry[i] = fromCharArray(
                data.slice(offset, offset + entryLength)
            );

            offset += entryLength;
        }
    },
    [serverOpcodes.OPTION_LIST_CLOSE]: function () {
        this.showOptionMenu = false;
    }
};

module.exports = handlers;

},{"../opcodes/server":55,"../utility":100}],60:[function(require,module,exports){
const Utility = require('../utility');
const serverOpcodes = require('../opcodes/server');

const handlers = {
    [serverOpcodes.PLAYER_STAT_LIST]: function (data) {
        let offset = 1;

        for (let i = 0; i < this.playerStatCurrent.length; i++) {
            this.playerStatCurrent[i] = Utility.getUnsignedByte(data[offset++]);
        }

        for (let i = 0; i < this.playerStatBase.length; i++) {
            this.playerStatBase[i] = Utility.getUnsignedByte(data[offset++]);
        }

        for (let i = 0; i < this.playerExperience.length; i++) {
            this.playerExperience[i] = Utility.getUnsignedInt(data, offset);
            offset += 4;
        }

        this.playerQuestPoints = Utility.getUnsignedByte(data[offset++]);
    },
    [serverOpcodes.PLAYER_STAT_EQUIPMENT_BONUS]: function (data) {
        for (let i = 0; i < this.playerStatEquipment.length; i++) {
            this.playerStatEquipment[i] = Utility.getUnsignedByte(data[1 + i]);
        }
    },
    [serverOpcodes.PLAYER_STAT_EXPERIENCE_UPDATE]: function (data) {
        const skillIndex = data[1] & 0xff;
        this.playerExperience[skillIndex] = Utility.getUnsignedInt(data, 2);
    },
    [serverOpcodes.PLAYER_STAT_UPDATE]: function (data) {
        let offset = 1;

        const skillIndex = data[offset++] & 0xff;

        this.playerStatCurrent[skillIndex] = Utility.getUnsignedByte(
            data[offset++]
        );

        this.playerStatBase[skillIndex] = Utility.getUnsignedByte(
            data[offset++]
        );

        this.playerExperience[skillIndex] = Utility.getUnsignedInt(
            data,
            offset
        );

        // TODO probably don't need this
        offset += 4;
    },
    [serverOpcodes.PLAYER_STAT_FATIGUE]: function (data) {
        this.statFatigue = Utility.getUnsignedShort(data, 1);
    },
    [serverOpcodes.PLAYER_QUEST_LIST]: function (data) {
        for (let i = 0; i < this.questComplete.length; i++) {
            this.questComplete[i] = !!data[i + 1];
        }
    }
};

module.exports = handlers;

},{"../opcodes/server":55,"../utility":100}],61:[function(require,module,exports){
const GameData = require('../game-data');
const Utility = require('../utility');
const serverOpcodes = require('../opcodes/server');

const handlers = {
    [serverOpcodes.REGION_GROUND_ITEMS]: function (data, size) {
        for (let offset = 1; offset < size; ) {
            if (Utility.getUnsignedByte(data[offset]) === 255) {
                let itemIndex = 0;
                const j14 = (this.localRegionX + data[offset + 1]) >> 3;
                const i19 = (this.localRegionY + data[offset + 2]) >> 3;

                offset += 3;

                for (let i = 0; i < this.groundItemCount; i++) {
                    const j26 = (this.groundItemX[i] >> 3) - j14;
                    const j29 = (this.groundItemY[i] >> 3) - i19;

                    if (j26 !== 0 || j29 !== 0) {
                        if (i !== itemIndex) {
                            this.groundItemX[itemIndex] = this.groundItemX[i];
                            this.groundItemY[itemIndex] = this.groundItemY[i];
                            this.groundItemID[itemIndex] = this.groundItemID[i];
                            this.groundItemZ[itemIndex] = this.groundItemZ[i];
                        }

                        itemIndex++;
                    }
                }

                this.groundItemCount = itemIndex;
            } else {
                let itemID = Utility.getUnsignedShort(data, offset);
                offset += 2;

                const areaX = this.localRegionX + data[offset++];
                const areaY = this.localRegionY + data[offset++];

                if ((itemID & 32768) === 0) {
                    this.groundItemX[this.groundItemCount] = areaX;
                    this.groundItemY[this.groundItemCount] = areaY;
                    this.groundItemID[this.groundItemCount] = itemID;
                    this.groundItemZ[this.groundItemCount] = 0;

                    for (let i = 0; i < this.objectCount; i++) {
                        if (
                            this.objectX[i] !== areaX ||
                            this.objectY[i] !== areaY
                        ) {
                            continue;
                        }

                        this.groundItemZ[this.groundItemCount] =
                            GameData.objectElevation[this.objectId[i]];

                        break;
                    }

                    this.groundItemCount++;
                } else {
                    itemID &= 32767;

                    let itemIndex = 0;

                    for (let i = 0; i < this.groundItemCount; i++) {
                        if (
                            this.groundItemX[i] !== areaX ||
                            this.groundItemY[i] !== areaY ||
                            this.groundItemID[i] !== itemID
                        ) {
                            if (i !== itemIndex) {
                                this.groundItemX[itemIndex] = this.groundItemX[
                                    i
                                ];

                                this.groundItemY[itemIndex] = this.groundItemY[
                                    i
                                ];

                                this.groundItemID[
                                    itemIndex
                                ] = this.groundItemID[i];

                                this.groundItemZ[itemIndex] = this.groundItemZ[
                                    i
                                ];
                            }

                            itemIndex++;
                        } else {
                            itemID = -123;
                        }
                    }

                    this.groundItemCount = itemIndex;
                }
            }
        }
    }
};

module.exports = handlers;

},{"../game-data":44,"../opcodes/server":55,"../utility":100}],62:[function(require,module,exports){
const Utility = require('../utility');
const GameData = require('../game-data');
const serverOpcodes = require('../opcodes/server');

const handlers = {
    [serverOpcodes.REGION_NPCS]: function (data, size) {
        this.npcCacheCount = this.npcCount;
        this.npcCount = 0;

        for (let i = 0; i < this.npcCacheCount; i++) {
            this.npcsCache[i] = this.npcs[i];
        }

        let offset = 8;

        const length = Utility.getBitMask(data, offset, 8);
        offset += 8;

        for (let i = 0; i < length; i++) {
            const npc = this.npcsCache[i];
            const hasUpdated = Utility.getBitMask(data, offset, 1);
            offset++;

            if (hasUpdated !== 0) {
                const hasMoved = Utility.getBitMask(data, offset, 1);
                offset++;

                if (hasMoved === 0) {
                    const sprite = Utility.getBitMask(data, offset, 3);
                    offset += 3;

                    let waypointCurrent = npc.waypointCurrent;
                    let npcX = npc.waypointsX[waypointCurrent];
                    let npcY = npc.waypointsY[waypointCurrent];

                    if (sprite === 2 || sprite === 1 || sprite === 3) {
                        npcX += this.magicLoc;
                    }

                    if (sprite === 6 || sprite === 5 || sprite === 7) {
                        npcX -= this.magicLoc;
                    }

                    if (sprite === 4 || sprite === 3 || sprite === 5) {
                        npcY += this.magicLoc;
                    }

                    if (sprite === 0 || sprite === 1 || sprite === 7) {
                        npcY -= this.magicLoc;
                    }

                    npc.animationNext = sprite;

                    npc.waypointCurrent = waypointCurrent =
                        (waypointCurrent + 1) % 10;

                    npc.waypointsX[waypointCurrent] = npcX;
                    npc.waypointsY[waypointCurrent] = npcY;
                } else {
                    const sprite = Utility.getBitMask(data, offset, 4);

                    if ((sprite & 12) === 12) {
                        offset += 2;
                        continue;
                    }

                    npc.animationNext = Utility.getBitMask(data, offset, 4);
                    offset += 4;
                }
            }

            this.npcs[this.npcCount++] = npc;
        }

        while (offset + 34 < size * 8) {
            const serverIndex = Utility.getBitMask(data, offset, 12);
            offset += 12;

            let areaX = Utility.getBitMask(data, offset, 5);
            offset += 5;

            if (areaX > 15) {
                areaX -= 32;
            }

            let areaY = Utility.getBitMask(data, offset, 5);
            offset += 5;

            if (areaY > 15) {
                areaY -= 32;
            }

            const sprite = Utility.getBitMask(data, offset, 4);
            offset += 4;

            const x = (this.localRegionX + areaX) * this.magicLoc + 64;
            const y = (this.localRegionY + areaY) * this.magicLoc + 64;

            let npcID = Utility.getBitMask(data, offset, 10);
            offset += 10;

            if (npcID >= GameData.npcCount) {
                npcID = 24;
            }

            this.addNpc(serverIndex, x, y, sprite, npcID);
        }
    }
};

module.exports = handlers;

},{"../game-data":44,"../opcodes/server":55,"../utility":100}],63:[function(require,module,exports){
const Utility = require('../utility');
const GameData = require('../game-data');
const serverOpcodes = require('../opcodes/server');

const handlers = {
    [serverOpcodes.REGION_OBJECTS]: function (data, size) {
        for (let offset = 1; offset < size; ) {
            if (Utility.getUnsignedByte(data[offset]) === 255) {
                let objectIndex = 0;
                const l14 = (this.localRegionX + data[offset + 1]) >> 3;
                const k19 = (this.localRegionY + data[offset + 2]) >> 3;

                offset += 3;

                for (let i = 0; i < this.objectCount; i++) {
                    const l26 = (this.objectX[i] >> 3) - l14;
                    const k29 = (this.objectY[i] >> 3) - k19;

                    if (l26 !== 0 || k29 !== 0) {
                        if (i !== objectIndex) {
                            this.objectModel[objectIndex] = this.objectModel[i];
                            this.objectModel[objectIndex].key = objectIndex;
                            this.objectX[objectIndex] = this.objectX[i];
                            this.objectY[objectIndex] = this.objectY[i];
                            this.objectId[objectIndex] = this.objectId[i];

                            this.objectDirection[
                                objectIndex
                            ] = this.objectDirection[i];
                        }

                        objectIndex++;
                    } else {
                        this.scene.removeModel(this.objectModel[i]);

                        this.world.removeObject(
                            this.objectX[i],
                            this.objectY[i],
                            this.objectId[i]
                        );
                    }
                }

                this.objectCount = objectIndex;
            } else {
                const objectID = Utility.getUnsignedShort(data, offset);
                offset += 2;

                const areaX = this.localRegionX + data[offset++];
                const areaY = this.localRegionY + data[offset++];
                let objectIndex = 0;

                for (let i = 0; i < this.objectCount; i++) {
                    if (
                        this.objectX[i] !== areaX ||
                        this.objectY[i] !== areaY
                    ) {
                        if (i !== objectIndex) {
                            this.objectModel[objectIndex] = this.objectModel[i];
                            this.objectModel[objectIndex].key = objectIndex;
                            this.objectX[objectIndex] = this.objectX[i];
                            this.objectY[objectIndex] = this.objectY[i];
                            this.objectId[objectIndex] = this.objectId[i];

                            this.objectDirection[
                                objectIndex
                            ] = this.objectDirection[i];
                        }

                        objectIndex++;
                    } else {
                        this.scene.removeModel(this.objectModel[i]);
                        this.world.removeObject(
                            this.objectX[i],
                            this.objectY[i],
                            this.objectId[i]
                        );
                    }
                }

                this.objectCount = objectIndex;

                if (objectID !== 60000) {
                    const direction = this.world.getTileDirection(areaX, areaY);
                    let width = 0;
                    let height = 0;

                    if (direction === 0 || direction === 4) {
                        width = GameData.objectWidth[objectID];
                        height = GameData.objectHeight[objectID];
                    } else {
                        height = GameData.objectWidth[objectID];
                        width = GameData.objectHeight[objectID];
                    }

                    const modelX =
                        (((areaX + areaX + width) * this.magicLoc) / 2) | 0;

                    const modelY =
                        (((areaY + areaY + height) * this.magicLoc) / 2) | 0;

                    const modelIndex = GameData.objectModelIndex[objectID];
                    const model = this.gameModels[modelIndex].copy();

                    this.scene.addModel(model);

                    model.key = this.objectCount;
                    model.rotate(0, direction * 32, 0);

                    model.translate(
                        modelX,
                        -this.world.getElevation(modelX, modelY),
                        modelY
                    );

                    model._setLight_from6(true, 48, 48, -50, -10, -50);

                    this.world.removeObject2(areaX, areaY, objectID);

                    if (objectID === 74) {
                        model.translate(0, -480, 0);
                    }

                    this.objectX[this.objectCount] = areaX;
                    this.objectY[this.objectCount] = areaY;
                    this.objectId[this.objectCount] = objectID;
                    this.objectDirection[this.objectCount] = direction;
                    this.objectModel[this.objectCount++] = model;
                }
            }
        }
    }
};

module.exports = handlers;

},{"../game-data":44,"../opcodes/server":55,"../utility":100}],64:[function(require,module,exports){
const Utility = require('../utility');
const clientOpcodes = require('../opcodes/client');
const serverOpcodes = require('../opcodes/server');

const handlers = {
    [serverOpcodes.REGION_PLAYERS]: function (data, size) {
        this.knownPlayerCount = this.playerCount;

        for (let i = 0; i < this.knownPlayerCount; i++) {
            this.knownPlayers[i] = this.players[i];
        }

        let offset = 8;

        this.localRegionX = Utility.getBitMask(data, offset, 11);
        offset += 11;

        this.localRegionY = Utility.getBitMask(data, offset, 13);
        offset += 13;

        const sprite = Utility.getBitMask(data, offset, 4);
        offset += 4;

        const hasLoadedRegion = this.loadNextRegion(
            this.localRegionX,
            this.localRegionY
        );

        this.localRegionX -= this.regionX;
        this.localRegionY -= this.regionY;

        const playerX = this.localRegionX * this.magicLoc + 64;
        const playerY = this.localRegionY * this.magicLoc + 64;

        if (hasLoadedRegion) {
            this.localPlayer.waypointCurrent = 0;
            this.localPlayer.movingStep = 0;
            this.localPlayer.currentX = this.localPlayer.waypointsX[0] = playerX;
            this.localPlayer.currentY = this.localPlayer.waypointsY[0] = playerY;
        }

        this.playerCount = 0;

        this.localPlayer = this.createPlayer(
            this.localPlayerServerIndex,
            playerX,
            playerY,
            sprite
        );

        const length = Utility.getBitMask(data, offset, 8);
        offset += 8;

        for (let i = 0; i < length; i++) {
            const player = this.knownPlayers[i + 1];
            const hasUpdated = Utility.getBitMask(data, offset, 1);

            offset++;

            if (hasUpdated !== 0) {
                const updateType = Utility.getBitMask(data, offset, 1);
                offset++;

                if (updateType === 0) {
                    const sprite = Utility.getBitMask(data, offset, 3);
                    offset += 3;

                    let waypointCurrent = player.waypointCurrent;
                    let playerX = player.waypointsX[waypointCurrent];
                    let playerY = player.waypointsY[waypointCurrent];

                    if (sprite === 2 || sprite === 1 || sprite === 3) {
                        playerX += this.magicLoc;
                    }

                    if (sprite === 6 || sprite === 5 || sprite === 7) {
                        playerX -= this.magicLoc;
                    }

                    if (sprite === 4 || sprite === 3 || sprite === 5) {
                        playerY += this.magicLoc;
                    }

                    if (sprite === 0 || sprite === 1 || sprite === 7) {
                        playerY -= this.magicLoc;
                    }

                    player.animationNext = sprite;

                    player.waypointCurrent = waypointCurrent =
                        (waypointCurrent + 1) % 10;

                    player.waypointsX[waypointCurrent] = playerX;
                    player.waypointsY[waypointCurrent] = playerY;
                } else {
                    const sprite = Utility.getBitMask(data, offset, 4);

                    if ((sprite & 12) === 12) {
                        offset += 2;
                        continue;
                    }

                    player.animationNext = Utility.getBitMask(data, offset, 4);
                    offset += 4;
                }
            }

            this.players[this.playerCount++] = player;
        }

        let playerCount = 0;

        while (offset + 24 < size * 8) {
            const serverIndex = Utility.getBitMask(data, offset, 11);
            offset += 11;

            let areaX = Utility.getBitMask(data, offset, 5);
            offset += 5;

            if (areaX > 15) {
                areaX -= 32;
            }

            let areaY = Utility.getBitMask(data, offset, 5);
            offset += 5;

            if (areaY > 15) {
                areaY -= 32;
            }

            const sprite = Utility.getBitMask(data, offset, 4);
            offset += 4;

            const isPlayerKnown = Utility.getBitMask(data, offset, 1);
            offset++;

            const x = (this.localRegionX + areaX) * this.magicLoc + 64;
            const y = (this.localRegionY + areaY) * this.magicLoc + 64;

            this.createPlayer(serverIndex, x, y, sprite);

            if (isPlayerKnown === 0) {
                this.playerServerIndexes[playerCount++] = serverIndex;
            }
        }

        if (playerCount > 0) {
            this.packetStream.newPacket(clientOpcodes.KNOWN_PLAYERS);
            this.packetStream.putShort(playerCount);

            for (let i = 0; i < playerCount; i++) {
                const player = this.playerServer[this.playerServerIndexes[i]];

                this.packetStream.putShort(player.serverIndex);
                this.packetStream.putShort(player.serverId);
            }

            this.packetStream.sendPacket();
            playerCount = 0;
        }
    }
};

module.exports = handlers;

},{"../opcodes/client":54,"../opcodes/server":55,"../utility":100}],65:[function(require,module,exports){
const Utility = require('../utility');
const serverOpcodes = require('../opcodes/server');

const handlers = {
    [serverOpcodes.PRIVACY_SETTINGS]: function (data) {
        this.settingsBlockChat = data[1];
        this.settingsBlockPrivate = data[2];
        this.settingsBlockTrade = data[3];
        this.settingsBlockDuel = data[4];
    },
    [serverOpcodes.GAME_SETTINGS]: function (data) {
        this.optionCameraModeAuto = !!Utility.getUnsignedByte(data[1]);
        this.optionMouseButtonOne = !!Utility.getUnsignedByte(data[2]);
        this.optionSoundDisabled = !!Utility.getUnsignedByte(data[3]);
    }
};

module.exports = handlers;

},{"../opcodes/server":55,"../utility":100}],66:[function(require,module,exports){
const Utility = require('../utility');
const serverOpcodes = require('../opcodes/server');

const handlers = {
    [serverOpcodes.SLEEP_OPEN]: function (data) {
        if (!this.isSleeping) {
            this.fatigueSleeping = this.statFatigue;
        }

        this.isSleeping = true;
        this.inputTextCurrent = '';
        this.inputTextFinal = '';
        this.surface.readSleepWord(this.spriteTexture + 1, data);
        this.sleepingStatusText = null;
    },
    [serverOpcodes.SLEEP_CLOSE]: function () {
        this.isSleeping = false;
    },
    [serverOpcodes.SLEEP_INCORRECT]: function () {
        this.sleepingStatusText = 'Incorrect - Please wait...';
    },
    [serverOpcodes.PLAYER_STAT_FATIGUE_ASLEEP]: function (data) {
        this.fatigueSleeping = Utility.getUnsignedShort(data, 1);
    }
};

module.exports = handlers;

},{"../opcodes/server":55,"../utility":100}],67:[function(require,module,exports){
const ChatMessage = require('../chat-message');
const GameConnection = require('../game-connection');
const Utility = require('../utility');
const WordFilter = require('../word-filter');
const serverOpcodes = require('../opcodes/server');

const handlers = {
    [serverOpcodes.FRIEND_LIST]: function (data) {
        this.friendListCount = Utility.getUnsignedByte(data[1]);

        for (let i = 0; i < this.friendListCount; i++) {
            this.friendListHashes[i] = Utility.getUnsignedLong(data, 2 + i * 9);

            this.friendListOnline[i] = Utility.getUnsignedByte(
                data[10 + i * 9]
            );
        }

        this.sortFriendsList();
    },
    [serverOpcodes.FRIEND_STATUS_CHANGE]: function (data) {
        const encodedUsername = Utility.getUnsignedLong(data, 1);
        const world = data[9] & 0xff;

        for (let i = 0; i < this.friendListCount; i++) {
            if (this.friendListHashes[i].equals(encodedUsername)) {
                if (this.friendListOnline[i] === 0 && world !== 0) {
                    this.showServerMessage(
                        `@pri@${Utility.hashToUsername(encodedUsername)} ` +
                            'has logged in'
                    );
                }

                if (this.friendListOnline[i] !== 0 && world === 0) {
                    this.showServerMessage(
                        `@pri@${Utility.hashToUsername(encodedUsername)} ` +
                            'has logged out'
                    );
                }

                this.friendListOnline[i] = world;
                this.sortFriendsList();

                return;
            }
        }

        this.friendListHashes[this.friendListCount] = encodedUsername;
        this.friendListOnline[this.friendListCount] = world;

        this.friendListCount++;

        this.sortFriendsList();
    },
    [serverOpcodes.FRIEND_MESSAGE]: function (data, size) {
        const from = Utility.getUnsignedLong(data, 1);
        const token = Utility.getUnsignedInt(data, 9);

        for (let i = 0; i < this.maxSocialListSize; i++) {
            if (this.messageTokens[i] === token) {
                return;
            }
        }

        this.messageTokens[this.messageIndex] = token;

        this.messageIndex =
            (this.messageIndex + 1) % GameConnection.maxSocialListSize;

        let message = ChatMessage.descramble(data, 13, size - 13);

        if (this.options.wordFilter) {
            message = WordFilter.filter(message);
        }

        this.showServerMessage(
            `@pri@${Utility.hashToUsername(from)}: tells you ${message}`
        );
    },
    [serverOpcodes.IGNORE_LIST]: function (data) {
        this.ignoreListCount = Utility.getUnsignedByte(data[1]);

        for (let i = 0; i < this.ignoreListCount; i++) {
            this.ignoreList[i] = Utility.getUnsignedLong(data, 2 + i * 8);
        }
    }
};

module.exports = handlers;

},{"../chat-message":40,"../game-connection":43,"../opcodes/server":55,"../utility":100,"../word-filter":102}],68:[function(require,module,exports){
const Long = require('long');

function toCharArray(s) {
    const a = new Uint16Array(s.length);

    for (let i = 0; i < s.length; i += 1) {
        a[i] = s.charCodeAt(i);
    }

    return a;
}

class PacketStream {
    constructor(socket) {
        this.socket = socket;

        this.closed = false;
        this.closing = false;
        this.delay = 0;
        this.isaacIncoming = null;
        this.isaacOutgoing = null;
        this.length = 0;
        this.maxReadTries = 0;
        this.packet8Check = 8;
        this.packetData = null;
        this.packetEnd = 3;
        this.packetMaxLength = 5000;
        this.packetStart = 0;
        this.readTries = 0;
        this.socketException = false;
        this.socketExceptionMessage = '';
    }

    // TODO toggle ISAAC
    /*seedIsaac(seed) {
        //this.isaacIncoming = new ISAAC(seed);
        //this.isaacOutgoing = new ISAAC(seed);
    }*/

    async readBytes(len, buff) {
        await this.readStreamBytes(len, 0, buff);
    }

    async readPacket(buff) {
        try {
            this.readTries++;

            if (this.maxReadTries > 0 && this.readTries > this.maxReadTries) {
                this.socketException = true;
                this.socketExceptionMessage = 'time-out';
                this.maxReadTries += this.maxReadTries;

                return 0;
            }

            if (this.length === 0 && this.availableStream() >= 2) {
                this.length = await this.readStream();

                if (this.length >= 160) {
                    this.length =
                        (this.length - 160) * 256 + (await this.readStream());
                }
            }

            if (this.length > 0 && this.availableStream() >= this.length) {
                if (this.length >= 160) {
                    await this.readBytes(this.length, buff);
                } else {
                    buff[this.length - 1] = (await this.readStream()) & 0xff;

                    if (this.length > 1) {
                        await this.readBytes(this.length - 1, buff);
                    }
                }

                let i = this.length;

                this.length = 0;
                this.readTries = 0;

                return i;
            }
        } catch (e) {
            this.socketException = true;
            this.socketExceptionMessage = e.message;
        }

        return 0;
    }

    hasPacket() {
        return this.packetStart > 0;
    }

    writePacket(i) {
        if (this.socketException) {
            this.packetetStart = 0;
            this.packetetEnd = 3;
            this.socketException = false;

            throw Error(this.socketExceptionMessage);
        }

        this.delay++;

        if (this.delay < i) {
            return;
        }

        if (this.packetStart > 0) {
            this.delay = 0;
            this.writeStreamBytes(this.packetData, 0, this.packetStart);
        }

        this.packetStart = 0;
        this.packetEnd = 3;
    }

    sendPacket() {
        if (this.isaacOutgoing !== null) {
            let i = this.packetData[this.packetStart + 2] & 0xff;
            this.packetData[this.packetStart + 2] =
                (i + this.isaacOutgoing.getNextValue()) & 0xff;
        }

        // what the fuck is this even for? legacy?
        if (this.packet8Check !== 8) {
            this.packetEnd++;
        }

        const length = this.packetEnd - this.packetStart - 2;

        if (length >= 160) {
            this.packetData[this.packetStart] =
                (160 + ((length / 256) | 0)) & 0xff;
            this.packetData[this.packetStart + 1] = length & 0xff;
        } else {
            this.packetData[this.packetStart] = length & 0xff;
            this.packetEnd--;
            this.packetData[this.packetStart + 1] = this.packetData[
                this.packetEnd
            ];
        }

        // this seems largely useless and doesn't appear to do anything
        if (this.packetMaxLength <= 10000) {
            let k = this.packetData[this.packetStart + 2] & 0xff;

            PacketStream.anIntArray537[k]++;
            PacketStream.anIntArray541[k] += this.packetEnd - this.packetStart;
        }

        this.packetStart = this.packetEnd;
    }

    putBytes(src, srcPos, len) {
        for (let k = 0; k < len; k++) {
            this.packetData[this.packetEnd++] = src[srcPos + k] & 0xff;
        }
    }

    putLong(l) {
        this.putInt(l.shiftRight(32).toInt());
        this.putInt(l.toInt());
    }

    newPacket(opcode) {
        if (this.packetStart > (((this.packetMaxLength * 4) / 5) | 0)) {
            try {
                this.writePacket(0);
            } catch (e) {
                this.socketException = true;
                this.socketExceptionMessage = e.message;
            }
        }

        if (this.packetData === null) {
            this.packetData = new Int8Array(this.packetMaxLength);
        }

        this.packetData[this.packetStart + 2] = opcode & 0xff;
        this.packetData[this.packetStart + 3] = 0;
        this.packetEnd = this.packetStart + 3;
        this.packet8Check = 8;
    }

    async getLong() {
        let l = await this.getShort();
        let l1 = await this.getShort();
        let l2 = await this.getShort();
        let l3 = await this.getShort();

        return Long.fromInt(l)
            .shiftLeft(48)
            .add(Long.fromInt(l1).shiftLeft(32))
            .add(l2 << 16)
            .add(l3);
    }

    putShort(i) {
        this.packetData[this.packetEnd++] = (i >> 8) & 0xff;
        this.packetData[this.packetEnd++] = i & 0xff;
    }

    putInt(i) {
        this.packetData[this.packetEnd++] = (i >> 24) & 0xff;
        this.packetData[this.packetEnd++] = (i >> 16) & 0xff;
        this.packetData[this.packetEnd++] = (i >> 8) & 0xff;
        this.packetData[this.packetEnd++] = i & 0xff;
    }

    async getShort() {
        let i = await this.getByte();
        let j = await this.getByte();

        return i * 256 + j;
    }

    putString(s) {
        this.putBytes(toCharArray(s), 0, s.length);
    }

    putByte(i) {
        this.packetData[this.packetEnd++] = i & 0xff;
    }

    isaacCommand(i) {
        // TODO toggle ISAA
        //return i - isaacIncoming.getNextValue() & 0xff;
        return i;
    }

    async getByte() {
        return (await this.readStream()) & 0xff;
    }

    flushPacket() {
        this.sendPacket();
        this.writePacket(0);
    }

    closeStream() {
        this.closing = true;
        this.socket.close();
        this.closed = true;
    }

    async readStream() {
        if (this.closing) {
            return 0;
        }

        return await this.socket.read();
    }

    availableStream() {
        if (this.closing) {
            return 0;
        }

        return this.socket.available();
    }

    async readStreamBytes(len, off, buff) {
        if (this.closing) {
            return;
        }

        await this.socket.readBytes(buff, off, len);
    }

    writeStreamBytes(buff, off, len) {
        if (this.closing) {
            return;
        }

        this.socket.write(buff, off, len);
    }
}

PacketStream.anIntArray537 = new Int32Array(256);
PacketStream.anIntArray541 = new Int32Array(256);

module.exports = PacketStream;

},{"long":33}],69:[function(require,module,exports){
const Surface = require('./surface');

const controlTypes = {
    TEXT: 0,
    CENTRE_TEXT: 1,
    GRADIENT_BG: 2,
    HORIZ_LINE: 3,
    TEXT_LIST: 4,
    LIST_INPUT: 5,
    TEXT_INPUT: 6,
    HORIZ_OPTION: 7,
    VERT_OPTION: 8,
    I_TEXT_LIST: 9,
    BUTTON: 10,
    ROUND_BOX: 11,
    IMAGE: 12,
    CHECKBOX: 14
};

class Panel {
    constructor(surface, max) {
        this.controlCount = 0;

        this.mouseX = 0;
        this.mouseY = 0;
        this.mouseLastButtonDown = 0;
        this.mouseButtonDown = 0;
        this.mouseMetaButtonHeld = 0;
        this.mouseScrollDelta = 0;

        this.focusControlIndex = -1;
        this.aBoolean219 = true;
        this.surface = surface;
        this.maxControls = max;
        this.controlShown = new Int8Array(max);
        this.controlListScrollbarHandleDragged = new Int8Array(max);
        this.controlMaskText = new Int8Array(max);
        this.controlClicked = new Int8Array(max);
        this.controlUseAlternativeColour = new Int8Array(max);
        this.controlFlashText = new Int32Array(max);
        this.controlListEntryCount = new Int32Array(max);
        this.controlListEntryMouseButtonDown = new Int32Array(max);
        this.controlListEntryMouseOver = new Int32Array(max);
        this.controlX = new Int32Array(max);
        this.controlY = new Int32Array(max);
        this.controlType = new Int32Array(max);
        this.controlWidth = new Int32Array(max);
        this.controlHeight = new Int32Array(max);
        this.controlInputMaxLen = new Int32Array(max);
        this.controlTextSize = new Int32Array(max);

        this.controlText = [];
        this.controlText.length = max;

        this.controlListEntries = [];

        for (let i = 0; i < max; i += 1) {
            this.controlListEntries.push([]);
        }

        this.colourScrollbarTop = this.rgbToIntMod(114, 114, 176);
        this.colourScrollbarBottom = this.rgbToIntMod(14, 14, 62);
        this.colourScrollbarHandleLeft = this.rgbToIntMod(200, 208, 232);
        this.colourScrollbarHandleMid = this.rgbToIntMod(96, 129, 184);
        this.colourScrollbarHandleRight = this.rgbToIntMod(53, 95, 115);
        this.colourRoundedBoxOut = this.rgbToIntMod(117, 142, 171);
        this.colourRoundedBoxMid = this.rgbToIntMod(98, 122, 158);
        this.colourRoundedBoxIn = this.rgbToIntMod(86, 100, 136);
        this.colourBoxTopNBottom = this.rgbToIntMod(135, 146, 179);
        this.colourBoxTopNBottom2 = this.rgbToIntMod(97, 112, 151);
        this.colourBoxLeftNRight2 = this.rgbToIntMod(88, 102, 136);
        this.colourBoxLeftNRight = this.rgbToIntMod(84, 93, 120);
    }

    rgbToIntMod(r, g, b) {
        return Surface.rgbToInt(
            ((Panel.redMod * r) / 114) | 0,
            ((Panel.greenMod * g) / 114) | 0,
            ((Panel.blueMod * b) / 176) | 0
        );
    }

    handleMouse(mx, my, lastMb, mbDown, mScrollDelta = 0) {
        this.mouseX = mx;
        this.mouseY = my;
        this.mouseButtonDown = mbDown;
        this.mouseScrollDelta = mScrollDelta;

        if (lastMb !== 0) {
            this.mouseLastButtonDown = lastMb;
        }

        if (lastMb === 1) {
            for (let i1 = 0; i1 < this.controlCount; i1++) {
                if (
                    this.controlShown[i1] &&
                    this.controlType[i1] === controlTypes.BUTTON &&
                    this.mouseX >= this.controlX[i1] &&
                    this.mouseY >= this.controlY[i1] &&
                    this.mouseX <= this.controlX[i1] + this.controlWidth[i1] &&
                    this.mouseY <= this.controlY[i1] + this.controlHeight[i1]
                ) {
                    this.controlClicked[i1] = true;
                }

                if (
                    this.controlShown[i1] &&
                    this.controlType[i1] === controlTypes.CHECKBOX &&
                    this.mouseX >= this.controlX[i1] &&
                    this.mouseY >= this.controlY[i1] &&
                    this.mouseX <= this.controlX[i1] + this.controlWidth[i1] &&
                    this.mouseY <= this.controlY[i1] + this.controlHeight[i1]
                ) {
                    this.controlListEntryMouseButtonDown[i1] =
                        1 - this.controlListEntryMouseButtonDown[i1];
                }
            }
        }

        if (mbDown === 1) {
            this.mouseMetaButtonHeld++;
        } else {
            this.mouseMetaButtonHeld = 0;
        }

        if (lastMb === 1 || this.mouseMetaButtonHeld > 20) {
            for (let j1 = 0; j1 < this.controlCount; j1++) {
                if (
                    this.controlShown[j1] &&
                    this.controlType[j1] === 15 &&
                    this.mouseX >= this.controlX[j1] &&
                    this.mouseY >= this.controlY[j1] &&
                    this.mouseX <= this.controlX[j1] + this.controlWidth[j1] &&
                    this.mouseY <= this.controlY[j1] + this.controlHeight[j1]
                ) {
                    this.controlClicked[j1] = true;
                }
            }

            this.mouseMetaButtonHeld -= 5;
        }
    }

    isClicked(i) {
        if (this.controlShown[i] && this.controlClicked[i]) {
            this.controlClicked[i] = false;
            return true;
        } else {
            return false;
        }
    }

    keyPress(key) {
        if (key === 0) {
            return;
        }

        if (
            this.focusControlIndex !== -1 &&
            this.controlText[this.focusControlIndex] !== null &&
            this.controlShown[this.focusControlIndex]
        ) {
            const inputLen = this.controlText[this.focusControlIndex].length;

            if (key === 8 && inputLen > 0) {
                this.controlText[this.focusControlIndex] = this.controlText[
                    this.focusControlIndex
                ].slice(0, inputLen - 1);
            }

            if ((key === 10 || key === 13) && inputLen > 0) {
                this.controlClicked[this.focusControlIndex] = true;
            }

            const charSet =
                'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234567' +
                '89!"£$%^&*()-_=+[{]};:\'@#~,<.>/?\\| ';

            if (inputLen < this.controlInputMaxLen[this.focusControlIndex]) {
                for (let k = 0; k < charSet.length; k++) {
                    if (key === charSet.charCodeAt(k)) {
                        this.controlText[
                            this.focusControlIndex
                        ] += String.fromCharCode(key);
                    }
                }
            }

            if (key === 9) {
                do {
                    this.focusControlIndex =
                        (this.focusControlIndex + 1) % this.controlCount;
                } while (
                    this.controlType[this.focusControlIndex] !== 5 &&
                    this.controlType[this.focusControlIndex] !== 6
                );
            }
        }
    }

    drawPanel() {
        for (let i = 0; i < this.controlCount; i++) {
            if (this.controlShown[i]) {
                if (this.controlType[i] === controlTypes.TEXT) {
                    this.drawText(
                        i,
                        this.controlX[i],
                        this.controlY[i],
                        this.controlText[i],
                        this.controlTextSize[i]
                    );
                } else if (this.controlType[i] === controlTypes.CENTRE_TEXT) {
                    this.drawText(
                        i,
                        this.controlX[i] -
                            ((this.surface.textWidth(
                                this.controlText[i],
                                this.controlTextSize[i]
                            ) /
                                2) |
                                0),
                        this.controlY[i],
                        this.controlText[i],
                        this.controlTextSize[i]
                    );
                } else if (this.controlType[i] === controlTypes.GRADIENT_BG) {
                    this.drawBox(
                        this.controlX[i],
                        this.controlY[i],
                        this.controlWidth[i],
                        this.controlHeight[i]
                    );
                } else if (this.controlType[i] === controlTypes.HORIZ_LINE) {
                    this.drawLineHoriz(
                        this.controlX[i],
                        this.controlY[i],
                        this.controlWidth[i]
                    );
                } else if (this.controlType[i] === controlTypes.TEXT_LIST) {
                    this.drawTextList(
                        i,
                        this.controlX[i],
                        this.controlY[i],
                        this.controlWidth[i],
                        this.controlHeight[i],
                        this.controlTextSize[i],
                        this.controlListEntries[i],
                        this.controlListEntryCount[i],
                        this.controlFlashText[i]
                    );
                } else if (
                    this.controlType[i] === controlTypes.LIST_INPUT ||
                    this.controlType[i] === controlTypes.TEXT_INPUT
                ) {
                    this.drawTextInput(
                        i,
                        this.controlX[i],
                        this.controlY[i],
                        this.controlWidth[i],
                        this.controlHeight[i],
                        this.controlText[i],
                        this.controlTextSize[i]
                    );
                } else if (this.controlType[i] === controlTypes.HORIZ_OPTION) {
                    this.drawOptionListHoriz(
                        i,
                        this.controlX[i],
                        this.controlY[i],
                        this.controlTextSize[i],
                        this.controlListEntries[i]
                    );
                } else if (this.controlType[i] === controlTypes.VERT_OPTION) {
                    this.drawOptionListVert(
                        i,
                        this.controlX[i],
                        this.controlY[i],
                        this.controlTextSize[i],
                        this.controlListEntries[i]
                    );
                } else if (this.controlType[i] === controlTypes.I_TEXT_LIST) {
                    this.drawTextListInteractive(
                        i,
                        this.controlX[i],
                        this.controlY[i],
                        this.controlWidth[i],
                        this.controlHeight[i],
                        this.controlTextSize[i],
                        this.controlListEntries[i],
                        this.controlListEntryCount[i],
                        this.controlFlashText[i]
                    );
                } else if (this.controlType[i] === controlTypes.ROUND_BOX) {
                    this.drawRoundedBox(
                        this.controlX[i],
                        this.controlY[i],
                        this.controlWidth[i],
                        this.controlHeight[i]
                    );
                } else if (this.controlType[i] === controlTypes.IMAGE) {
                    this.drawPicture(
                        this.controlX[i],
                        this.controlY[i],
                        this.controlTextSize[i]
                    );
                } else if (this.controlType[i] === controlTypes.CHECKBOX) {
                    this.drawCheckbox(
                        i,
                        this.controlX[i],
                        this.controlY[i],
                        this.controlWidth[i],
                        this.controlHeight[i]
                    );
                }
            }
        }

        this.mouseLastButtonDown = 0;
    }

    drawCheckbox(control, x, y, width, height) {
        this.surface.drawBox(x, y, width, height, 0xffffff);
        this.surface.drawLineHoriz(x, y, width, this.colourBoxTopNBottom);
        this.surface.drawLineVert(x, y, height, this.colourBoxTopNBottom);
        this.surface.drawLineHoriz(
            x,
            y + height - 1,
            width,
            this.colourBoxLeftNRight
        );
        this.surface.drawLineVert(
            x + width - 1,
            y,
            height,
            this.colourBoxLeftNRight
        );

        if (this.controlListEntryMouseButtonDown[control] === 1) {
            for (let j1 = 0; j1 < height; j1++) {
                this.surface.drawLineHoriz(x + j1, y + j1, 1, 0);
                this.surface.drawLineHoriz(x + width - 1 - j1, y + j1, 1, 0);
            }
        }
    }

    drawText(control, x, y, text, textSize) {
        const y2 = y + ((this.surface.textHeight(textSize) / 3) | 0);
        this.drawString(control, x, y2, text, textSize);
    }

    drawString(control, x, y, text, textSize) {
        let i1;

        if (this.controlUseAlternativeColour[control]) {
            i1 = 0xffffff;
        } else {
            i1 = 0;
        }

        this.surface.drawString(text, x, y, textSize, i1);
    }

    drawTextInput(control, x, y, width, height, text, textSize) {
        // password
        if (this.controlMaskText[control]) {
            const len = text.length;
            text = '';

            for (let i2 = 0; i2 < len; i2++) {
                text = text + 'X';
            }
        }

        if (this.controlType[control] === controlTypes.LIST_INPUT) {
            if (
                this.mouseLastButtonDown === 1 &&
                this.mouseX >= x &&
                this.mouseY >= y - ((height / 2) | 0) &&
                this.mouseX <= x + width &&
                this.mouseY <= y + ((height / 2) | 0)
            ) {
                this.focusControlIndex = control;
            }
        } else if (this.controlType[control] === controlTypes.TEXT_INPUT) {
            if (
                this.mouseLastButtonDown === 1 &&
                this.mouseX >= x - ((width / 2) | 0) &&
                this.mouseY >= y - ((height / 2) | 0) &&
                this.mouseX <= x + width / 2 &&
                this.mouseY <= y + ((height / 2) | 0)
            ) {
                this.focusControlIndex = control;
            }

            x -= (this.surface.textWidth(text, textSize) / 2) | 0;
        }

        if (this.focusControlIndex === control) {
            text = text + '*';
        }

        const y2 = y + ((this.surface.textHeight(textSize) / 3) | 0);
        this.drawString(control, x, y2, text, textSize);
    }

    drawBox(x, y, width, height) {
        this.surface.setBounds(x, y, x + width, y + height);
        this.surface.drawGradient(
            x,
            y,
            width,
            height,
            this.colourBoxLeftNRight,
            this.colourBoxTopNBottom
        );

        if (Panel.drawBackgroundArrow) {
            for (let i1 = x - (y & 0x3f); i1 < x + width; i1 += 128) {
                for (let j1 = y - (y & 0x1f); j1 < y + height; j1 += 128) {
                    this.surface.drawSpriteAlpha(
                        i1,
                        j1,
                        6 + Panel.baseSpriteStart,
                        128
                    );
                }
            }
        }

        this.surface.drawLineHoriz(x, y, width, this.colourBoxTopNBottom);
        this.surface.drawLineHoriz(
            x + 1,
            y + 1,
            width - 2,
            this.colourBoxTopNBottom
        );
        this.surface.drawLineHoriz(
            x + 2,
            y + 2,
            width - 4,
            this.colourBoxTopNBottom2
        );
        this.surface.drawLineVert(x, y, height, this.colourBoxTopNBottom);
        this.surface.drawLineVert(
            x + 1,
            y + 1,
            height - 2,
            this.colourBoxTopNBottom
        );
        this.surface.drawLineVert(
            x + 2,
            y + 2,
            height - 4,
            this.colourBoxTopNBottom2
        );
        this.surface.drawLineHoriz(
            x,
            y + height - 1,
            width,
            this.colourBoxLeftNRight
        );
        this.surface.drawLineHoriz(
            x + 1,
            y + height - 2,
            width - 2,
            this.colourBoxLeftNRight
        );
        this.surface.drawLineHoriz(
            x + 2,
            y + height - 3,
            width - 4,
            this.colourBoxLeftNRight2
        );
        this.surface.drawLineVert(
            x + width - 1,
            y,
            height,
            this.colourBoxLeftNRight
        );
        this.surface.drawLineVert(
            x + width - 2,
            y + 1,
            height - 2,
            this.colourBoxLeftNRight
        );
        this.surface.drawLineVert(
            x + width - 3,
            y + 2,
            height - 4,
            this.colourBoxLeftNRight2
        );
        this.surface.resetBounds();
    }

    drawRoundedBox(x, y, width, height) {
        this.surface.drawBox(x, y, width, height, 0);
        this.surface.drawBoxEdge(x, y, width, height, this.colourRoundedBoxOut);
        this.surface.drawBoxEdge(
            x + 1,
            y + 1,
            width - 2,
            height - 2,
            this.colourRoundedBoxMid
        );
        this.surface.drawBoxEdge(
            x + 2,
            y + 2,
            width - 4,
            height - 4,
            this.colourRoundedBoxIn
        );
        this.surface._drawSprite_from3(x, y, 2 + Panel.baseSpriteStart);
        this.surface._drawSprite_from3(
            x + width - 7,
            y,
            3 + Panel.baseSpriteStart
        );
        this.surface._drawSprite_from3(
            x,
            y + height - 7,
            4 + Panel.baseSpriteStart
        );
        this.surface._drawSprite_from3(
            x + width - 7,
            y + height - 7,
            5 + Panel.baseSpriteStart
        );
    }

    drawPicture(x, y, size) {
        this.surface._drawSprite_from3(x, y, size);
    }

    drawLineHoriz(x, y, width) {
        this.surface.drawLineHoriz(x, y, width, 0xffffff);
    }

    drawTextList(
        control,
        x,
        y,
        width,
        height,
        textSize,
        listEntries,
        listEntryCount,
        listEntryPosition
    ) {
        const displayedEntryCount =
            (height / this.surface.textHeight(textSize)) | 0;
        const maxEntries = listEntryCount - displayedEntryCount;

        if (listEntryPosition > maxEntries) {
            listEntryPosition = maxEntries;
        }

        if (listEntryPosition < 0) {
            listEntryPosition = 0;
        }

        this.controlFlashText[control] = listEntryPosition;

        if (displayedEntryCount < listEntryCount) {
            const cornerTopRight = x + width - 12;
            let cornerBottomLeft =
                (((height - 27) * displayedEntryCount) / listEntryCount) | 0;

            if (cornerBottomLeft < 6) {
                cornerBottomLeft = 6;
            }

            let j3 =
                (((height - 27 - cornerBottomLeft) * listEntryPosition) /
                    maxEntries) |
                0;

            if (
                this.mouseScrollDelta !== 0 &&
                this.mouseX > x &&
                this.mouseX < x + width &&
                this.mouseY > y &&
                this.mouseY < y + height
            ) {
                listEntryPosition += this.mouseScrollDelta;

                if (listEntryPosition < 0) {
                    listEntryPosition = 0;
                } else if (listEntryPosition > maxEntries) {
                    listEntryPosition = maxEntries;
                }

                this.controlFlashText[control] = listEntryPosition;
            }

            if (
                this.mouseButtonDown === 1 &&
                this.mouseX >= cornerTopRight &&
                this.mouseX <= cornerTopRight + 12
            ) {
                if (
                    this.mouseY > y &&
                    this.mouseY < y + 12 &&
                    listEntryPosition > 0
                ) {
                    listEntryPosition--;
                }

                if (
                    this.mouseY > y + height - 12 &&
                    this.mouseY < y + height &&
                    listEntryPosition < listEntryCount - displayedEntryCount
                ) {
                    listEntryPosition++;
                }

                this.controlFlashText[control] = listEntryPosition;
            }

            if (
                this.mouseButtonDown === 1 &&
                ((this.mouseX >= cornerTopRight &&
                    this.mouseX <= cornerTopRight + 12) ||
                    (this.mouseX >= cornerTopRight - 12 &&
                        this.mouseX <= cornerTopRight + 24 &&
                        this.controlListScrollbarHandleDragged[control]))
            ) {
                if (this.mouseY > y + 12 && this.mouseY < y + height - 12) {
                    this.controlListScrollbarHandleDragged[control] = true;

                    const l3 =
                        this.mouseY - y - 12 - ((cornerBottomLeft / 2) | 0);
                    listEntryPosition =
                        ((l3 * listEntryCount) / (height - 24)) | 0;

                    if (listEntryPosition > maxEntries) {
                        listEntryPosition = maxEntries;
                    }

                    if (listEntryPosition < 0) {
                        listEntryPosition = 0;
                    }

                    this.controlFlashText[control] = listEntryPosition;
                }
            } else {
                this.controlListScrollbarHandleDragged[control] = false;
            }

            j3 =
                (((height - 27 - cornerBottomLeft) * listEntryPosition) /
                    (listEntryCount - displayedEntryCount)) |
                0;
            this.drawListContainer(x, y, width, height, j3, cornerBottomLeft);
        }

        const entryListStartY =
            height - displayedEntryCount * this.surface.textHeight(textSize);
        let y2 =
            (y +
                ((this.surface.textHeight(textSize) * 5) / 6 +
                    entryListStartY / 2)) |
            0;

        for (let entry = listEntryPosition; entry < listEntryCount; entry++) {
            this.drawString(control, x + 2, y2, listEntries[entry], textSize);
            y2 +=
                this.surface.textHeight(textSize) -
                Panel.textListEntryHeightMod;

            if (y2 >= y + height) {
                return;
            }
        }
    }

    drawListContainer(x, y, width, height, corner1, corner2) {
        const x2 = x + width - 12;
        this.surface.drawBoxEdge(x2, y, 12, height, 0);
        this.surface._drawSprite_from3(x2 + 1, y + 1, Panel.baseSpriteStart); // up arrow?
        this.surface._drawSprite_from3(
            x2 + 1,
            y + height - 12,
            1 + Panel.baseSpriteStart
        ); // down arrow?
        this.surface.drawLineHoriz(x2, y + 13, 12, 0);
        this.surface.drawLineHoriz(x2, y + height - 13, 12, 0);
        this.surface.drawGradient(
            x2 + 1,
            y + 14,
            11,
            height - 27,
            this.colourScrollbarTop,
            this.colourScrollbarBottom
        );
        this.surface.drawBox(
            x2 + 3,
            corner1 + y + 14,
            7,
            corner2,
            this.colourScrollbarHandleMid
        );
        this.surface.drawLineVert(
            x2 + 2,
            corner1 + y + 14,
            corner2,
            this.colourScrollbarHandleLeft
        );
        this.surface.drawLineVert(
            x2 + 2 + 8,
            corner1 + y + 14,
            corner2,
            this.colourScrollbarHandleRight
        );
    }

    drawOptionListHoriz(control, x, y, textSize, listEntries) {
        let listTotalTextWidth = 0;
        const listEntryCount = listEntries.length;

        for (let idx = 0; idx < listEntryCount; idx++) {
            listTotalTextWidth += this.surface.textWidth(
                listEntries[idx],
                textSize
            );

            if (idx < listEntryCount - 1) {
                listTotalTextWidth += this.surface.textWidth('  ', textSize);
            }
        }

        let left = x - ((listTotalTextWidth / 2) | 0);
        const bottom = y + ((this.surface.textHeight(textSize) / 3) | 0);

        for (let idx = 0; idx < listEntryCount; idx++) {
            let colour;

            if (this.controlUseAlternativeColour[control]) {
                colour = 0xffffff;
            } else {
                colour = 0;
            }

            if (
                this.mouseX >= left &&
                this.mouseX <=
                    left + this.surface.textWidth(listEntries[idx], textSize) &&
                this.mouseY <= bottom &&
                this.mouseY > bottom - this.surface.textHeight(textSize)
            ) {
                if (this.controlUseAlternativeColour[control]) {
                    colour = 0x808080;
                } else {
                    colour = 0xffffff;
                }

                if (this.mouseLastButtonDown === 1) {
                    this.controlListEntryMouseButtonDown[control] = idx;
                    this.controlClicked[control] = true;
                }
            }

            if (this.controlListEntryMouseButtonDown[control] === idx) {
                if (this.controlUseAlternativeColour[control]) {
                    colour = 0xff0000;
                } else {
                    colour = 0xc00000;
                }
            }

            this.surface.drawString(
                listEntries[idx],
                left,
                bottom,
                textSize,
                colour
            );
            left += this.surface.textWidth(listEntries[idx] + '  ', textSize);
        }
    }

    drawOptionListVert(control, x, y, textSize, listEntries) {
        const listEntryCount = listEntries.length;
        let listTotalTextHeightMid =
            y -
            (((this.surface.textHeight(textSize) * (listEntryCount - 1)) / 2) |
                0);

        for (let idx = 0; idx < listEntryCount; idx++) {
            let colour;

            if (this.controlUseAlternativeColour[control]) {
                colour = 0xffffff;
            } else {
                colour = 0;
            }

            const entryTextWidth = this.surface.textWidth(
                listEntries[idx],
                textSize
            );

            if (
                this.mouseX >= x - ((entryTextWidth / 2) | 0) &&
                this.mouseX <= x + ((entryTextWidth / 2) | 0) &&
                this.mouseY - 2 <= listTotalTextHeightMid &&
                this.mouseY - 2 >
                    listTotalTextHeightMid - this.surface.textHeight(textSize)
            ) {
                if (this.controlUseAlternativeColour[control]) {
                    colour = 0x808080;
                } else {
                    colour = 0xffffff;
                }

                if (this.mouseLastButtonDown === 1) {
                    this.controlListEntryMouseButtonDown[control] = idx;
                    this.controlClicked[control] = true;
                }
            }

            if (this.controlListEntryMouseButtonDown[control] === idx) {
                if (this.controlUseAlternativeColour[control]) {
                    colour = 0xff0000;
                } else {
                    colour = 0xc00000;
                }
            }

            this.surface.drawString(
                listEntries[idx],
                x - ((entryTextWidth / 2) | 0),
                listTotalTextHeightMid,
                textSize,
                colour
            );
            listTotalTextHeightMid += this.surface.textHeight(textSize);
        }
    }

    drawTextListInteractive(
        control,
        x,
        y,
        width,
        height,
        textSize,
        listEntries,
        listEntryCount,
        listEntryPosition
    ) {
        const displayedEntryCount =
            (height / this.surface.textHeight(textSize)) | 0;
        const maxEntries = listEntryCount - displayedEntryCount;

        if (displayedEntryCount < listEntryCount) {
            const cornerTopRight = x + width - 12;
            let cornerBottomLeft =
                (((height - 27) * displayedEntryCount) / listEntryCount) | 0;

            if (cornerBottomLeft < 6) {
                cornerBottomLeft = 6;
            }

            let j3 =
                (((height - 27 - cornerBottomLeft) * listEntryPosition) /
                    maxEntries) |
                0;

            if (
                this.mouseScrollDelta !== 0 &&
                this.mouseX > x &&
                this.mouseX < x + width &&
                this.mouseY > y &&
                this.mouseY < y + height
            ) {
                listEntryPosition += this.mouseScrollDelta;

                if (listEntryPosition < 0) {
                    listEntryPosition = 0;
                } else if (listEntryPosition > maxEntries) {
                    listEntryPosition = maxEntries;
                }

                this.controlFlashText[control] = listEntryPosition;
            }

            // the up and down arrow buttons on the scrollbar
            if (
                this.mouseButtonDown === 1 &&
                this.mouseX >= cornerTopRight &&
                this.mouseX <= cornerTopRight + 12
            ) {
                if (
                    this.mouseY > y &&
                    this.mouseY < y + 12 &&
                    listEntryPosition > 0
                ) {
                    listEntryPosition--;
                }

                if (
                    this.mouseY > y + height - 12 &&
                    this.mouseY < y + height &&
                    listEntryPosition < maxEntries
                ) {
                    listEntryPosition++;
                }

                this.controlFlashText[control] = listEntryPosition;
            }

            // handle the thumb/middle section dragging of the scrollbar
            if (
                this.mouseButtonDown === 1 &&
                ((this.mouseX >= cornerTopRight &&
                    this.mouseX <= cornerTopRight + 12) ||
                    (this.mouseX >= cornerTopRight - 12 &&
                        this.mouseX <= cornerTopRight + 24 &&
                        this.controlListScrollbarHandleDragged[control]))
            ) {
                if (this.mouseY > y + 12 && this.mouseY < y + height - 12) {
                    this.controlListScrollbarHandleDragged[control] = true;

                    const l3 =
                        this.mouseY - y - 12 - ((cornerBottomLeft / 2) | 0);
                    listEntryPosition =
                        ((l3 * listEntryCount) / (height - 24)) | 0;

                    if (listEntryPosition < 0) {
                        listEntryPosition = 0;
                    }

                    if (listEntryPosition > maxEntries) {
                        listEntryPosition = maxEntries;
                    }

                    this.controlFlashText[control] = listEntryPosition;
                }
            } else {
                this.controlListScrollbarHandleDragged[control] = false;
            }

            j3 =
                (((height - 27 - cornerBottomLeft) * listEntryPosition) /
                    maxEntries) |
                0;
            this.drawListContainer(x, y, width, height, j3, cornerBottomLeft);
        } else {
            listEntryPosition = 0;
            this.controlFlashText[control] = 0;
        }

        this.controlListEntryMouseOver[control] = -1;
        const k2 =
            height - displayedEntryCount * this.surface.textHeight(textSize);
        let i3 =
            y +
            (((((this.surface.textHeight(textSize) * 5) / 6) | 0) + k2 / 2) |
                0);

        for (let k3 = listEntryPosition; k3 < listEntryCount; k3++) {
            let i4;

            if (this.controlUseAlternativeColour[control]) {
                i4 = 0xffffff;
            } else {
                i4 = 0;
            }

            if (
                this.mouseX >= x + 2 &&
                this.mouseX <=
                    x + 2 + this.surface.textWidth(listEntries[k3], textSize) &&
                this.mouseY - 2 <= i3 &&
                this.mouseY - 2 > i3 - this.surface.textHeight(textSize)
            ) {
                if (this.controlUseAlternativeColour[control]) {
                    i4 = 0x808080;
                } else {
                    i4 = 0xffffff;
                }

                this.controlListEntryMouseOver[control] = k3;

                if (this.mouseLastButtonDown === 1) {
                    this.controlListEntryMouseButtonDown[control] = k3;
                    this.controlClicked[control] = true;
                }
            }

            if (
                this.controlListEntryMouseButtonDown[control] === k3 &&
                this.aBoolean219
            ) {
                i4 = 0xff0000;
            }

            this.surface.drawString(listEntries[k3], x + 2, i3, textSize, i4);
            i3 += this.surface.textHeight(textSize);

            if (i3 >= y + height) {
                return;
            }
        }
    }

    addText(x, y, text, size, flag) {
        this.controlShown[this.controlCount] = true;
        this.controlClicked[this.controlCount] = false;
        this.controlTextSize[this.controlCount] = size;
        this.controlUseAlternativeColour[this.controlCount] = flag;
        this.controlX[this.controlCount] = x;
        this.controlY[this.controlCount] = y;
        this.controlText[this.controlCount] = text;

        return this.controlCount++;
    }

    addTextCentre(x, y, text, size, flag) {
        this.controlType[this.controlCount] = controlTypes.CENTRE_TEXT;
        this.controlShown[this.controlCount] = true;
        this.controlClicked[this.controlCount] = false;
        this.controlTextSize[this.controlCount] = size;
        this.controlUseAlternativeColour[this.controlCount] = flag;
        this.controlX[this.controlCount] = x;
        this.controlY[this.controlCount] = y;
        this.controlText[this.controlCount] = text;

        return this.controlCount++;
    }

    addButtonBackground(x, y, width, height) {
        this.controlType[this.controlCount] = controlTypes.GRADIENT_BG;
        this.controlShown[this.controlCount] = true;
        this.controlClicked[this.controlCount] = false;
        this.controlX[this.controlCount] = x - ((width / 2) | 0);
        this.controlY[this.controlCount] = y - ((height / 2) | 0);
        this.controlWidth[this.controlCount] = width;
        this.controlHeight[this.controlCount] = height;

        return this.controlCount++;
    }

    addBoxRounded(x, y, width, height) {
        this.controlType[this.controlCount] = controlTypes.ROUND_BOX;
        this.controlShown[this.controlCount] = true;
        this.controlClicked[this.controlCount] = false;
        this.controlX[this.controlCount] = x - ((width / 2) | 0);
        this.controlY[this.controlCount] = y - ((height / 2) | 0);
        this.controlWidth[this.controlCount] = width;
        this.controlHeight[this.controlCount] = height;

        return this.controlCount++;
    }

    addSprite(x, y, spriteId) {
        const imgWidth = this.surface.spriteWidth[spriteId];
        const imgHeight = this.surface.spriteHeight[spriteId];

        this.controlType[this.controlCount] = controlTypes.IMAGE;
        this.controlShown[this.controlCount] = true;
        this.controlClicked[this.controlCount] = false;
        this.controlX[this.controlCount] = x - ((imgWidth / 2) | 0);
        this.controlY[this.controlCount] = y - ((imgHeight / 2) | 0);
        this.controlWidth[this.controlCount] = imgWidth;
        this.controlHeight[this.controlCount] = imgHeight;
        this.controlTextSize[this.controlCount] = spriteId;

        return this.controlCount++;
    }

    addTextList(x, y, width, height, size, maxLength, flag) {
        this.controlType[this.controlCount] = controlTypes.TEXT_LIST;
        this.controlShown[this.controlCount] = true;
        this.controlClicked[this.controlCount] = false;
        this.controlX[this.controlCount] = x;
        this.controlY[this.controlCount] = y;
        this.controlWidth[this.controlCount] = width;
        this.controlHeight[this.controlCount] = height;
        this.controlUseAlternativeColour[this.controlCount] = flag;
        this.controlTextSize[this.controlCount] = size;
        this.controlInputMaxLen[this.controlCount] = maxLength;
        this.controlListEntryCount[this.controlCount] = 0;
        this.controlFlashText[this.controlCount] = 0;
        this.controlListEntries[this.controlCount] = [];
        this.controlListEntries[this.controlCount].length = maxLength;
        this.controlListEntries[this.controlCount].fill(null);

        return this.controlCount++;
    }

    addTextListInput(x, y, width, height, size, maxLength, flag, flag1) {
        this.controlType[this.controlCount] = controlTypes.LIST_INPUT;
        this.controlShown[this.controlCount] = true;
        this.controlMaskText[this.controlCount] = flag;
        this.controlClicked[this.controlCount] = false;
        this.controlTextSize[this.controlCount] = size;
        this.controlUseAlternativeColour[this.controlCount] = flag1;
        this.controlX[this.controlCount] = x;
        this.controlY[this.controlCount] = y;
        this.controlWidth[this.controlCount] = width;
        this.controlHeight[this.controlCount] = height;
        this.controlInputMaxLen[this.controlCount] = maxLength;
        this.controlText[this.controlCount] = '';

        return this.controlCount++;
    }

    addTextInput(x, y, width, height, size, maxLength, flag, flag1) {
        this.controlType[this.controlCount] = controlTypes.TEXT_INPUT;
        this.controlShown[this.controlCount] = true;
        this.controlMaskText[this.controlCount] = flag;
        this.controlClicked[this.controlCount] = false;
        this.controlTextSize[this.controlCount] = size;
        this.controlUseAlternativeColour[this.controlCount] = flag1;
        this.controlX[this.controlCount] = x;
        this.controlY[this.controlCount] = y;
        this.controlWidth[this.controlCount] = width;
        this.controlHeight[this.controlCount] = height;
        this.controlInputMaxLen[this.controlCount] = maxLength;
        this.controlText[this.controlCount] = '';

        return this.controlCount++;
    }

    addTextListInteractive(
        x,
        y,
        width,
        height,
        textSize,
        maxLength,
        flag
    ) {
        this.controlType[this.controlCount] = controlTypes.I_TEXT_LIST;
        this.controlShown[this.controlCount] = true;
        this.controlClicked[this.controlCount] = false;
        this.controlTextSize[this.controlCount] = textSize;
        this.controlUseAlternativeColour[this.controlCount] = flag;
        this.controlX[this.controlCount] = x;
        this.controlY[this.controlCount] = y;
        this.controlWidth[this.controlCount] = width;
        this.controlHeight[this.controlCount] = height;
        this.controlInputMaxLen[this.controlCount] = maxLength;
        this.controlListEntries[this.controlCount] = [];
        this.controlListEntries[this.controlCount].length = maxLength;
        this.controlListEntries[this.controlCount].fill(null);
        this.controlListEntryCount[this.controlCount] = 0;
        this.controlFlashText[this.controlCount] = 0;
        this.controlListEntryMouseButtonDown[this.controlCount] = -1;
        this.controlListEntryMouseOver[this.controlCount] = -1;

        return this.controlCount++;
    }

    addButton(x, y, width, height) {
        this.controlType[this.controlCount] = controlTypes.BUTTON;
        this.controlShown[this.controlCount] = true;
        this.controlClicked[this.controlCount] = false;
        this.controlX[this.controlCount] = x - ((width / 2) | 0);
        this.controlY[this.controlCount] = y - ((height / 2) | 0);
        this.controlWidth[this.controlCount] = width;
        this.controlHeight[this.controlCount] = height;

        return this.controlCount++;
    }

    addLineHoriz(x, y, width) {
        this.controlType[this.controlCount] = controlTypes.HORIZ_LINE;
        this.controlShown[this.controlCount] = true;
        this.controlX[this.controlCount] = x;
        this.controlY[this.controlCount] = y;
        this.controlWidth[this.controlCount] = width;

        return this.controlCount++;
    }

    addOptionListHoriz(x, y, textSize, maxListCount, useAltColour) {
        this.controlType[this.controlCount] = controlTypes.HORIZ_OPTION;
        this.controlShown[this.controlCount] = true;
        this.controlX[this.controlCount] = x;
        this.controlY[this.controlCount] = y;
        this.controlTextSize[this.controlCount] = textSize;
        this.controlListEntries[this.controlCount] = [];
        this.controlListEntries[this.controlCount].length = maxListCount;
        this.controlListEntries[this.controlCount].fill(null);
        this.controlListEntryCount[this.controlCount] = 0;
        this.controlUseAlternativeColour[this.controlCount] = useAltColour;
        this.controlClicked[this.controlCount] = false;

        return this.controlCount++;
    }

    addOptionListVert(x, y, textSize, maxListCount, useAltColour) {
        this.controlType[this.controlCount] = controlTypes.VERT_OPTION;
        this.controlShown[this.controlCount] = true;
        this.controlX[this.controlCount] = x;
        this.controlY[this.controlCount] = y;
        this.controlTextSize[this.controlCount] = textSize;
        this.controlListEntries[this.controlCount] = [];
        this.controlListEntries[this.controlCount].length = maxListCount;
        this.controlListEntries[this.controlCount].fill(null);
        this.controlListEntryCount[this.controlCount] = 0;
        this.controlUseAlternativeColour[this.controlCount] = useAltColour;
        this.controlClicked[this.controlCount] = false;

        return this.controlCount++;
    }

    addCheckbox(x, y, width, height) {
        this.controlType[this.controlCount] = controlTypes.CHECKBOX;
        this.controlShown[this.controlCount] = true;
        this.controlX[this.controlCount] = x;
        this.controlY[this.controlCount] = y;
        this.controlWidth[this.controlCount] = width;
        this.controlHeight[this.controlCount] = height;
        this.controlListEntryMouseButtonDown[this.controlCount] = 0;

        return this.controlCount++;
    }

    toggleCheckbox(control, activated) {
        this.controlListEntryMouseButtonDown[control] = activated ? 1 : 0;
    }

    isActivated(control) {
        return this.controlListEntryMouseButtonDown[control] !== 0;
    }

    clearList(control) {
        this.controlListEntryCount[control] = 0;
    }

    resetListProps(control) {
        this.controlFlashText[control] = 0;
        this.controlListEntryMouseOver[control] = -1;
    }

    addListEntry(control, index, text) {
        this.controlListEntries[control][index] = text;

        if (index + 1 > this.controlListEntryCount[control]) {
            this.controlListEntryCount[control] = index + 1;
        }
    }

    removeListEntry(control, text, flag) {
        let j = this.controlListEntryCount[control]++;

        if (j >= this.controlInputMaxLen[control]) {
            j--;

            this.controlListEntryCount[control]--;

            for (let k = 0; k < j; k++) {
                this.controlListEntries[control][k] = this.controlListEntries[
                    control
                ][k + 1];
            }
        }

        this.controlListEntries[control][j] = text;

        if (flag) {
            this.controlFlashText[control] = 999999;
        }
    }

    updateText(control, s) {
        this.controlText[control] = s;
    }

    getText(control) {
        if (this.controlText[control] === null) {
            return 'null';
        } else {
            return this.controlText[control];
        }
    }

    show(control) {
        this.controlShown[control] = true;
    }

    hide(control) {
        this.controlShown[control] = false;
    }

    setFocus(control) {
        this.focusControlIndex = control;
    }

    getListEntryIndex(control) {
        return this.controlListEntryMouseOver[control];
    }
}

Panel.baseSpriteStart = 0;
Panel.drawBackgroundArrow = true;
Panel.redMod = 114;
Panel.greenMod = 114;
Panel.blueMod = 176;
Panel.textListEntryHeightMod = 0;

module.exports = Panel;

},{"./surface":74}],70:[function(require,module,exports){
class Polygon {
    constructor() {
        this.minPlaneX = 0;
        this.minPlaneY = 0;
        this.maxPlaneX = 0;
        this.maxPlaneY = 0;
        this.minZ = 0;
        this.maxZ = 0;
        this.model = null;
        this.face = 0;
        this.depth = 0;
        this.normalX = 0;
        this.normalY = 0;
        this.normalZ = 0;
        this.visibility = 0;
        this.facefill = 0;
        this.skipSomething = false;
        this.index = 0;
        this.index2 = 0;
    }
}

module.exports = Polygon;
},{}],71:[function(require,module,exports){
class Scanline {
    constructor() {
        this.startX = 0;
        this.endX = 0;
        this.startS = 0;
        this.endS = 0;  
    }
}

module.exports = Scanline;
},{}],72:[function(require,module,exports){
const Long = require('long');
const Polygon = require('./polygon');
const Scanline = require('./scanline');

const COLOUR_TRANSPARENT = 12345678;

/*function polygonDepthSort(a, b) {
    if (a.depth === 0) {
        return 1;
    }

    if (a.depth === b.depth) {
        return 0;
    }

    return a.depth < b.depth ? 1 : -1;
}*/

class Scene {
    constructor(surface, maxModelCount, polygonCount, spriteCount) {
        this.lastVisiblePolygonsCount = 0;
        this.anIntArray377 = null;
        this.textureCount = 0;
        this.textureColoursUsed = null;
        this.textureColourList = null;
        this.textureDimension = null;
        this.textureLoadedNumber = null;
        this.texturePixels = null;
        this.textureBackTransparent = null;
        this.textureColours64 = null;
        this.textureColours128 = null;
        this.scanlines = null;
        this.minY = 0;
        this.maxY = 0;
        this.interlace = false;
        this.mouseX = 0;
        this.mouseY = 0;
        this.mousePickedCount = 0;
        this.newStart = 0;
        this.newEnd = 0;
        this.cameraX = 0;
        this.cameraY = 0;
        this.cameraZ = 0;
        this.cameraYaw = 0;
        this.cameraPitch = 0;
        this.cameraRoll = 0;

        this.rampCount = 50;
        this.gradientBase = new Int32Array(this.rampCount);

        this.gradientRamps = [];

        for (let _i = 0; _i < this.rampCount; _i += 1) {
            this.gradientRamps.push(new Int32Array(256));
        }

        this.clipNear = 5;
        this.clipFar3d = 1000;
        this.clipFar2d = 1000;
        this.fogZFalloff = 20;
        this.fogZDistance = 10;
        this.wideBand = false;
        this.mousePickingActive = false;
        this.mousePickedMax = 100;
        this.mousePickedModels = [];
        this.mousePickedModels.length = this.mousePickedMax;
        this.mousePickedModels.fill(null);
        this.mousePickedFaces = new Int32Array(this.mousePickedMax);
        this.width = 512;
        this.clipX = 256;
        this.clipY = 192;
        this.baseX = 256;
        this.baseY = 256;
        this.viewDistance = 8;
        this.normalMagnitude = 4;
        this.planeX = new Int32Array(40);
        this.planeY = new Int32Array(40);
        this.vertexShade = new Int32Array(40);
        this.vertexX = new Int32Array(40);
        this.vertexY = new Int32Array(40);
        this.vertexZ = new Int32Array(40);
        this.interlace = false;
        this.surface = surface;
        this.clipX = (surface.width2 / 2) | 0;
        this.clipY = (surface.height2 / 2) | 0;
        this.raster = surface.pixels;
        this.modelCount = 0;
        this.maxModelCount = maxModelCount;
        this.models = [];
        this.models.length = this.maxModelCount;
        this.models.fill(null);

        this.visiblePolygonsCount = 0;
        this.visiblePolygons = [];

        for (let l = 0; l < polygonCount; l++) {
            this.visiblePolygons.push(new Polygon());
        }

        this.spriteCount = 0;
        //this.view = new GameModel(k * 2, k);
        this.spriteId = new Int32Array(spriteCount);
        this.spriteWidth = new Int32Array(spriteCount);
        this.spriteHeight = new Int32Array(spriteCount);
        this.spriteX = new Int32Array(spriteCount);
        this.spriteZ = new Int32Array(spriteCount);
        this.spriteY = new Int32Array(spriteCount);
        this.spriteTranslateX = new Int32Array(spriteCount);

        if (this.aByteArray434 === null) {
            this.aByteArray434 = new Int8Array(17691);
        }

        this.cameraX = 0;
        this.cameraY = 0;
        this.cameraZ = 0;
        this.cameraYaw = 0;
        this.cameraPitch = 0;
        this.cameraRoll = 0;

        for (let i1 = 0; i1 < 256; i1++) {
            Scene.sin512Cache[i1] = (Math.sin(i1 * 0.02454369) * 32768) | 0;
            Scene.sin512Cache[i1 + 256] =
                (Math.cos(i1 * 0.02454369) * 32768) | 0;
        }

        for (let j1 = 0; j1 < 1024; j1++) {
            Scene.sinCosCache[j1] = (Math.sin(j1 * 0.00613592315) * 32768) | 0;
            Scene.sinCosCache[j1 + 1024] =
                (Math.cos(j1 * 0.00613592315) * 32768) | 0;
        }
    }

    static textureScanline(
        ai,
        ai1,
        i,
        j,
        k,
        l,
        i1,
        j1,
        k1,
        l1,
        i2,
        j2,
        k2,
        l2
    ) {
        if (i2 <= 0) {
            return;
        }

        let i3 = 0;
        let j3 = 0;
        let i4 = 0;

        if (i1 !== 0) {
            i = (k / i1) << 7;
            j = (l / i1) << 7;
        }

        if (i < 0) {
            i = 0;
        } else if (i > 16256) {
            i = 16256;
        }

        k += j1;
        l += k1;
        i1 += l1;

        if (i1 !== 0) {
            i3 = (k / i1) << 7;
            j3 = (l / i1) << 7;
        }

        if (i3 < 0) {
            i3 = 0;
        } else if (i3 > 16256) {
            i3 = 16256;
        }

        let k3 = (i3 - i) >> 4;
        let l3 = (j3 - j) >> 4;

        for (let j4 = i2 >> 4; j4 > 0; j4--) {
            i += k2 & 0x600000;
            i4 = k2 >> 23;
            k2 += l2;
            ai[j2++] = ai1[(j & 0x3f80) + (i >> 7)] >>> i4;
            i += k3;
            j += l3;
            ai[j2++] = ai1[(j & 0x3f80) + (i >> 7)] >>> i4;
            i += k3;
            j += l3;
            ai[j2++] = ai1[(j & 0x3f80) + (i >> 7)] >>> i4;
            i += k3;
            j += l3;
            ai[j2++] = ai1[(j & 0x3f80) + (i >> 7)] >>> i4;
            i += k3;
            j += l3;
            i = (i & 0x3fff) + (k2 & 0x600000);
            i4 = k2 >> 23;
            k2 += l2;
            ai[j2++] = ai1[(j & 0x3f80) + (i >> 7)] >>> i4;
            i += k3;
            j += l3;
            ai[j2++] = ai1[(j & 0x3f80) + (i >> 7)] >>> i4;
            i += k3;
            j += l3;
            ai[j2++] = ai1[(j & 0x3f80) + (i >> 7)] >>> i4;
            i += k3;
            j += l3;
            ai[j2++] = ai1[(j & 0x3f80) + (i >> 7)] >>> i4;
            i += k3;
            j += l3;
            i = (i & 0x3fff) + (k2 & 0x600000);
            i4 = k2 >> 23;
            k2 += l2;
            ai[j2++] = ai1[(j & 0x3f80) + (i >> 7)] >>> i4;
            i += k3;
            j += l3;
            ai[j2++] = ai1[(j & 0x3f80) + (i >> 7)] >>> i4;
            i += k3;
            j += l3;
            ai[j2++] = ai1[(j & 0x3f80) + (i >> 7)] >>> i4;
            i += k3;
            j += l3;
            ai[j2++] = ai1[(j & 0x3f80) + (i >> 7)] >>> i4;
            i += k3;
            j += l3;
            i = (i & 0x3fff) + (k2 & 0x600000);
            i4 = k2 >> 23;
            k2 += l2;
            ai[j2++] = ai1[(j & 0x3f80) + (i >> 7)] >>> i4;
            i += k3;
            j += l3;
            ai[j2++] = ai1[(j & 0x3f80) + (i >> 7)] >>> i4;
            i += k3;
            j += l3;
            ai[j2++] = ai1[(j & 0x3f80) + (i >> 7)] >>> i4;
            i += k3;
            j += l3;
            ai[j2++] = ai1[(j & 0x3f80) + (i >> 7)] >>> i4;
            i = i3;
            j = j3;
            k += j1;
            l += k1;
            i1 += l1;

            if (i1 !== 0) {
                i3 = (k / i1) << 7;
                j3 = (l / i1) << 7;
            }

            if (i3 < 0) {
                i3 = 0;
            } else if (i3 > 16256) {
                i3 = 16256;
            }

            k3 = (i3 - i) >> 4;
            l3 = (j3 - j) >> 4;
        }

        for (let k4 = 0; k4 < (i2 & 0xf); k4++) {
            if ((k4 & 3) === 0) {
                i = (i & 0x3fff) + (k2 & 0x600000);
                i4 = k2 >> 23;
                k2 += l2;
            }

            ai[j2++] = ai1[(j & 0x3f80) + (i >> 7)] >>> i4;
            i += k3;
            j += l3;
        }
    }

    static textureTranslucentScanline(
        ai,
        ai1,
        i,
        j,
        k,
        l,
        i1,
        j1,
        k1,
        l1,
        i2,
        j2,
        k2,
        l2
    ) {
        if (i2 <= 0) {
            return;
        }

        let i3 = 0;
        let j3 = 0;
        let i4 = 0;

        if (i1 !== 0) {
            i = (k / i1) << 7;
            j = (l / i1) << 7;
        }

        if (i < 0) {
            i = 0;
        } else if (i > 16256) {
            i = 16256;
        }

        k += j1;
        l += k1;
        i1 += l1;

        if (i1 !== 0) {
            i3 = (k / i1) << 7;
            j3 = (l / i1) << 7;
        }

        if (i3 < 0) {
            i3 = 0;
        } else if (i3 > 16256) {
            i3 = 16256;
        }

        let k3 = (i3 - i) >> 4;
        let l3 = (j3 - j) >> 4;

        for (let j4 = i2 >> 4; j4 > 0; j4--) {
            i += k2 & 0x600000;
            i4 = k2 >> 23;
            k2 += l2;
            ai[j2++] =
                (ai1[(j & 0x3f80) + (i >> 7)] >>> i4) +
                ((ai[j2] >> 1) & 0x7f7f7f);
            i += k3;
            j += l3;
            ai[j2++] =
                (ai1[(j & 0x3f80) + (i >> 7)] >>> i4) +
                ((ai[j2] >> 1) & 0x7f7f7f);
            i += k3;
            j += l3;
            ai[j2++] =
                (ai1[(j & 0x3f80) + (i >> 7)] >>> i4) +
                ((ai[j2] >> 1) & 0x7f7f7f);
            i += k3;
            j += l3;
            ai[j2++] =
                (ai1[(j & 0x3f80) + (i >> 7)] >>> i4) +
                ((ai[j2] >> 1) & 0x7f7f7f);
            i += k3;
            j += l3;
            i = (i & 0x3fff) + (k2 & 0x600000);
            i4 = k2 >> 23;
            k2 += l2;
            ai[j2++] =
                (ai1[(j & 0x3f80) + (i >> 7)] >>> i4) +
                ((ai[j2] >> 1) & 0x7f7f7f);
            i += k3;
            j += l3;
            ai[j2++] =
                (ai1[(j & 0x3f80) + (i >> 7)] >>> i4) +
                ((ai[j2] >> 1) & 0x7f7f7f);
            i += k3;
            j += l3;
            ai[j2++] =
                (ai1[(j & 0x3f80) + (i >> 7)] >>> i4) +
                ((ai[j2] >> 1) & 0x7f7f7f);
            i += k3;
            j += l3;
            ai[j2++] =
                (ai1[(j & 0x3f80) + (i >> 7)] >>> i4) +
                ((ai[j2] >> 1) & 0x7f7f7f);
            i += k3;
            j += l3;
            i = (i & 0x3fff) + (k2 & 0x600000);
            i4 = k2 >> 23;
            k2 += l2;
            ai[j2++] =
                (ai1[(j & 0x3f80) + (i >> 7)] >>> i4) +
                ((ai[j2] >> 1) & 0x7f7f7f);
            i += k3;
            j += l3;
            ai[j2++] =
                (ai1[(j & 0x3f80) + (i >> 7)] >>> i4) +
                ((ai[j2] >> 1) & 0x7f7f7f);
            i += k3;
            j += l3;
            ai[j2++] =
                (ai1[(j & 0x3f80) + (i >> 7)] >>> i4) +
                ((ai[j2] >> 1) & 0x7f7f7f);
            i += k3;
            j += l3;
            ai[j2++] =
                (ai1[(j & 0x3f80) + (i >> 7)] >>> i4) +
                ((ai[j2] >> 1) & 0x7f7f7f);
            i += k3;
            j += l3;
            i = (i & 0x3fff) + (k2 & 0x600000);
            i4 = k2 >> 23;
            k2 += l2;
            ai[j2++] =
                (ai1[(j & 0x3f80) + (i >> 7)] >>> i4) +
                ((ai[j2] >> 1) & 0x7f7f7f);
            i += k3;
            j += l3;
            ai[j2++] =
                (ai1[(j & 0x3f80) + (i >> 7)] >>> i4) +
                ((ai[j2] >> 1) & 0x7f7f7f);
            i += k3;
            j += l3;
            ai[j2++] =
                (ai1[(j & 0x3f80) + (i >> 7)] >>> i4) +
                ((ai[j2] >> 1) & 0x7f7f7f);
            i += k3;
            j += l3;
            ai[j2++] =
                (ai1[(j & 0x3f80) + (i >> 7)] >>> i4) +
                ((ai[j2] >> 1) & 0x7f7f7f);
            i = i3;
            j = j3;
            k += j1;
            l += k1;
            i1 += l1;

            if (i1 !== 0) {
                i3 = (k / i1) << 7;
                j3 = (l / i1) << 7;
            }

            if (i3 < 0) {
                i3 = 0;
            } else if (i3 > 16256) {
                i3 = 16256;
            }

            k3 = (i3 - i) >> 4;
            l3 = (j3 - j) >> 4;
        }

        for (let k4 = 0; k4 < (i2 & 0xf); k4++) {
            if ((k4 & 3) === 0) {
                i = (i & 0x3fff) + (k2 & 0x600000);
                i4 = k2 >> 23;
                k2 += l2;
            }

            ai[j2++] =
                (ai1[(j & 0x3f80) + (i >> 7)] >>> i4) +
                ((ai[j2] >> 1) & 0x7f7f7f);
            i += k3;
            j += l3;
        }
    }

    static textureBackTranslucentScanline(
        ai,
        i,
        j,
        k,
        ai1,
        l,
        i1,
        j1,
        k1,
        l1,
        i2,
        j2,
        k2,
        l2,
        i3
    ) {
        if (j2 <= 0) {
            return;
        }

        let j3 = 0;
        let k3 = 0;
        i3 <<= 2;

        if (j1 !== 0) {
            j3 = (l / j1) << 7;
            k3 = (i1 / j1) << 7;
        }

        if (j3 < 0) {
            j3 = 0;
        } else if (j3 > 16256) {
            j3 = 16256;
        }

        for (let j4 = j2; j4 > 0; j4 -= 16) {
            l += k1;
            i1 += l1;
            j1 += i2;
            j = j3;
            k = k3;

            if (j1 !== 0) {
                j3 = (l / j1) << 7;
                k3 = (i1 / j1) << 7;
            }

            if (j3 < 0) {
                j3 = 0;
            } else if (j3 > 16256) {
                j3 = 16256;
            }

            let l3 = (j3 - j) >> 4;
            let i4 = (k3 - k) >> 4;
            let k4 = l2 >> 23;

            j += l2 & 0x600000;
            l2 += i3;

            if (j4 < 16) {
                for (let l4 = 0; l4 < j4; l4++) {
                    if ((i = ai1[(k & 0x3f80) + (j >> 7)] >>> k4) !== 0) {
                        ai[k2] = i;
                    }

                    k2++;
                    j += l3;
                    k += i4;

                    if ((l4 & 3) === 3) {
                        j = (j & 0x3fff) + (l2 & 0x600000);
                        k4 = l2 >> 23;
                        l2 += i3;
                    }
                }
            } else {
                if ((i = ai1[(k & 0x3f80) + (j >> 7)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;

                if ((i = ai1[(k & 0x3f80) + (j >> 7)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;

                if ((i = ai1[(k & 0x3f80) + (j >> 7)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;

                if ((i = ai1[(k & 0x3f80) + (j >> 7)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;
                j = (j & 0x3fff) + (l2 & 0x600000);
                k4 = l2 >> 23;
                l2 += i3;

                if ((i = ai1[(k & 0x3f80) + (j >> 7)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;

                if ((i = ai1[(k & 0x3f80) + (j >> 7)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;

                if ((i = ai1[(k & 0x3f80) + (j >> 7)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;

                if ((i = ai1[(k & 0x3f80) + (j >> 7)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;
                j = (j & 0x3fff) + (l2 & 0x600000);
                k4 = l2 >> 23;
                l2 += i3;

                if ((i = ai1[(k & 0x3f80) + (j >> 7)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;

                if ((i = ai1[(k & 0x3f80) + (j >> 7)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;

                if ((i = ai1[(k & 0x3f80) + (j >> 7)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;

                if ((i = ai1[(k & 0x3f80) + (j >> 7)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;
                j = (j & 0x3fff) + (l2 & 0x600000);
                k4 = l2 >> 23;
                l2 += i3;

                if ((i = ai1[(k & 0x3f80) + (j >> 7)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;

                if ((i = ai1[(k & 0x3f80) + (j >> 7)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;

                if ((i = ai1[(k & 0x3f80) + (j >> 7)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;

                if ((i = ai1[(k & 0x3f80) + (j >> 7)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
            }
        }
    }

    static textureScanline2(
        ai,
        ai1,
        i,
        j,
        k,
        l,
        i1,
        j1,
        k1,
        l1,
        i2,
        j2,
        k2,
        l2
    ) {
        if (i2 <= 0) {
            return;
        }

        let i3 = 0;
        let j3 = 0;
        l2 <<= 2;

        if (i1 !== 0) {
            i3 = (k / i1) << 6;
            j3 = (l / i1) << 6;
        }

        if (i3 < 0) {
            i3 = 0;
        } else if (i3 > 4032) {
            i3 = 4032;
        }

        for (let i4 = i2; i4 > 0; i4 -= 16) {
            k += j1;
            l += k1;
            i1 += l1;
            i = i3;
            j = j3;

            if (i1 !== 0) {
                i3 = (k / i1) << 6;
                j3 = (l / i1) << 6;
            }

            if (i3 < 0) {
                i3 = 0;
            } else if (i3 > 4032) {
                i3 = 4032;
            }

            let k3 = (i3 - i) >> 4;
            let l3 = (j3 - j) >> 4;
            let j4 = k2 >> 20;
            i += k2 & 0xc0000;
            k2 += l2;

            if (i4 < 16) {
                for (let k4 = 0; k4 < i4; k4++) {
                    ai[j2++] = ai1[(j & 0xfc0) + (i >> 6)] >>> j4;
                    i += k3;
                    j += l3;

                    if ((k4 & 3) === 3) {
                        i = (i & 0xfff) + (k2 & 0xc0000);
                        j4 = k2 >> 20;
                        k2 += l2;
                    }
                }
            } else {
                ai[j2++] = ai1[(j & 0xfc0) + (i >> 6)] >>> j4;
                i += k3;
                j += l3;
                ai[j2++] = ai1[(j & 0xfc0) + (i >> 6)] >>> j4;
                i += k3;
                j += l3;
                ai[j2++] = ai1[(j & 0xfc0) + (i >> 6)] >>> j4;
                i += k3;
                j += l3;
                ai[j2++] = ai1[(j & 0xfc0) + (i >> 6)] >>> j4;
                i += k3;
                j += l3;
                i = (i & 0xfff) + (k2 & 0xc0000);
                j4 = k2 >> 20;
                k2 += l2;
                ai[j2++] = ai1[(j & 0xfc0) + (i >> 6)] >>> j4;
                i += k3;
                j += l3;
                ai[j2++] = ai1[(j & 0xfc0) + (i >> 6)] >>> j4;
                i += k3;
                j += l3;
                ai[j2++] = ai1[(j & 0xfc0) + (i >> 6)] >>> j4;
                i += k3;
                j += l3;
                ai[j2++] = ai1[(j & 0xfc0) + (i >> 6)] >>> j4;
                i += k3;
                j += l3;
                i = (i & 0xfff) + (k2 & 0xc0000);
                j4 = k2 >> 20;
                k2 += l2;
                ai[j2++] = ai1[(j & 0xfc0) + (i >> 6)] >>> j4;
                i += k3;
                j += l3;
                ai[j2++] = ai1[(j & 0xfc0) + (i >> 6)] >>> j4;
                i += k3;
                j += l3;
                ai[j2++] = ai1[(j & 0xfc0) + (i >> 6)] >>> j4;
                i += k3;
                j += l3;
                ai[j2++] = ai1[(j & 0xfc0) + (i >> 6)] >>> j4;
                i += k3;
                j += l3;
                i = (i & 0xfff) + (k2 & 0xc0000);
                j4 = k2 >> 20;
                k2 += l2;
                ai[j2++] = ai1[(j & 0xfc0) + (i >> 6)] >>> j4;
                i += k3;
                j += l3;
                ai[j2++] = ai1[(j & 0xfc0) + (i >> 6)] >>> j4;
                i += k3;
                j += l3;
                ai[j2++] = ai1[(j & 0xfc0) + (i >> 6)] >>> j4;
                i += k3;
                j += l3;
                ai[j2++] = ai1[(j & 0xfc0) + (i >> 6)] >>> j4;
            }
        }
    }

    static textureTranslucentScanline2(
        ai,
        ai1,
        i,
        j,
        k,
        l,
        i1,
        j1,
        k1,
        l1,
        i2,
        j2,
        k2,
        l2
    ) {
        if (i2 <= 0) {
            return;
        }

        let i3 = 0;
        let j3 = 0;
        l2 <<= 2;

        if (i1 !== 0) {
            i3 = (k / i1) << 6;
            j3 = (l / i1) << 6;
        }

        if (i3 < 0) {
            i3 = 0;
        } else if (i3 > 4032) {
            i3 = 4032;
        }

        for (let i4 = i2; i4 > 0; i4 -= 16) {
            k += j1;
            l += k1;
            i1 += l1;
            i = i3;
            j = j3;

            if (i1 !== 0) {
                i3 = (k / i1) << 6;
                j3 = (l / i1) << 6;
            }

            if (i3 < 0) {
                i3 = 0;
            } else if (i3 > 4032) {
                i3 = 4032;
            }

            let k3 = (i3 - i) >> 4;
            let l3 = (j3 - j) >> 4;
            let j4 = k2 >> 20;
            i += k2 & 0xc0000;
            k2 += l2;

            if (i4 < 16) {
                for (let k4 = 0; k4 < i4; k4++) {
                    ai[j2++] =
                        (ai1[(j & 0xfc0) + (i >> 6)] >>> j4) +
                        ((ai[j2] >> 1) & 0x7f7f7f);
                    i += k3;
                    j += l3;

                    if ((k4 & 3) === 3) {
                        i = (i & 0xfff) + (k2 & 0xc0000);
                        j4 = k2 >> 20;
                        k2 += l2;
                    }
                }
            } else {
                ai[j2++] =
                    (ai1[(j & 0xfc0) + (i >> 6)] >>> j4) +
                    ((ai[j2] >> 1) & 0x7f7f7f);
                i += k3;
                j += l3;
                ai[j2++] =
                    (ai1[(j & 0xfc0) + (i >> 6)] >>> j4) +
                    ((ai[j2] >> 1) & 0x7f7f7f);
                i += k3;
                j += l3;
                ai[j2++] =
                    (ai1[(j & 0xfc0) + (i >> 6)] >>> j4) +
                    ((ai[j2] >> 1) & 0x7f7f7f);
                i += k3;
                j += l3;
                ai[j2++] =
                    (ai1[(j & 0xfc0) + (i >> 6)] >>> j4) +
                    ((ai[j2] >> 1) & 0x7f7f7f);
                i += k3;
                j += l3;
                i = (i & 0xfff) + (k2 & 0xc0000);
                j4 = k2 >> 20;
                k2 += l2;
                ai[j2++] =
                    (ai1[(j & 0xfc0) + (i >> 6)] >>> j4) +
                    ((ai[j2] >> 1) & 0x7f7f7f);
                i += k3;
                j += l3;
                ai[j2++] =
                    (ai1[(j & 0xfc0) + (i >> 6)] >>> j4) +
                    ((ai[j2] >> 1) & 0x7f7f7f);
                i += k3;
                j += l3;
                ai[j2++] =
                    (ai1[(j & 0xfc0) + (i >> 6)] >>> j4) +
                    ((ai[j2] >> 1) & 0x7f7f7f);
                i += k3;
                j += l3;
                ai[j2++] =
                    (ai1[(j & 0xfc0) + (i >> 6)] >>> j4) +
                    ((ai[j2] >> 1) & 0x7f7f7f);
                i += k3;
                j += l3;
                i = (i & 0xfff) + (k2 & 0xc0000);
                j4 = k2 >> 20;
                k2 += l2;
                ai[j2++] =
                    (ai1[(j & 0xfc0) + (i >> 6)] >>> j4) +
                    ((ai[j2] >> 1) & 0x7f7f7f);
                i += k3;
                j += l3;
                ai[j2++] =
                    (ai1[(j & 0xfc0) + (i >> 6)] >>> j4) +
                    ((ai[j2] >> 1) & 0x7f7f7f);
                i += k3;
                j += l3;
                ai[j2++] =
                    (ai1[(j & 0xfc0) + (i >> 6)] >>> j4) +
                    ((ai[j2] >> 1) & 0x7f7f7f);
                i += k3;
                j += l3;
                ai[j2++] =
                    (ai1[(j & 0xfc0) + (i >> 6)] >>> j4) +
                    ((ai[j2] >> 1) & 0x7f7f7f);
                i += k3;
                j += l3;
                i = (i & 0xfff) + (k2 & 0xc0000);
                j4 = k2 >> 20;
                k2 += l2;
                ai[j2++] =
                    (ai1[(j & 0xfc0) + (i >> 6)] >>> j4) +
                    ((ai[j2] >> 1) & 0x7f7f7f);
                i += k3;
                j += l3;
                ai[j2++] =
                    (ai1[(j & 0xfc0) + (i >> 6)] >>> j4) +
                    ((ai[j2] >> 1) & 0x7f7f7f);
                i += k3;
                j += l3;
                ai[j2++] =
                    (ai1[(j & 0xfc0) + (i >> 6)] >>> j4) +
                    ((ai[j2] >> 1) & 0x7f7f7f);
                i += k3;
                j += l3;
                ai[j2++] =
                    (ai1[(j & 0xfc0) + (i >> 6)] >>> j4) +
                    ((ai[j2] >> 1) & 0x7f7f7f);
            }
        }
    }

    static textureBackTranslucentScanline2(
        ai,
        i,
        j,
        k,
        ai1,
        l,
        i1,
        j1,
        k1,
        l1,
        i2,
        j2,
        k2,
        l2,
        i3
    ) {
        if (j2 <= 0) {
            return;
        }

        let j3 = 0;
        let k3 = 0;
        i3 <<= 2;

        if (j1 !== 0) {
            j3 = (l / j1) << 6;
            k3 = (i1 / j1) << 6;
        }

        if (j3 < 0) {
            j3 = 0;
        } else if (j3 > 4032) {
            j3 = 4032;
        }

        for (let j4 = j2; j4 > 0; j4 -= 16) {
            l += k1;
            i1 += l1;
            j1 += i2;
            j = j3;
            k = k3;

            if (j1 !== 0) {
                j3 = (l / j1) << 6;
                k3 = (i1 / j1) << 6;
            }

            if (j3 < 0) {
                j3 = 0;
            } else if (j3 > 4032) {
                j3 = 4032;
            }

            let l3 = (j3 - j) >> 4;
            let i4 = (k3 - k) >> 4;
            let k4 = l2 >> 20;
            j += l2 & 0xc0000;
            l2 += i3;

            if (j4 < 16) {
                for (let l4 = 0; l4 < j4; l4++) {
                    if ((i = ai1[(k & 0xfc0) + (j >> 6)] >>> k4) !== 0) {
                        ai[k2] = i;
                    }

                    k2++;
                    j += l3;
                    k += i4;

                    if ((l4 & 3) === 3) {
                        j = (j & 0xfff) + (l2 & 0xc0000);
                        k4 = l2 >> 20;
                        l2 += i3;
                    }
                }
            } else {
                if ((i = ai1[(k & 0xfc0) + (j >> 6)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;

                if ((i = ai1[(k & 0xfc0) + (j >> 6)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;

                if ((i = ai1[(k & 0xfc0) + (j >> 6)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;

                if ((i = ai1[(k & 0xfc0) + (j >> 6)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;
                j = (j & 0xfff) + (l2 & 0xc0000);
                k4 = l2 >> 20;
                l2 += i3;

                if ((i = ai1[(k & 0xfc0) + (j >> 6)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;

                if ((i = ai1[(k & 0xfc0) + (j >> 6)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;

                if ((i = ai1[(k & 0xfc0) + (j >> 6)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;

                if ((i = ai1[(k & 0xfc0) + (j >> 6)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;
                j = (j & 0xfff) + (l2 & 0xc0000);
                k4 = l2 >> 20;
                l2 += i3;

                if ((i = ai1[(k & 0xfc0) + (j >> 6)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;

                if ((i = ai1[(k & 0xfc0) + (j >> 6)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;

                if ((i = ai1[(k & 0xfc0) + (j >> 6)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;

                if ((i = ai1[(k & 0xfc0) + (j >> 6)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;
                j = (j & 0xfff) + (l2 & 0xc0000);
                k4 = l2 >> 20;
                l2 += i3;

                if ((i = ai1[(k & 0xfc0) + (j >> 6)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;

                if ((i = ai1[(k & 0xfc0) + (j >> 6)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;

                if ((i = ai1[(k & 0xfc0) + (j >> 6)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
                j += l3;
                k += i4;

                if ((i = ai1[(k & 0xfc0) + (j >> 6)] >>> k4) !== 0) {
                    ai[k2] = i;
                }

                k2++;
            }
        }
    }

    static gradientScanline(ai, i, j, k, ai1, l, i1) {
        if (i >= 0) {
            return;
        }

        i1 <<= 1;
        k = ai1[(l >> 8) & 0xff];
        l += i1;
        let j1 = (i / 8) | 0;

        for (let k1 = j1; k1 < 0; k1++) {
            ai[j++] = k;
            ai[j++] = k;
            k = ai1[(l >> 8) & 0xff];
            l += i1;
            ai[j++] = k;
            ai[j++] = k;
            k = ai1[(l >> 8) & 0xff];
            l += i1;
            ai[j++] = k;
            ai[j++] = k;
            k = ai1[(l >> 8) & 0xff];
            l += i1;
            ai[j++] = k;
            ai[j++] = k;
            k = ai1[(l >> 8) & 0xff];
            l += i1;
        }

        j1 = -(i % 8);

        for (let l1 = 0; l1 < j1; l1++) {
            ai[j++] = k;

            if ((l1 & 1) === 1) {
                k = ai1[(l >> 8) & 0xff];
                l += i1;
            }
        }
    }

    static textureGradientScanline(ai, i, j, k, ai1, l, i1) {
        if (i >= 0) {
            return;
        }

        i1 <<= 2;
        k = ai1[(l >> 8) & 0xff];
        l += i1;
        let j1 = (i / 16) | 0;

        for (let k1 = j1; k1 < 0; k1++) {
            ai[j++] = k + ((ai[j] >> 1) & 0x7f7f7f);
            ai[j++] = k + ((ai[j] >> 1) & 0x7f7f7f);
            ai[j++] = k + ((ai[j] >> 1) & 0x7f7f7f);
            ai[j++] = k + ((ai[j] >> 1) & 0x7f7f7f);
            k = ai1[(l >> 8) & 0xff];
            l += i1;
            ai[j++] = k + ((ai[j] >> 1) & 0x7f7f7f);
            ai[j++] = k + ((ai[j] >> 1) & 0x7f7f7f);
            ai[j++] = k + ((ai[j] >> 1) & 0x7f7f7f);
            ai[j++] = k + ((ai[j] >> 1) & 0x7f7f7f);
            k = ai1[(l >> 8) & 0xff];
            l += i1;
            ai[j++] = k + ((ai[j] >> 1) & 0x7f7f7f);
            ai[j++] = k + ((ai[j] >> 1) & 0x7f7f7f);
            ai[j++] = k + ((ai[j] >> 1) & 0x7f7f7f);
            ai[j++] = k + ((ai[j] >> 1) & 0x7f7f7f);
            k = ai1[(l >> 8) & 0xff];
            l += i1;
            ai[j++] = k + ((ai[j] >> 1) & 0x7f7f7f);
            ai[j++] = k + ((ai[j] >> 1) & 0x7f7f7f);
            ai[j++] = k + ((ai[j] >> 1) & 0x7f7f7f);
            ai[j++] = k + ((ai[j] >> 1) & 0x7f7f7f);
            k = ai1[(l >> 8) & 0xff];
            l += i1;
        }

        j1 = -(i % 16);

        for (let l1 = 0; l1 < j1; l1++) {
            ai[j++] = k + ((ai[j] >> 1) & 0x7f7f7f);

            if ((l1 & 3) === 3) {
                k = ai1[(l >> 8) & 0xff];
                l += i1;
                l += i1;
            }
        }
    }

    static gradientScanline2(ai, i, j, k, ai1, l, i1) {
        if (i >= 0) {
            return;
        }

        i1 <<= 2;
        k = ai1[(l >> 8) & 0xff];
        l += i1;
        let j1 = (i / 16) | 0;

        for (let k1 = j1; k1 < 0; k1++) {
            ai[j++] = k;
            ai[j++] = k;
            ai[j++] = k;
            ai[j++] = k;
            k = ai1[(l >> 8) & 0xff];
            l += i1;
            ai[j++] = k;
            ai[j++] = k;
            ai[j++] = k;
            ai[j++] = k;
            k = ai1[(l >> 8) & 0xff];
            l += i1;
            ai[j++] = k;
            ai[j++] = k;
            ai[j++] = k;
            ai[j++] = k;
            k = ai1[(l >> 8) & 0xff];
            l += i1;
            ai[j++] = k;
            ai[j++] = k;
            ai[j++] = k;
            ai[j++] = k;
            k = ai1[(l >> 8) & 0xff];
            l += i1;
        }

        j1 = -(i % 16);

        for (let l1 = 0; l1 < j1; l1++) {
            ai[j++] = k;

            if ((l1 & 3) === 3) {
                k = ai1[(l >> 8) & 0xff];
                l += i1;
            }
        }
    }

    static rgb(i, j, k) {
        return -1 - ((i / 8) | 0) * 1024 - ((j / 8) | 0) * 32 - ((k / 8) | 0);
    }

    addModel(model) {
        if (model === null) {
            console.log('Warning tried to add null object!');
        }

        if (this.modelCount < this.maxModelCount) {
            this.models[this.modelCount++] = model;
        }
    }

    removeModel(gameModel) {
        for (let i = 0; i < this.modelCount; i++) {
            if (this.models[i] === gameModel) {
                this.modelCount--;

                for (let j = i; j < this.modelCount; j++) {
                    this.models[j] = this.models[j + 1];
                }
            }
        }
    }

    dispose() {
        this.clear();

        for (let i = 0; i < this.modelCount; i++) {
            this.models[i] = null;
        }

        this.modelCount = 0;
    }

    clear() {
        this.spriteCount = 0;
        this.view.clear();
    }

    reduceSprites(i) {
        this.spriteCount -= i;
        this.view.reduce(i, i * 2);

        if (this.spriteCount < 0) {
            this.spriteCount = 0;
        }
    }

    addSprite(n, x, z, y, w, h, tag) {
        this.spriteId[this.spriteCount] = n;
        this.spriteX[this.spriteCount] = x;
        this.spriteZ[this.spriteCount] = z;
        this.spriteY[this.spriteCount] = y;
        this.spriteWidth[this.spriteCount] = w;
        this.spriteHeight[this.spriteCount] = h;
        this.spriteTranslateX[this.spriteCount] = 0;

        const bottomVert = this.view.createVertex(x, z, y);
        const topVert = this.view.createVertex(x, z - h, y);
        const vertexes = new Int32Array([bottomVert, topVert]);

        this.view.createFace(2, vertexes, 0, 0);
        this.view.faceTag[this.spriteCount] = tag;
        this.view.isLocalPlayer[this.spriteCount++] = 0;

        return this.spriteCount - 1;
    }

    setLocalPlayer(i) {
        this.view.isLocalPlayer[i] = 1;
    }

    setSpriteTranslateX(i, n) {
        this.spriteTranslateX[i] = n;
    }

    setMouseLoc(x, y) {
        this.mouseX = x - this.baseX;
        this.mouseY = y;
        this.mousePickedCount = 0;
        this.mousePickingActive = true;
    }

    getMousePickedCount() {
        return this.mousePickedCount;
    }

    getMousePickedFaces() {
        return this.mousePickedFaces;
    }

    getMousePickedModels() {
        return this.mousePickedModels;
    }

    setBounds(baseX, baseY, clipX, clipY, width, viewDistance) {
        this.clipX = clipX;
        this.clipY = clipY;
        this.baseX = baseX;
        this.baseY = baseY;
        this.width = width;
        this.viewDistance = viewDistance;
        this.scanlines = [];

        for (let k1 = 0; k1 < clipY + baseY; k1++) {
            this.scanlines.push(new Scanline());
        }
    }

    polygonsQSort(polygons, low, high) {
        if (low < high) {
            let min = low - 1;
            let max = high + 1;
            let mid = ((low + high) / 2) | 0;
            let polygon = polygons[mid];
            polygons[mid] = polygons[low];
            polygons[low] = polygon;
            let j1 = polygon.depth;

            while (min < max) {
                do {
                    max--;
                } while (polygons[max].depth < j1);

                do {
                    min++;
                } while (polygons[min].depth > j1);

                if (min < max) {
                    let polygon_1 = polygons[min];
                    polygons[min] = polygons[max];
                    polygons[max] = polygon_1;
                }
            }

            this.polygonsQSort(polygons, low, max);
            this.polygonsQSort(polygons, max + 1, high);
        }
    }

    polygonsIntersectSort(step, polygons, count) {
        for (let i = 0; i <= count; i++) {
            polygons[i].skipSomething = false;
            polygons[i].index = i;
            polygons[i].index2 = -1;
        }

        let l = 0;

        do {
            while (polygons[l].skipSomething) {
                l++;
            }

            if (l === count) {
                return;
            }

            let polygon = polygons[l];
            polygon.skipSomething = true;
            let i1 = l;
            let j1 = l + step;

            if (j1 >= count) {
                j1 = count - 1;
            }

            for (let k1 = j1; k1 >= i1 + 1; k1--) {
                let other = polygons[k1];

                if (
                    polygon.minPlaneX < other.maxPlaneX &&
                    other.minPlaneX < polygon.maxPlaneX &&
                    polygon.minPlaneY < other.maxPlaneY &&
                    other.minPlaneY < polygon.maxPlaneY &&
                    polygon.index !== other.index2 &&
                    !this.separatePolygon(polygon, other) &&
                    this.heuristicPolygon(other, polygon)
                ) {
                    this.polygonsOrder(polygons, i1, k1);

                    if (polygons[k1] !== other) {
                        k1++;
                    }

                    i1 = this.newStart;
                    other.index2 = polygon.index;
                }
            }
        } while (true);
    }

    polygonsOrder(polygons, start, end) {
        do {
            let polygon = polygons[start];

            for (let k = start + 1; k <= end; k++) {
                let polygon_1 = polygons[k];

                if (!this.separatePolygon(polygon_1, polygon)) {
                    break;
                }

                polygons[start] = polygon_1;
                polygons[k] = polygon;
                start = k;

                if (start === end) {
                    this.newStart = start;
                    this.newEnd = start - 1;

                    return true;
                }
            }

            let polygon_2 = polygons[end];

            for (let l = end - 1; l >= start; l--) {
                let polygon_3 = polygons[l];

                if (!this.separatePolygon(polygon_2, polygon_3)) {
                    break;
                }

                polygons[end] = polygon_3;
                polygons[l] = polygon_2;
                end = l;

                if (start === end) {
                    this.newStart = end + 1;
                    this.newEnd = end;

                    return true;
                }
            }

            if (start + 1 >= end) {
                this.newStart = start;
                this.newEnd = end;

                return false;
            }

            if (!this.polygonsOrder(polygons, start + 1, end)) {
                this.newStart = start;

                return false;
            }

            end = this.newEnd;
        } while (true);
    }

    setFrustum(i, j, k) {
        let l = (-this.cameraYaw + 1024) & 0x3ff;
        let i1 = (-this.cameraPitch + 1024) & 0x3ff;
        let j1 = (-this.cameraRoll + 1024) & 0x3ff;

        if (j1 !== 0) {
            let k1 = Scene.sinCosCache[j1];
            let j2 = Scene.sinCosCache[j1 + 1024];
            let i3 = (j * k1 + i * j2) >> 15;
            j = (j * j2 - i * k1) >> 15;
            i = i3;
        }

        if (l !== 0) {
            let l1 = Scene.sinCosCache[l];
            let k2 = Scene.sinCosCache[l + 1024];
            let j3 = (j * k2 - k * l1) >> 15;
            k = (j * l1 + k * k2) >> 15;
            j = j3;
        }

        if (i1 !== 0) {
            let i2 = Scene.sinCosCache[i1];
            let l2 = Scene.sinCosCache[i1 + 1024];
            let k3 = (k * i2 + i * l2) >> 15;
            k = (k * l2 - i * i2) >> 15;
            i = k3;
        }

        if (i < Scene.frustumMaxX) {
            Scene.frustumMaxX = i;
        }

        if (i > Scene.frustumMinX) {
            Scene.frustumMinX = i;
        }

        if (j < Scene.frustumMaxY) {
            Scene.frustumMaxY = j;
        }

        if (j > Scene.frustumMinY) {
            Scene.frustumMinY = j;
        }

        if (k < Scene.frustumFarZ) {
            Scene.frustumFarZ = k;
        }

        if (k > Scene.frustumNearZ) {
            Scene.frustumNearZ = k;
        }
    }

    render() {
        this.interlace = this.surface.interlace;
        let i3 = (this.clipX * this.clipFar3d) >> this.viewDistance;
        let j3 = (this.clipY * this.clipFar3d) >> this.viewDistance;

        Scene.frustumMaxX = 0;
        Scene.frustumMinX = 0;
        Scene.frustumMaxY = 0;
        Scene.frustumMinY = 0;
        Scene.frustumFarZ = 0;
        Scene.frustumNearZ = 0;

        this.setFrustum(-i3, -j3, this.clipFar3d);
        this.setFrustum(-i3, j3, this.clipFar3d);
        this.setFrustum(i3, -j3, this.clipFar3d);
        this.setFrustum(i3, j3, this.clipFar3d);
        this.setFrustum(-this.clipX, -this.clipY, 0);
        this.setFrustum(-this.clipX, this.clipY, 0);
        this.setFrustum(this.clipX, -this.clipY, 0);
        this.setFrustum(this.clipX, this.clipY, 0);

        Scene.frustumMaxX += this.cameraX;
        Scene.frustumMinX += this.cameraX;
        Scene.frustumMaxY += this.cameraY;
        Scene.frustumMinY += this.cameraY;
        Scene.frustumFarZ += this.cameraZ;
        Scene.frustumNearZ += this.cameraZ;

        this.models[this.modelCount] = this.view;
        this.view.transformState = 2;

        for (let i = 0; i < this.modelCount; i++) {
            this.models[i].project(
                this.cameraX,
                this.cameraY,
                this.cameraZ,
                this.cameraYaw,
                this.cameraPitch,
                this.cameraRoll,
                this.viewDistance,
                this.clipNear
            );
        }

        this.models[this.modelCount].project(
            this.cameraX,
            this.cameraY,
            this.cameraZ,
            this.cameraYaw,
            this.cameraPitch,
            this.cameraRoll,
            this.viewDistance,
            this.clipNear
        );

        this.visiblePolygonsCount = 0;

        for (let count = 0; count < this.modelCount; count++) {
            let gameModel = this.models[count];

            if (gameModel.visible) {
                for (let face = 0; face < gameModel.numFaces; face++) {
                    let num_vertices = gameModel.faceNumVertices[face];
                    let vertices = gameModel.faceVertices[face];
                    let visible = false;

                    for (let vertex = 0; vertex < num_vertices; vertex++) {
                        let z = gameModel.projectVertexZ[vertices[vertex]];

                        if (z <= this.clipNear || z >= this.clipFar3d) {
                            continue;
                        }

                        visible = true;
                        break;
                    }

                    if (visible) {
                        let viewXCount = 0;

                        for (let vertex = 0; vertex < num_vertices; vertex++) {
                            let x = gameModel.vertexViewX[vertices[vertex]];

                            if (x > -this.clipX) {
                                viewXCount |= 1;
                            }

                            if (x < this.clipX) {
                                viewXCount |= 2;
                            }

                            if (viewXCount === 3) {
                                break;
                            }
                        }

                        if (viewXCount === 3) {
                            let viewYCount = 0;

                            for (
                                let vertex = 0;
                                vertex < num_vertices;
                                vertex++
                            ) {
                                let k1 =
                                    gameModel.vertexViewY[vertices[vertex]];

                                if (k1 > -this.clipY) {
                                    viewYCount |= 1;
                                }

                                if (k1 < this.clipY) {
                                    viewYCount |= 2;
                                }

                                if (viewYCount === 3) {
                                    break;
                                }
                            }

                            if (viewYCount === 3) {
                                let polygon_1 = this.visiblePolygons[
                                    this.visiblePolygonsCount
                                ];

                                polygon_1.model = gameModel;
                                polygon_1.face = face;
                                this.initialisePolygon3D(
                                    this.visiblePolygonsCount
                                );

                                let faceFill = 0;

                                if (polygon_1.visibility < 0) {
                                    faceFill = gameModel.faceFillFront[face];
                                } else {
                                    faceFill = gameModel.faceFillBack[face];
                                }

                                if (faceFill !== COLOUR_TRANSPARENT) {
                                    let h = 0;

                                    for (
                                        let vertex = 0;
                                        vertex < num_vertices;
                                        vertex++
                                    ) {
                                        h +=
                                            gameModel.projectVertexZ[
                                                vertices[vertex]
                                            ];
                                    }

                                    polygon_1.depth =
                                        ((h / num_vertices) | 0) +
                                        gameModel.depth;
                                    polygon_1.facefill = faceFill;
                                    this.visiblePolygonsCount++;
                                }
                            }
                        }
                    }
                }
            }
        }

        let model_2d = this.view;

        if (model_2d.visible) {
            for (let face = 0; face < model_2d.numFaces; face++) {
                let faceVertices = model_2d.faceVertices[face];
                let vertex0 = faceVertices[0];
                let vx = model_2d.vertexViewX[vertex0];
                let vy = model_2d.vertexViewY[vertex0];
                let vz = model_2d.projectVertexZ[vertex0];

                if (vz > this.clipNear && vz < this.clipFar2d) {
                    let vw =
                        ((this.spriteWidth[face] << this.viewDistance) / vz) |
                        0;
                    let vh =
                        ((this.spriteHeight[face] << this.viewDistance) / vz) |
                        0;

                    if (
                        vx - ((vw / 2) | 0) <= this.clipX &&
                        vx + ((vw / 2) | 0) >= -this.clipX &&
                        vy - vh <= this.clipY &&
                        vy >= -this.clipY
                    ) {
                        let polygon_2 = this.visiblePolygons[
                            this.visiblePolygonsCount
                        ];
                        polygon_2.model = model_2d;
                        polygon_2.face = face;

                        this.initialisePolygon2D(this.visiblePolygonsCount);

                        polygon_2.depth =
                            ((vz + model_2d.projectVertexZ[faceVertices[1]]) /
                                2) |
                            0;
                        this.visiblePolygonsCount++;
                    }
                }
            }
        }

        if (this.visiblePolygonsCount === 0) {
            return;
        }

        this.lastVisiblePolygonsCount = this.visiblePolygonsCount;

        this.polygonsQSort(
            this.visiblePolygons,
            0,
            this.visiblePolygonsCount - 1
        );

        // TODO see what this does. it's taking up a lot of time in performance,
        // but commenting out doesn't seem to change the game at all?
        /*this.polygonsIntersectSort(
            100,
            this.visiblePolygons,
            this.visiblePolygonsCount
        );*/

        for (let i = 0; i < this.visiblePolygonsCount; i++) {
            let polygon = this.visiblePolygons[i];
            let gameModel_2 = polygon.model;
            let l = polygon.face;

            if (gameModel_2 === this.view) {
                let faceverts = gameModel_2.faceVertices[l];
                let face_0 = faceverts[0];
                let vx = gameModel_2.vertexViewX[face_0];
                let vy = gameModel_2.vertexViewY[face_0];
                let vz = gameModel_2.projectVertexZ[face_0];
                let w = ((this.spriteWidth[l] << this.viewDistance) / vz) | 0;
                let h = ((this.spriteHeight[l] << this.viewDistance) / vz) | 0;
                let tx = gameModel_2.vertexViewX[faceverts[1]] - vx;
                let x = vx - ((w / 2) | 0);
                let y = this.baseY + vy - h;

                this.surface._spriteClipping_from7(
                    x + this.baseX,
                    y,
                    w,
                    h,
                    this.spriteId[l],
                    tx,
                    ((256 << this.viewDistance) / vz) | 0
                );

                if (
                    this.mousePickingActive &&
                    this.mousePickedCount < this.mousePickedMax
                ) {
                    x +=
                        ((this.spriteTranslateX[l] << this.viewDistance) / vz) |
                        0;

                    if (
                        this.mouseY >= y &&
                        this.mouseY <= y + h &&
                        this.mouseX >= x &&
                        this.mouseX <= x + w &&
                        !gameModel_2.unpickable &&
                        gameModel_2.isLocalPlayer[l] === 0
                    ) {
                        this.mousePickedModels[
                            this.mousePickedCount
                        ] = gameModel_2;
                        this.mousePickedFaces[this.mousePickedCount] = l;
                        this.mousePickedCount++;
                    }
                }
            } else {
                let k8 = 0;
                let j10 = 0;
                let l10 = gameModel_2.faceNumVertices[l];
                let ai3 = gameModel_2.faceVertices[l];

                if (gameModel_2.faceIntensity[l] !== COLOUR_TRANSPARENT) {
                    if (polygon.visibility < 0) {
                        j10 =
                            gameModel_2.lightAmbience -
                            gameModel_2.faceIntensity[l];
                    } else {
                        j10 =
                            gameModel_2.lightAmbience +
                            gameModel_2.faceIntensity[l];
                    }
                }

                for (let k11 = 0; k11 < l10; k11++) {
                    let k2 = ai3[k11];

                    this.vertexX[k11] = gameModel_2.projectVertexX[k2];
                    this.vertexY[k11] = gameModel_2.projectVertexY[k2];
                    this.vertexZ[k11] = gameModel_2.projectVertexZ[k2];

                    if (gameModel_2.faceIntensity[l] === COLOUR_TRANSPARENT) {
                        if (polygon.visibility < 0) {
                            j10 =
                                gameModel_2.lightAmbience -
                                gameModel_2.vertexIntensity[k2] +
                                gameModel_2.vertexAmbience[k2];
                        } else {
                            j10 =
                                gameModel_2.lightAmbience +
                                gameModel_2.vertexIntensity[k2] +
                                gameModel_2.vertexAmbience[k2];
                        }
                    }

                    if (gameModel_2.projectVertexZ[k2] >= this.clipNear) {
                        this.planeX[k8] = gameModel_2.vertexViewX[k2];
                        this.planeY[k8] = gameModel_2.vertexViewY[k2];
                        this.vertexShade[k8] = j10;

                        if (
                            gameModel_2.projectVertexZ[k2] > this.fogZDistance
                        ) {
                            this.vertexShade[k8] +=
                                ((gameModel_2.projectVertexZ[k2] -
                                    this.fogZDistance) /
                                    this.fogZFalloff) |
                                0;
                        }

                        k8++;
                    } else {
                        let k9 = 0;

                        if (k11 === 0) {
                            k9 = ai3[l10 - 1];
                        } else {
                            k9 = ai3[k11 - 1];
                        }

                        if (gameModel_2.projectVertexZ[k9] >= this.clipNear) {
                            let k7 =
                                gameModel_2.projectVertexZ[k2] -
                                gameModel_2.projectVertexZ[k9];
                            let i5 =
                                gameModel_2.projectVertexX[k2] -
                                ((((gameModel_2.projectVertexX[k2] -
                                    gameModel_2.projectVertexX[k9]) *
                                    (gameModel_2.projectVertexZ[k2] -
                                        this.clipNear)) /
                                    k7) |
                                    0);
                            let j6 =
                                gameModel_2.projectVertexY[k2] -
                                ((((gameModel_2.projectVertexY[k2] -
                                    gameModel_2.projectVertexY[k9]) *
                                    (gameModel_2.projectVertexZ[k2] -
                                        this.clipNear)) /
                                    k7) |
                                    0);
                            this.planeX[k8] =
                                ((i5 << this.viewDistance) / this.clipNear) | 0;
                            this.planeY[k8] =
                                ((j6 << this.viewDistance) / this.clipNear) | 0;
                            this.vertexShade[k8] = j10;
                            k8++;
                        }

                        if (k11 === l10 - 1) {
                            k9 = ai3[0];
                        } else {
                            k9 = ai3[k11 + 1];
                        }

                        if (gameModel_2.projectVertexZ[k9] >= this.clipNear) {
                            let l7 =
                                gameModel_2.projectVertexZ[k2] -
                                gameModel_2.projectVertexZ[k9];
                            let j5 =
                                gameModel_2.projectVertexX[k2] -
                                ((((gameModel_2.projectVertexX[k2] -
                                    gameModel_2.projectVertexX[k9]) *
                                    (gameModel_2.projectVertexZ[k2] -
                                        this.clipNear)) /
                                    l7) |
                                    0);
                            let k6 =
                                gameModel_2.projectVertexY[k2] -
                                ((((gameModel_2.projectVertexY[k2] -
                                    gameModel_2.projectVertexY[k9]) *
                                    (gameModel_2.projectVertexZ[k2] -
                                        this.clipNear)) /
                                    l7) |
                                    0);
                            this.planeX[k8] =
                                ((j5 << this.viewDistance) / this.clipNear) | 0;
                            this.planeY[k8] =
                                ((k6 << this.viewDistance) / this.clipNear) | 0;
                            this.vertexShade[k8] = j10;
                            k8++;
                        }
                    }
                }

                for (let i12 = 0; i12 < l10; i12++) {
                    if (this.vertexShade[i12] < 0) {
                        this.vertexShade[i12] = 0;
                    } else if (this.vertexShade[i12] > 255) {
                        this.vertexShade[i12] = 255;
                    }

                    if (polygon.facefill >= 0) {
                        if (this.textureDimension[polygon.facefill] === 1) {
                            this.vertexShade[i12] <<= 9;
                        } else {
                            this.vertexShade[i12] <<= 6;
                        }
                    }
                }

                this.generateScanlines(
                    0,
                    0,
                    0,
                    0,
                    k8,
                    this.planeX,
                    this.planeY,
                    this.vertexShade,
                    gameModel_2,
                    l
                );

                if (this.maxY > this.minY) {
                    this.rasterize(
                        0,
                        0,
                        l10,
                        this.vertexX,
                        this.vertexY,
                        this.vertexZ,
                        polygon.facefill,
                        gameModel_2
                    );
                }
            }
        }

        this.mousePickingActive = false;
    }

    generateScanlines(i, j, k, l, i1, ai, ai1, ai2, gameModel, pid) {
        if (i1 === 3) {
            let k1 = ai1[0] + this.baseY;
            let k2 = ai1[1] + this.baseY;
            let k3 = ai1[2] + this.baseY;
            let k4 = ai[0];
            let l5 = ai[1];
            let j7 = ai[2];
            let l8 = ai2[0];
            let j10 = ai2[1];
            let j11 = ai2[2];
            let j12 = this.baseY + this.clipY - 1;
            let l12 = 0;
            let j13 = 0;
            let l13 = 0;
            let j14 = 0;
            let l14 = COLOUR_TRANSPARENT;
            let j15 = -COLOUR_TRANSPARENT;

            if (k3 !== k1) {
                j13 = (((j7 - k4) << 8) / (k3 - k1)) | 0;
                j14 = (((j11 - l8) << 8) / (k3 - k1)) | 0;

                if (k1 < k3) {
                    l12 = k4 << 8;
                    l13 = l8 << 8;
                    l14 = k1;
                    j15 = k3;
                } else {
                    l12 = j7 << 8;
                    l13 = j11 << 8;
                    l14 = k3;
                    j15 = k1;
                }

                if (l14 < 0) {
                    l12 -= j13 * l14;
                    l13 -= j14 * l14;
                    l14 = 0;
                }

                if (j15 > j12) {
                    j15 = j12;
                }
            }

            let l15 = 0;
            let j16 = 0;
            let l16 = 0;
            let j17 = 0;
            let l17 = COLOUR_TRANSPARENT;
            let j18 = -COLOUR_TRANSPARENT;

            if (k2 !== k1) {
                j16 = (((l5 - k4) << 8) / (k2 - k1)) | 0;
                j17 = (((j10 - l8) << 8) / (k2 - k1)) | 0;

                if (k1 < k2) {
                    l15 = k4 << 8;
                    l16 = l8 << 8;
                    l17 = k1;
                    j18 = k2;
                } else {
                    l15 = l5 << 8;
                    l16 = j10 << 8;
                    l17 = k2;
                    j18 = k1;
                }

                if (l17 < 0) {
                    l15 -= (j16 * l17) | 0;
                    l16 -= (j17 * l17) | 0;
                    l17 = 0;
                }

                if (j18 > j12) {
                    j18 = j12;
                }
            }

            let l18 = 0;
            let j19 = 0;
            let l19 = 0;
            let j20 = 0;
            let l20 = COLOUR_TRANSPARENT;
            let j21 = -COLOUR_TRANSPARENT;

            if (k3 !== k2) {
                j19 = (((j7 - l5) << 8) / (k3 - k2)) | 0;
                j20 = (((j11 - j10) << 8) / (k3 - k2)) | 0;

                if (k2 < k3) {
                    l18 = l5 << 8;
                    l19 = j10 << 8;
                    l20 = k2;
                    j21 = k3;
                } else {
                    l18 = j7 << 8;
                    l19 = j11 << 8;
                    l20 = k3;
                    j21 = k2;
                }

                if (l20 < 0) {
                    l18 -= (j19 * l20) | 0;
                    l19 -= (j20 * l20) | 0;
                    l20 = 0;
                }

                if (j21 > j12) {
                    j21 = j12;
                }
            }

            this.minY = l14;

            if (l17 < this.minY) {
                this.minY = l17;
            }

            if (l20 < this.minY) {
                this.minY = l20;
            }

            this.maxY = j15;

            if (j18 > this.maxY) {
                this.maxY = j18;
            }

            if (j21 > this.maxY) {
                this.maxY = j21;
            }

            let l21 = 0;

            for (k = this.minY; k < this.maxY; k++) {
                if (k >= l14 && k < j15) {
                    i = j = l12;
                    l = l21 = l13;
                    l12 += j13;
                    l13 += j14;
                } else {
                    i = 655360;
                    j = -655360;
                }

                if (k >= l17 && k < j18) {
                    if (l15 < i) {
                        i = l15;
                        l = l16;
                    }

                    if (l15 > j) {
                        j = l15;
                        l21 = l16;
                    }

                    l15 += j16;
                    l16 += j17;
                }

                if (k >= l20 && k < j21) {
                    if (l18 < i) {
                        i = l18;
                        l = l19;
                    }

                    if (l18 > j) {
                        j = l18;
                        l21 = l19;
                    }

                    l18 += j19;
                    l19 += j20;
                }

                let scanline_6 = this.scanlines[k];
                scanline_6.startX = i;
                scanline_6.endX = j;
                scanline_6.startS = l;
                scanline_6.endS = l21;
            }

            if (this.minY < this.baseY - this.clipY) {
                this.minY = this.baseY - this.clipY;
            }
        } else if (i1 === 4) {
            let l1 = ai1[0] + this.baseY;
            let l2 = ai1[1] + this.baseY;
            let l3 = ai1[2] + this.baseY;
            let l4 = ai1[3] + this.baseY;
            let i6 = ai[0];
            let k7 = ai[1];
            let i9 = ai[2];
            let k10 = ai[3];
            let k11 = ai2[0];
            let k12 = ai2[1];
            let i13 = ai2[2];
            let k13 = ai2[3];
            let i14 = this.baseY + this.clipY - 1;
            let k14 = 0;
            let i15 = 0;
            let k15 = 0;
            let i16 = 0;
            let k16 = COLOUR_TRANSPARENT;
            let i17 = -COLOUR_TRANSPARENT;

            if (l4 !== l1) {
                i15 = (((k10 - i6) << 8) / (l4 - l1)) | 0;
                i16 = (((k13 - k11) << 8) / (l4 - l1)) | 0;

                if (l1 < l4) {
                    k14 = i6 << 8;
                    k15 = k11 << 8;
                    k16 = l1;
                    i17 = l4;
                } else {
                    k14 = k10 << 8;
                    k15 = k13 << 8;
                    k16 = l4;
                    i17 = l1;
                }

                if (k16 < 0) {
                    k14 -= i15 * k16;
                    k15 -= i16 * k16;
                    k16 = 0;
                }

                if (i17 > i14) {
                    i17 = i14;
                }
            }

            let k17 = 0;
            let i18 = 0;
            let k18 = 0;
            let i19 = 0;
            let k19 = COLOUR_TRANSPARENT;
            let i20 = -COLOUR_TRANSPARENT;

            if (l2 !== l1) {
                i18 = (((k7 - i6) << 8) / (l2 - l1)) | 0;
                i19 = (((k12 - k11) << 8) / (l2 - l1)) | 0;

                if (l1 < l2) {
                    k17 = i6 << 8;
                    k18 = k11 << 8;
                    k19 = l1;
                    i20 = l2;
                } else {
                    k17 = k7 << 8;
                    k18 = k12 << 8;
                    k19 = l2;
                    i20 = l1;
                }

                if (k19 < 0) {
                    k17 -= i18 * k19;
                    k18 -= i19 * k19;
                    k19 = 0;
                }

                if (i20 > i14) {
                    i20 = i14;
                }
            }

            let k20 = 0;
            let i21 = 0;
            let k21 = 0;
            let i22 = 0;
            let j22 = COLOUR_TRANSPARENT;
            let k22 = -COLOUR_TRANSPARENT;

            if (l3 !== l2) {
                i21 = (((i9 - k7) << 8) / (l3 - l2)) | 0;
                i22 = (((i13 - k12) << 8) / (l3 - l2)) | 0;

                if (l2 < l3) {
                    k20 = k7 << 8;
                    k21 = k12 << 8;
                    j22 = l2;
                    k22 = l3;
                } else {
                    k20 = i9 << 8;
                    k21 = i13 << 8;
                    j22 = l3;
                    k22 = l2;
                }

                if (j22 < 0) {
                    k20 -= i21 * j22;
                    k21 -= i22 * j22;
                    j22 = 0;
                }

                if (k22 > i14) {
                    k22 = i14;
                }
            }

            let l22 = 0;
            let i23 = 0;
            let j23 = 0;
            let k23 = 0;
            let l23 = COLOUR_TRANSPARENT;
            let i24 = -COLOUR_TRANSPARENT;

            if (l4 !== l3) {
                i23 = (((k10 - i9) << 8) / (l4 - l3)) | 0;
                k23 = (((k13 - i13) << 8) / (l4 - l3)) | 0;

                if (l3 < l4) {
                    l22 = i9 << 8;
                    j23 = i13 << 8;
                    l23 = l3;
                    i24 = l4;
                } else {
                    l22 = k10 << 8;
                    j23 = k13 << 8;
                    l23 = l4;
                    i24 = l3;
                }

                if (l23 < 0) {
                    l22 -= i23 * l23;
                    j23 -= k23 * l23;
                    l23 = 0;
                }

                if (i24 > i14) {
                    i24 = i14;
                }
            }

            this.minY = k16;

            if (k19 < this.minY) {
                this.minY = k19;
            }

            if (j22 < this.minY) {
                this.minY = j22;
            }

            if (l23 < this.minY) {
                this.minY = l23;
            }

            this.maxY = i17;

            if (i20 > this.maxY) {
                this.maxY = i20;
            }

            if (k22 > this.maxY) {
                this.maxY = k22;
            }

            if (i24 > this.maxY) {
                this.maxY = i24;
            }

            let j24 = 0;

            for (k = this.minY; k < this.maxY; k++) {
                if (k >= k16 && k < i17) {
                    i = j = k14;
                    l = j24 = k15;
                    k14 += i15;
                    k15 += i16;
                } else {
                    i = 655360;
                    j = -655360;
                }

                if (k >= k19 && k < i20) {
                    if (k17 < i) {
                        i = k17;
                        l = k18;
                    }

                    if (k17 > j) {
                        j = k17;
                        j24 = k18;
                    }

                    k17 += i18;
                    k18 += i19;
                }

                if (k >= j22 && k < k22) {
                    if (k20 < i) {
                        i = k20;
                        l = k21;
                    }

                    if (k20 > j) {
                        j = k20;
                        j24 = k21;
                    }

                    k20 += i21;
                    k21 += i22;
                }

                if (k >= l23 && k < i24) {
                    if (l22 < i) {
                        i = l22;
                        l = j23;
                    }

                    if (l22 > j) {
                        j = l22;
                        j24 = j23;
                    }

                    l22 += i23;
                    j23 += k23;
                }

                let scanline_7 = this.scanlines[k];
                scanline_7.startX = i;
                scanline_7.endX = j;
                scanline_7.startS = l;
                scanline_7.endS = j24;
            }

            if (this.minY < this.baseY - this.clipY) {
                this.minY = this.baseY - this.clipY;
            }
        } else {
            this.maxY = this.minY = ai1[0] += this.baseY;

            for (k = 1; k < i1; k++) {
                let i2 = 0;

                if ((i2 = ai1[k] += this.baseY) < this.minY) {
                    this.minY = i2;
                } else if (i2 > this.maxY) {
                    this.maxY = i2;
                }
            }

            if (this.minY < this.baseY - this.clipY) {
                this.minY = this.baseY - this.clipY;
            }

            if (this.maxY >= this.baseY + this.clipY) {
                this.maxY = this.baseY + this.clipY - 1;
            }

            if (this.minY >= this.maxY) {
                return;
            }

            for (k = this.minY; k < this.maxY; k++) {
                let scanline = this.scanlines[k];
                scanline.startX = 655360;
                scanline.endX = -655360;
            }

            let j2 = i1 - 1;
            let i3 = ai1[0];
            let i4 = ai1[j2];

            if (i3 < i4) {
                let i5 = ai[0] << 8;
                let j6 = (((ai[j2] - ai[0]) << 8) / (i4 - i3)) | 0;
                let l7 = ai2[0] << 8;
                let j9 = (((ai2[j2] - ai2[0]) << 8) / (i4 - i3)) | 0;

                if (i3 < 0) {
                    i5 -= j6 * i3;
                    l7 -= j9 * i3;
                    i3 = 0;
                }

                if (i4 > this.maxY) {
                    i4 = this.maxY;
                }

                for (k = i3; k <= i4; k++) {
                    let scanline_2 = this.scanlines[k];
                    scanline_2.startX = scanline_2.endX = i5;
                    scanline_2.startS = scanline_2.endS = l7;
                    i5 += j6;
                    l7 += j9;
                }
            } else if (i3 > i4) {
                let j5 = ai[j2] << 8;
                let k6 = (((ai[0] - ai[j2]) << 8) / (i3 - i4)) | 0;
                let i8 = ai2[j2] << 8;
                let k9 = (((ai2[0] - ai2[j2]) << 8) / (i3 - i4)) | 0;

                if (i4 < 0) {
                    j5 -= k6 * i4;
                    i8 -= k9 * i4;
                    i4 = 0;
                }

                if (i3 > this.maxY) {
                    i3 = this.maxY;
                }

                for (k = i4; k <= i3; k++) {
                    let scanline_3 = this.scanlines[k];
                    scanline_3.startX = scanline_3.endX = j5;
                    scanline_3.startS = scanline_3.endS = i8;
                    j5 += k6;
                    i8 += k9;
                }
            }

            for (k = 0; k < j2; k++) {
                let k5 = k + 1;
                let j3 = ai1[k];
                let j4 = ai1[k5];

                if (j3 < j4) {
                    let l6 = ai[k] << 8;
                    let j8 = (((ai[k5] - ai[k]) << 8) / (j4 - j3)) | 0;
                    let l9 = ai2[k] << 8;
                    let l10 = (((ai2[k5] - ai2[k]) << 8) / (j4 - j3)) | 0;

                    if (j3 < 0) {
                        l6 -= j8 * j3;
                        l9 -= l10 * j3;
                        j3 = 0;
                    }

                    if (j4 > this.maxY) {
                        j4 = this.maxY;
                    }

                    for (let l11 = j3; l11 <= j4; l11++) {
                        let scanline_4 = this.scanlines[l11];

                        if (l6 < scanline_4.startX) {
                            scanline_4.startX = l6;
                            scanline_4.startS = l9;
                        }

                        if (l6 > scanline_4.endX) {
                            scanline_4.endX = l6;
                            scanline_4.endS = l9;
                        }

                        l6 += j8;
                        l9 += l10;
                    }
                } else if (j3 > j4) {
                    let i7 = ai[k5] << 8;
                    let k8 = (((ai[k] - ai[k5]) << 8) / (j3 - j4)) | 0;
                    let i10 = ai2[k5] << 8;
                    let i11 = (((ai2[k] - ai2[k5]) << 8) / (j3 - j4)) | 0;

                    if (j4 < 0) {
                        i7 -= k8 * j4;
                        i10 -= i11 * j4;
                        j4 = 0;
                    }

                    if (j3 > this.maxY) {
                        j3 = this.maxY;
                    }

                    for (let i12 = j4; i12 <= j3; i12++) {
                        let scanline_5 = this.scanlines[i12];

                        if (i7 < scanline_5.startX) {
                            scanline_5.startX = i7;
                            scanline_5.startS = i10;
                        }

                        if (i7 > scanline_5.endX) {
                            scanline_5.endX = i7;
                            scanline_5.endS = i10;
                        }

                        i7 += k8;
                        i10 += i11;
                    }
                }
            }

            if (this.minY < this.baseY - this.clipY) {
                this.minY = this.baseY - this.clipY;
            }
        }

        if (
            this.mousePickingActive &&
            this.mousePickedCount < this.mousePickedMax &&
            this.mouseY >= this.minY &&
            this.mouseY < this.maxY
        ) {
            let scanline_1 = this.scanlines[this.mouseY];

            if (
                this.mouseX >= scanline_1.startX >> 8 &&
                this.mouseX <= scanline_1.endX >> 8 &&
                scanline_1.startX <= scanline_1.endX &&
                !gameModel.unpickable &&
                gameModel.isLocalPlayer[pid] === 0
            ) {
                this.mousePickedModels[this.mousePickedCount] = gameModel;
                this.mousePickedFaces[this.mousePickedCount] = pid;
                this.mousePickedCount++;
            }
        }
    }

    rasterize(i, j, k, ai, ai1, ai2, l, gameModel) {
        if (l === -2) {
            return;
        }

        if (l >= 0) {
            if (l >= this.textureCount) {
                l = 0;
            }

            this.prepareTexture(l);

            let i1 = ai[0];
            let k1 = ai1[0];
            let j2 = ai2[0];
            let i3 = i1 - ai[1];
            let k3 = k1 - ai1[1];
            let i4 = j2 - ai2[1];
            k--;
            let i6 = ai[k] - i1;
            let j7 = ai1[k] - k1;
            let k8 = ai2[k] - j2;

            if (this.textureDimension[l] === 1) {
                let l9 = (i6 * k1 - j7 * i1) << 12;
                let k10 =
                    (j7 * j2 - k8 * k1) << (5 - this.viewDistance + 7 + 4);
                let i11 = (k8 * i1 - i6 * j2) << (5 - this.viewDistance + 7);
                let k11 = (i3 * k1 - k3 * i1) << 12;
                let i12 =
                    (k3 * j2 - i4 * k1) << (5 - this.viewDistance + 7 + 4);
                let k12 = (i4 * i1 - i3 * j2) << (5 - this.viewDistance + 7);
                let i13 = (k3 * i6 - i3 * j7) << 5;
                let k13 = (i4 * j7 - k3 * k8) << (5 - this.viewDistance + 4);
                let i14 = (i3 * k8 - i4 * i6) >> (this.viewDistance - 5);
                let k14 = k10 >> 4;
                let i15 = i12 >> 4;
                let k15 = k13 >> 4;
                let i16 = this.minY - this.baseY;
                let k16 = this.width;
                let i17 = this.baseX + this.minY * k16;
                let byte1 = 1;
                l9 += i11 * i16;
                k11 += k12 * i16;
                i13 += i14 * i16;

                if (this.interlace) {
                    if ((this.minY & 1) === 1) {
                        this.minY++;
                        l9 += i11;
                        k11 += k12;
                        i13 += i14;
                        i17 += k16;
                    }

                    i11 <<= 1;
                    k12 <<= 1;
                    i14 <<= 1;
                    k16 <<= 1;
                    byte1 = 2;
                }

                if (gameModel.textureTranslucent) {
                    for (i = this.minY; i < this.maxY; i += byte1) {
                        let scanline_3 = this.scanlines[i];
                        j = scanline_3.startX >> 8;
                        let k17 = scanline_3.endX >> 8;
                        let k20 = k17 - j;

                        if (k20 <= 0) {
                            l9 += i11;
                            k11 += k12;
                            i13 += i14;
                            i17 += k16;
                        } else {
                            let i22 = scanline_3.startS;
                            let k23 = ((scanline_3.endS - i22) / k20) | 0;

                            if (j < -this.clipX) {
                                i22 += (-this.clipX - j) * k23;
                                j = -this.clipX;
                                k20 = k17 - j;
                            }

                            if (k17 > this.clipX) {
                                let l17 = this.clipX;
                                k20 = l17 - j;
                            }

                            Scene.textureTranslucentScanline(
                                this.raster,
                                this.texturePixels[l],
                                0,
                                0,
                                l9 + k14 * j,
                                k11 + i15 * j,
                                i13 + k15 * j,
                                k10,
                                i12,
                                k13,
                                k20,
                                i17 + j,
                                i22,
                                k23 << 2
                            );

                            l9 += i11;
                            k11 += k12;
                            i13 += i14;
                            i17 += k16;
                        }
                    }

                    return;
                }

                if (!this.textureBackTransparent[l]) {
                    for (i = this.minY; i < this.maxY; i += byte1) {
                        let scanline_4 = this.scanlines[i];
                        j = scanline_4.startX >> 8;
                        let i18 = scanline_4.endX >> 8;
                        let l20 = i18 - j;

                        if (l20 <= 0) {
                            l9 += i11;
                            k11 += k12;
                            i13 += i14;
                            i17 += k16;
                        } else {
                            let j22 = scanline_4.startS;
                            let l23 = ((scanline_4.endS - j22) / l20) | 0;

                            if (j < -this.clipX) {
                                j22 += (-this.clipX - j) * l23;
                                j = -this.clipX;
                                l20 = i18 - j;
                            }

                            if (i18 > this.clipX) {
                                let j18 = this.clipX;
                                l20 = j18 - j;
                            }

                            Scene.textureScanline(
                                this.raster,
                                this.texturePixels[l],
                                0,
                                0,
                                l9 + k14 * j,
                                k11 + i15 * j,
                                i13 + k15 * j,
                                k10,
                                i12,
                                k13,
                                l20,
                                i17 + j,
                                j22,
                                l23 << 2
                            );

                            l9 += i11;
                            k11 += k12;
                            i13 += i14;
                            i17 += k16;
                        }
                    }

                    return;
                }

                for (i = this.minY; i < this.maxY; i += byte1) {
                    let scanline_5 = this.scanlines[i];
                    j = scanline_5.startX >> 8;
                    let k18 = scanline_5.endX >> 8;
                    let i21 = k18 - j;

                    if (i21 <= 0) {
                        l9 += i11;
                        k11 += k12;
                        i13 += i14;
                        i17 += k16;
                    } else {
                        let k22 = scanline_5.startS;
                        let i24 = ((scanline_5.endS - k22) / i21) | 0;

                        if (j < -this.clipX) {
                            k22 += (-this.clipX - j) * i24;
                            j = -this.clipX;
                            i21 = k18 - j;
                        }

                        if (k18 > this.clipX) {
                            let l18 = this.clipX;
                            i21 = l18 - j;
                        }

                        Scene.textureBackTranslucentScanline(
                            this.raster,
                            0,
                            0,
                            0,
                            this.texturePixels[l],
                            l9 + k14 * j,
                            k11 + i15 * j,
                            i13 + k15 * j,
                            k10,
                            i12,
                            k13,
                            i21,
                            i17 + j,
                            k22,
                            i24
                        );

                        l9 += i11;
                        k11 += k12;
                        i13 += i14;
                        i17 += k16;
                    }
                }

                return;
            }

            let i10 = (i6 * k1 - j7 * i1) << 11;
            let l10 = (j7 * j2 - k8 * k1) << (5 - this.viewDistance + 6 + 4);
            let j11 = (k8 * i1 - i6 * j2) << (5 - this.viewDistance + 6);
            let l11 = (i3 * k1 - k3 * i1) << 11;
            let j12 = (k3 * j2 - i4 * k1) << (5 - this.viewDistance + 6 + 4);
            let l12 = (i4 * i1 - i3 * j2) << (5 - this.viewDistance + 6);
            let j13 = (k3 * i6 - i3 * j7) << 5;
            let l13 = (i4 * j7 - k3 * k8) << (5 - this.viewDistance + 4);
            let j14 = (i3 * k8 - i4 * i6) >> (this.viewDistance - 5);
            let l14 = l10 >> 4;
            let j15 = j12 >> 4;
            let l15 = l13 >> 4;
            let j16 = this.minY - this.baseY;
            let l16 = this.width;
            let j17 = this.baseX + this.minY * l16;
            let byte2 = 1;
            i10 += j11 * j16;
            l11 += l12 * j16;
            j13 += j14 * j16;

            if (this.interlace) {
                if ((this.minY & 1) === 1) {
                    this.minY++;
                    i10 += j11;
                    l11 += l12;
                    j13 += j14;
                    j17 += l16;
                }

                j11 <<= 1;
                l12 <<= 1;
                j14 <<= 1;
                l16 <<= 1;
                byte2 = 2;
            }

            if (gameModel.textureTranslucent) {
                for (i = this.minY; i < this.maxY; i += byte2) {
                    let scanline_6 = this.scanlines[i];
                    j = scanline_6.startX >> 8;
                    let i19 = scanline_6.endX >> 8;
                    let j21 = i19 - j;

                    if (j21 <= 0) {
                        i10 += j11;
                        l11 += l12;
                        j13 += j14;
                        j17 += l16;
                    } else {
                        let l22 = scanline_6.startS;
                        let j24 = ((scanline_6.endS - l22) / j21) | 0;

                        if (j < -this.clipX) {
                            l22 += (-this.clipX - j) * j24;
                            j = -this.clipX;
                            j21 = i19 - j;
                        }

                        if (i19 > this.clipX) {
                            let j19 = this.clipX;
                            j21 = j19 - j;
                        }

                        Scene.textureTranslucentScanline2(
                            this.raster,
                            this.texturePixels[l],
                            0,
                            0,
                            i10 + l14 * j,
                            l11 + j15 * j,
                            j13 + l15 * j,
                            l10,
                            j12,
                            l13,
                            j21,
                            j17 + j,
                            l22,
                            j24
                        );

                        i10 += j11;
                        l11 += l12;
                        j13 += j14;
                        j17 += l16;
                    }
                }

                return;
            }

            if (!this.textureBackTransparent[l]) {
                for (i = this.minY; i < this.maxY; i += byte2) {
                    let scanline_7 = this.scanlines[i];
                    j = scanline_7.startX >> 8;
                    let k19 = scanline_7.endX >> 8;
                    let k21 = k19 - j;

                    if (k21 <= 0) {
                        i10 += j11;
                        l11 += l12;
                        j13 += j14;
                        j17 += l16;
                    } else {
                        let i23 = scanline_7.startS;
                        let k24 = ((scanline_7.endS - i23) / k21) | 0;

                        if (j < -this.clipX) {
                            i23 += (-this.clipX - j) * k24;
                            j = -this.clipX;
                            k21 = k19 - j;
                        }
                        if (k19 > this.clipX) {
                            let l19 = this.clipX;
                            k21 = l19 - j;
                        }

                        Scene.textureScanline2(
                            this.raster,
                            this.texturePixels[l],
                            0,
                            0,
                            i10 + l14 * j,
                            l11 + j15 * j,
                            j13 + l15 * j,
                            l10,
                            j12,
                            l13,
                            k21,
                            j17 + j,
                            i23,
                            k24
                        );

                        i10 += j11;
                        l11 += l12;
                        j13 += j14;
                        j17 += l16;
                    }
                }

                return;
            }

            for (i = this.minY; i < this.maxY; i += byte2) {
                let scanline = this.scanlines[i];
                j = scanline.startX >> 8;
                let i20 = scanline.endX >> 8;
                let l21 = i20 - j;

                if (l21 <= 0) {
                    i10 += j11;
                    l11 += l12;
                    j13 += j14;
                    j17 += l16;
                } else {
                    let j23 = scanline.startS;
                    let l24 = ((scanline.endS - j23) / l21) | 0;

                    if (j < -this.clipX) {
                        j23 += (-this.clipX - j) * l24;
                        j = -this.clipX;
                        l21 = i20 - j;
                    }

                    if (i20 > this.clipX) {
                        let j20 = this.clipX;
                        l21 = j20 - j;
                    }

                    Scene.textureBackTranslucentScanline2(
                        this.raster,
                        0,
                        0,
                        0,
                        this.texturePixels[l],
                        i10 + l14 * j,
                        l11 + j15 * j,
                        j13 + l15 * j,
                        l10,
                        j12,
                        l13,
                        l21,
                        j17 + j,
                        j23,
                        l24
                    );

                    i10 += j11;
                    l11 += l12;
                    j13 += j14;
                    j17 += l16;
                }
            }

            return;
        }

        for (let j1 = 0; j1 < this.rampCount; j1++) {
            if (this.gradientBase[j1] === l) {
                this.anIntArray377 = this.gradientRamps[j1];
                break;
            }

            if (j1 === this.rampCount - 1) {
                let l1 = (Math.random() * this.rampCount) | 0;
                this.gradientBase[l1] = l;
                l = -1 - l;
                let k2 = ((l >> 10) & 0x1f) * 8;
                let j3 = ((l >> 5) & 0x1f) * 8;
                let l3 = (l & 0x1f) * 8;

                for (let j4 = 0; j4 < 256; j4++) {
                    let j6 = j4 * j4;
                    let k7 = ((k2 * j6) / 0x10000) | 0;
                    let l8 = ((j3 * j6) / 0x10000) | 0;
                    let j10 = ((l3 * j6) / 0x10000) | 0;
                    this.gradientRamps[l1][255 - j4] =
                        (k7 << 16) + (l8 << 8) + j10;
                }

                this.anIntArray377 = this.gradientRamps[l1];
            }
        }

        let i2 = this.width;
        let l2 = this.baseX + this.minY * i2;
        let byte0 = 1;

        if (this.interlace) {
            if ((this.minY & 1) === 1) {
                this.minY++;
                l2 += i2;
            }

            i2 <<= 1;
            byte0 = 2;
        }

        if (gameModel.transparent) {
            for (i = this.minY; i < this.maxY; i += byte0) {
                let scanline = this.scanlines[i];
                j = scanline.startX >> 8;
                let k4 = scanline.endX >> 8;
                let k6 = k4 - j;

                if (k6 <= 0) {
                    l2 += i2;
                } else {
                    let l7 = scanline.startS;
                    let i9 = ((scanline.endS - l7) / k6) | 0;

                    if (j < -this.clipX) {
                        l7 += (-this.clipX - j) * i9;
                        j = -this.clipX;
                        k6 = k4 - j;
                    }

                    if (k4 > this.clipX) {
                        let l4 = this.clipX;
                        k6 = l4 - j;
                    }

                    Scene.textureGradientScanline(
                        this.raster,
                        -k6,
                        l2 + j,
                        0,
                        this.anIntArray377,
                        l7,
                        i9
                    );
                    l2 += i2;
                }
            }

            return;
        }

        if (this.wideBand) {
            for (i = this.minY; i < this.maxY; i += byte0) {
                let scanline_1 = this.scanlines[i];
                j = scanline_1.startX >> 8;
                let i5 = scanline_1.endX >> 8;
                let l6 = i5 - j;

                if (l6 <= 0) {
                    l2 += i2;
                } else {
                    let i8 = scanline_1.startS;
                    let j9 = ((scanline_1.endS - i8) / l6) | 0;

                    if (j < -this.clipX) {
                        i8 += (-this.clipX - j) * j9;
                        j = -this.clipX;
                        l6 = i5 - j;
                    }

                    if (i5 > this.clipX) {
                        let j5 = this.clipX;
                        l6 = j5 - j;
                    }

                    Scene.gradientScanline(
                        this.raster,
                        -l6,
                        l2 + j,
                        0,
                        this.anIntArray377,
                        i8,
                        j9
                    );
                    l2 += i2;
                }
            }

            return;
        }

        for (i = this.minY; i < this.maxY; i += byte0) {
            let scanline_2 = this.scanlines[i];
            j = scanline_2.startX >> 8;
            let k5 = scanline_2.endX >> 8;
            let i7 = k5 - j;

            if (i7 <= 0) {
                l2 += i2;
            } else {
                let j8 = scanline_2.startS;
                let k9 = ((scanline_2.endS - j8) / i7) | 0;

                if (j < -this.clipX) {
                    j8 += (-this.clipX - j) * k9;
                    j = -this.clipX;
                    i7 = k5 - j;
                }

                if (k5 > this.clipX) {
                    let l5 = this.clipX;
                    i7 = l5 - j;
                }

                Scene.gradientScanline2(
                    this.raster,
                    -i7,
                    l2 + j,
                    0,
                    this.anIntArray377,
                    j8,
                    k9
                );
                l2 += i2;
            }
        }
    }

    setCamera(x, z, y, pitch, yaw, roll, distance) {
        pitch &= 0x3ff;
        yaw &= 0x3ff;
        roll &= 0x3ff;
        this.cameraYaw = (1024 - pitch) & 0x3ff;
        this.cameraPitch = (1024 - yaw) & 0x3ff;
        this.cameraRoll = (1024 - roll) & 0x3ff;

        let l1 = 0;
        let i2 = 0;
        let j2 = distance;

        if (pitch !== 0) {
            let k2 = Scene.sinCosCache[pitch];
            let j3 = Scene.sinCosCache[pitch + 1024];
            let i4 = (i2 * j3 - j2 * k2) >> 15;
            j2 = (i2 * k2 + j2 * j3) >> 15;
            i2 = i4;
        }

        if (yaw !== 0) {
            let l2 = Scene.sinCosCache[yaw];
            let k3 = Scene.sinCosCache[yaw + 1024];
            let j4 = (j2 * l2 + l1 * k3) >> 15;
            j2 = (j2 * k3 - l1 * l2) >> 15;
            l1 = j4;
        }

        if (roll !== 0) {
            let i3 = Scene.sinCosCache[roll];
            let l3 = Scene.sinCosCache[roll + 1024];
            let k4 = (i2 * i3 + l1 * l3) >> 15;
            i2 = (i2 * l3 - l1 * i3) >> 15;
            l1 = k4;
        }

        this.cameraX = x - l1;
        this.cameraY = z - i2;
        this.cameraZ = y - j2;
    }

    initialisePolygon3D(i) {
        let polygon = this.visiblePolygons[i];
        let gameModel = polygon.model;
        let face = polygon.face;
        let faceVertices = gameModel.faceVertices[face];
        let faceNumVertices = gameModel.faceNumVertices[face];
        let faceCameraNormalScale = gameModel.normalScale[face];
        let vcx = gameModel.projectVertexX[faceVertices[0]];
        let vcy = gameModel.projectVertexY[faceVertices[0]];
        let vcz = gameModel.projectVertexZ[faceVertices[0]];
        let vcx1 = gameModel.projectVertexX[faceVertices[1]] - vcx;
        let vcy1 = gameModel.projectVertexY[faceVertices[1]] - vcy;
        let vcz1 = gameModel.projectVertexZ[faceVertices[1]] - vcz;
        let vcx2 = gameModel.projectVertexX[faceVertices[2]] - vcx;
        let vcy2 = gameModel.projectVertexY[faceVertices[2]] - vcy;
        let vcz2 = gameModel.projectVertexZ[faceVertices[2]] - vcz;
        let t1 = vcy1 * vcz2 - vcy2 * vcz1;
        let t2 = vcz1 * vcx2 - vcz2 * vcx1;
        let t3 = vcx1 * vcy2 - vcx2 * vcy1;

        if (faceCameraNormalScale === -1) {
            faceCameraNormalScale = 0;

            for (
                ;
                t1 > 25000 ||
                t2 > 25000 ||
                t3 > 25000 ||
                t1 < -25000 ||
                t2 < -25000 ||
                t3 < -25000;
                t3 >>= 1
            ) {
                faceCameraNormalScale++;
                t1 >>= 1;
                t2 >>= 1;
            }

            gameModel.normalScale[face] = faceCameraNormalScale;
            gameModel.normalMagnitude[face] =
                (this.normalMagnitude *
                    Math.sqrt(t1 * t1 + t2 * t2 + t3 * t3)) |
                0;
        } else {
            t1 >>= faceCameraNormalScale;
            t2 >>= faceCameraNormalScale;
            t3 >>= faceCameraNormalScale;
        }

        polygon.visibility = vcx * t1 + vcy * t2 + vcz * t3;
        polygon.normalX = t1;
        polygon.normalY = t2;
        polygon.normalZ = t3;

        let j4 = gameModel.projectVertexZ[faceVertices[0]];
        let k4 = j4;
        let l4 = gameModel.vertexViewX[faceVertices[0]];
        let i5 = l4;
        let j5 = gameModel.vertexViewY[faceVertices[0]];
        let k5 = j5;

        for (let l5 = 1; l5 < faceNumVertices; l5++) {
            let i1 = gameModel.projectVertexZ[faceVertices[l5]];

            if (i1 > k4) {
                k4 = i1;
            } else if (i1 < j4) {
                j4 = i1;
            }

            i1 = gameModel.vertexViewX[faceVertices[l5]];

            if (i1 > i5) {
                i5 = i1;
            } else if (i1 < l4) {
                l4 = i1;
            }

            i1 = gameModel.vertexViewY[faceVertices[l5]];

            if (i1 > k5) {
                k5 = i1;
            } else if (i1 < j5) {
                j5 = i1;
            }
        }

        polygon.minZ = j4;
        polygon.maxZ = k4;
        polygon.minPlaneX = l4;
        polygon.maxPlaneX = i5;
        polygon.minPlaneY = j5;
        polygon.maxPlaneY = k5;
    }

    initialisePolygon2D(i) {
        let polygon = this.visiblePolygons[i];
        let gameModel = polygon.model;
        let j = polygon.face;
        let ai = gameModel.faceVertices[j];
        let l = 0;
        let i1 = 0;
        let j1 = 1;
        let k1 = gameModel.projectVertexX[ai[0]];
        let l1 = gameModel.projectVertexY[ai[0]];
        let i2 = gameModel.projectVertexZ[ai[0]];

        gameModel.normalMagnitude[j] = 1;
        gameModel.normalScale[j] = 0;
        polygon.visibility = k1 * l + l1 * i1 + i2 * j1;
        polygon.normalX = l;
        polygon.normalY = i1;
        polygon.normalZ = j1;

        let j2 = gameModel.projectVertexZ[ai[0]];
        let k2 = j2;
        let l2 = gameModel.vertexViewX[ai[0]];
        let i3 = l2;

        if (gameModel.vertexViewX[ai[1]] < l2) {
            l2 = gameModel.vertexViewX[ai[1]];
        } else {
            i3 = gameModel.vertexViewX[ai[1]];
        }

        let j3 = gameModel.vertexViewY[ai[1]];
        let k3 = gameModel.vertexViewY[ai[0]];
        let k = gameModel.projectVertexZ[ai[1]];

        if (k > k2) {
            k2 = k;
        } else if (k < j2) {
            j2 = k;
        }

        k = gameModel.vertexViewX[ai[1]];

        if (k > i3) {
            i3 = k;
        } else if (k < l2) {
            l2 = k;
        }

        k = gameModel.vertexViewY[ai[1]];

        if (k > k3) {
            k3 = k;
        } else if (k < j3) {
            j3 = k;
        }

        polygon.minZ = j2;
        polygon.maxZ = k2;
        polygon.minPlaneX = l2 - 20;
        polygon.maxPlaneX = i3 + 20;
        polygon.minPlaneY = j3;
        polygon.maxPlaneY = k3;
    }

    separatePolygon(polygon, polygon_1) {
        if (polygon.minPlaneX >= polygon_1.maxPlaneX) {
            return true;
        }

        if (polygon_1.minPlaneX >= polygon.maxPlaneX) {
            return true;
        }

        if (polygon.minPlaneY >= polygon_1.maxPlaneY) {
            return true;
        }

        if (polygon_1.minPlaneY >= polygon.maxPlaneY) {
            return true;
        }

        if (polygon.minZ >= polygon_1.maxZ) {
            return true;
        }

        if (polygon_1.minZ > polygon.maxZ) {
            return false;
        }

        let gameModel = polygon.model;
        let gameModel_1 = polygon_1.model;
        let i = polygon.face;
        let j = polygon_1.face;
        let ai = gameModel.faceVertices[i];
        let ai1 = gameModel_1.faceVertices[j];
        let k = gameModel.faceNumVertices[i];
        let l = gameModel_1.faceNumVertices[j];
        let k2 = gameModel_1.projectVertexX[ai1[0]];
        let l2 = gameModel_1.projectVertexY[ai1[0]];
        let i3 = gameModel_1.projectVertexZ[ai1[0]];
        let j3 = polygon_1.normalX;
        let k3 = polygon_1.normalY;
        let l3 = polygon_1.normalZ;
        let i4 = gameModel_1.normalMagnitude[j];
        let j4 = polygon_1.visibility;
        let flag = false;

        for (let k4 = 0; k4 < k; k4++) {
            let i1 = ai[k4];
            let i2 =
                (k2 - gameModel.projectVertexX[i1]) * j3 +
                (l2 - gameModel.projectVertexY[i1]) * k3 +
                (i3 - gameModel.projectVertexZ[i1]) * l3;

            if ((i2 >= -i4 || j4 >= 0) && (i2 <= i4 || j4 <= 0)) {
                continue;
            }

            flag = true;
            break;
        }

        if (!flag) {
            return true;
        }

        k2 = gameModel.projectVertexX[ai[0]];
        l2 = gameModel.projectVertexY[ai[0]];
        i3 = gameModel.projectVertexZ[ai[0]];
        j3 = polygon.normalX;
        k3 = polygon.normalY;
        l3 = polygon.normalZ;
        i4 = gameModel.normalMagnitude[i];
        j4 = polygon.visibility;
        flag = false;

        for (let l4 = 0; l4 < l; l4++) {
            let j1 = ai1[l4];
            let j2 =
                (k2 - gameModel_1.projectVertexX[j1]) * j3 +
                (l2 - gameModel_1.projectVertexY[j1]) * k3 +
                (i3 - gameModel_1.projectVertexZ[j1]) * l3;

            if ((j2 >= -i4 || j4 <= 0) && (j2 <= i4 || j4 >= 0)) {
                continue;
            }

            flag = true;
            break;
        }

        if (!flag) {
            return true;
        }

        let ai2 = null;
        let ai3 = null;

        if (k === 2) {
            ai2 = new Int32Array(4);
            ai3 = new Int32Array(4);
            let i5 = ai[0];
            let k1 = ai[1];
            ai2[0] = gameModel.vertexViewX[i5] - 20;
            ai2[1] = gameModel.vertexViewX[k1] - 20;
            ai2[2] = gameModel.vertexViewX[k1] + 20;
            ai2[3] = gameModel.vertexViewX[i5] + 20;
            ai3[0] = ai3[3] = gameModel.vertexViewY[i5];
            ai3[1] = ai3[2] = gameModel.vertexViewY[k1];
        } else {
            ai2 = new Int32Array(k);
            ai3 = new Int32Array(k);

            for (let j5 = 0; j5 < k; j5++) {
                let i6 = ai[j5];
                ai2[j5] = gameModel.vertexViewX[i6];
                ai3[j5] = gameModel.vertexViewY[i6];
            }
        }

        let ai4 = null;
        let ai5 = null;

        if (l === 2) {
            ai4 = new Int32Array(4);
            ai5 = new Int32Array(4);
            let k5 = ai1[0];
            let l1 = ai1[1];
            ai4[0] = gameModel_1.vertexViewX[k5] - 20;
            ai4[1] = gameModel_1.vertexViewX[l1] - 20;
            ai4[2] = gameModel_1.vertexViewX[l1] + 20;
            ai4[3] = gameModel_1.vertexViewX[k5] + 20;
            ai5[0] = ai5[3] = gameModel_1.vertexViewY[k5];
            ai5[1] = ai5[2] = gameModel_1.vertexViewY[l1];
        } else {
            ai4 = new Int32Array(l);
            ai5 = new Int32Array(l);

            for (let l5 = 0; l5 < l; l5++) {
                let j6 = ai1[l5];
                ai4[l5] = gameModel_1.vertexViewX[j6];
                ai5[l5] = gameModel_1.vertexViewY[j6];
            }
        }

        return !this.intersect(ai2, ai3, ai4, ai5);
    }

    heuristicPolygon(polygon, polygon_1) {
        let gameModel = polygon.model;
        let gameModel_1 = polygon_1.model;
        let i = polygon.face;
        let j = polygon_1.face;
        let ai = gameModel.faceVertices[i];
        let ai1 = gameModel_1.faceVertices[j];
        let k = gameModel.faceNumVertices[i];
        let l = gameModel_1.faceNumVertices[j];
        let i2 = gameModel_1.projectVertexX[ai1[0]];
        let j2 = gameModel_1.projectVertexY[ai1[0]];
        let k2 = gameModel_1.projectVertexZ[ai1[0]];
        let l2 = polygon_1.normalX;
        let i3 = polygon_1.normalY;
        let j3 = polygon_1.normalZ;
        let k3 = gameModel_1.normalMagnitude[j];
        let l3 = polygon_1.visibility;
        let flag = false;

        for (let i4 = 0; i4 < k; i4++) {
            let i1 = ai[i4];
            let k1 =
                (i2 - gameModel.projectVertexX[i1]) * l2 +
                (j2 - gameModel.projectVertexY[i1]) * i3 +
                (k2 - gameModel.projectVertexZ[i1]) * j3;
            if ((k1 >= -k3 || l3 >= 0) && (k1 <= k3 || l3 <= 0)) {
                continue;
            }
            flag = true;
            break;
        }

        if (!flag) {
            return true;
        }

        i2 = gameModel.projectVertexX[ai[0]];
        j2 = gameModel.projectVertexY[ai[0]];
        k2 = gameModel.projectVertexZ[ai[0]];
        l2 = polygon.normalX;
        i3 = polygon.normalY;
        j3 = polygon.normalZ;
        k3 = gameModel.normalMagnitude[i];
        l3 = polygon.visibility;
        flag = false;

        for (let j4 = 0; j4 < l; j4++) {
            let j1 = ai1[j4];
            let l1 =
                (i2 - gameModel_1.projectVertexX[j1]) * l2 +
                (j2 - gameModel_1.projectVertexY[j1]) * i3 +
                (k2 - gameModel_1.projectVertexZ[j1]) * j3;

            if ((l1 >= -k3 || l3 <= 0) && (l1 <= k3 || l3 >= 0)) {
                continue;
            }

            flag = true;
            break;
        }

        return !flag;
    }

    allocateTextures(count, something7, something11) {
        this.textureCount = count;
        this.textureColoursUsed = []; // byte[][]
        this.textureColoursUsed.length = count; // byte[][]
        this.textureColoursUsed.fill(null);
        this.textureColourList = [];
        this.textureColourList.length = count;
        this.textureColourList.fill(null);
        this.textureDimension = new Int32Array(count);
        this.textureLoadedNumber = [];
        this.textureLoadedNumber.length = count;
        this.textureLoadedNumber.fill(null);
        this.textureBackTransparent = new Int8Array(count);
        this.texturePixels = [];
        this.texturePixels.length = count;
        this.texturePixels.fill(null);
        Scene.textureCountLoaded = new Long(0);

        for (let i = 0; i < count; i += 1) {
            this.textureLoadedNumber.push(new Long(0));
        }

        // 64x64 rgba
        this.textureColours64 = [];
        this.textureColours64.length = something7;
        this.textureColours64.fill(null);

        // 128x128 rgba
        this.textureColours128 = [];
        this.textureColours128.length = something11;
        this.textureColours128.fill(null);
    }

    defineTexture(id, usedColours, colours, wide128) {
        this.textureColoursUsed[id] = usedColours;
        this.textureColourList[id] = colours;
        // is 1 if the this.texture is 128+ pixels wide, 0 if <128
        this.textureDimension[id] = wide128;
        // as in the current loaded this.texture count when its loaded
        this.textureLoadedNumber[id] = new Long(0);
        this.textureBackTransparent[id] = false;
        this.texturePixels[id] = null;
        this.prepareTexture(id);
    }

    prepareTexture(id) {
        if (id < 0) {
            return;
        }

        Scene.textureCountLoaded = Scene.textureCountLoaded.add(1);
        this.textureLoadedNumber[id] = new Long(Scene.textureCountLoaded);

        if (this.texturePixels[id] !== null) {
            return;
        }

        if (this.textureDimension[id] === 0) {
            // is 64 pixels wide
            for (let j = 0; j < this.textureColours64.length; j++) {
                if (this.textureColours64[j] === null) {
                    this.textureColours64[j] = new Int32Array(16384);
                    this.texturePixels[id] = this.textureColours64[j];
                    this.setTexturePixels(id);
                    return;
                }
            }

            // almost as large as exemplar's nas storage
            let GIGALONG = new Long(1).shiftLeft(30);
            let wut = 0;

            for (let k1 = 0; k1 < this.textureCount; k1++) {
                if (
                    k1 !== id &&
                    this.textureDimension[k1] === 0 &&
                    this.texturePixels[k1] !== null &&
                    this.textureLoadedNumber[k1].lessThan(GIGALONG)
                ) {
                    GIGALONG = this.textureLoadedNumber[k1];
                    wut = k1;
                }
            }

            this.texturePixels[id] = this.texturePixels[wut];
            this.texturePixels[wut] = null;
            this.setTexturePixels(id);
            return;
        }

        // is 128 wide
        for (let k = 0; k < this.textureColours128.length; k++) {
            if (this.textureColours128[k] === null) {
                this.textureColours128[k] = new Int32Array(0x10000);
                this.texturePixels[id] = this.textureColours128[k];
                this.setTexturePixels(id);
                return;
            }
        }

        // 1G 2G 3G... 4G?
        let GIGALONG = new Long(1).shiftLeft(30);
        let wat = 0;

        for (let i2 = 0; i2 < this.textureCount; i2++) {
            if (
                i2 !== id &&
                this.textureDimension[i2] === 1 &&
                this.texturePixels[i2] !== null &&
                this.textureLoadedNumber[i2].lessThan(GIGALONG)
            ) {
                GIGALONG = this.textureLoadedNumber[i2];
                wat = i2;
            }
        }

        this.texturePixels[id] = this.texturePixels[wat];
        this.texturePixels[wat] = null;
        this.setTexturePixels(id);
    }

    setTexturePixels(id) {
        let textureWidth = 0;

        if (this.textureDimension[id] === 0) {
            textureWidth = 64;
        } else {
            textureWidth = 128;
        }

        let colours = this.texturePixels[id];
        let colourCount = 0;

        for (let x = 0; x < textureWidth; x++) {
            for (let y = 0; y < textureWidth; y++) {
                let colour = this.textureColourList[id][
                    this.textureColoursUsed[id][y + x * textureWidth] & 0xff
                ];
                colour &= 0xf8f8ff;

                if (colour === 0) {
                    colour = 1;
                } else if (colour === 0xf800ff) {
                    colour = 0;
                    this.textureBackTransparent[id] = true;
                }

                colours[colourCount++] = colour;
            }
        }

        for (let i1 = 0; i1 < colourCount; i1++) {
            let colour = colours[i1]; // ??
            colours[colourCount + i1] = (colour - (colour >>> 3)) & 0xf8f8ff;
            colours[colourCount * 2 + i1] =
                (colour - (colour >>> 2)) & 0xf8f8ff;
            colours[colourCount * 3 + i1] =
                (colour - (colour >>> 2) - (colour >>> 3)) & 0xf8f8ff;
        }
    }

    doSOemthingWithTheFuckinFountainFuck(id) {
        if (this.texturePixels[id] === null) {
            return;
        }

        let colours = this.texturePixels[id];

        for (let i = 0; i < 64; i++) {
            let k = i + 4032;
            let l = colours[k];

            for (let j1 = 0; j1 < 63; j1++) {
                colours[k] = colours[k - 64];
                k -= 64;
            }

            this.texturePixels[id][k] = l;
        }

        let c = 4096;

        for (let i1 = 0; i1 < c; i1++) {
            let k1 = colours[i1];
            colours[c + i1] = (k1 - (k1 >>> 3)) & 0xf8f8ff;
            colours[c * 2 + i1] = (k1 - (k1 >>> 2)) & 0xf8f8ff;
            colours[c * 3 + i1] = (k1 - (k1 >>> 2) - (k1 >>> 3)) & 0xf8f8ff;
        }
    }

    method302(i) {
        if (i === COLOUR_TRANSPARENT) {
            return 0;
        }

        this.prepareTexture(i);

        if (i >= 0) {
            return this.texturePixels[i][0];
        }

        if (i < 0) {
            i = -(i + 1);

            let j = (i >> 10) & 0x1f;
            let k = (i >> 5) & 0x1f;
            let l = i & 0x1f;

            return (j << 19) + (k << 11) + (l << 3);
        } else {
            return 0;
        }
    }

    _setLight_from3(i, j, k) {
        if (i === 0 && j === 0 && k === 0) {
            i = 32;
        }

        for (let l = 0; l < this.modelCount; l++) {
            this.models[l]._setLight_from3(i, j, k);
        }
    }

    _setLight_from5(i, j, k, l, i1) {
        if (k === 0 && l === 0 && i1 === 0) {
            k = 32;
        }

        for (let j1 = 0; j1 < this.modelCount; j1++) {
            this.models[j1]._setLight_from5(i, j, k, l, i1);
        }
    }

    setLight(...args) {
        switch (args.length) {
            case 3:
                return this._setLight_from3(...args);
            case 5:
                return this._setLight_from5(...args);
        }
    }

    method306(i, j, k, l, i1) {
        if (l === j) {
            return i;
        } else {
            return i + ((((k - i) * (i1 - j)) / (l - j)) | 0);
        }
    }

    method307(i, j, k, l, flag) {
        if ((flag && i <= k) || i < k) {
            if (i > l) {
                return true;
            }

            if (j > k) {
                return true;
            }

            if (j > l) {
                return true;
            }

            return !flag;
        }

        if (i < l) {
            return true;
        }

        if (j < k) {
            return true;
        }

        if (j < l) {
            return true;
        } else {
            return flag;
        }
    }

    method308(i, j, k, flag) {
        if ((flag && i <= k) || i < k) {
            if (j > k) {
                return true;
            }

            return !flag;
        }

        if (j < k) {
            return true;
        } else {
            return flag;
        }
    }

    intersect(ai, ai1, ai2, ai3) {
        let i = ai.length;
        let j = ai2.length;
        let byte0 = 0;
        let i20;
        let k20 = (i20 = ai1[0]);
        let k = 0;
        let j20;
        let l20 = (j20 = ai3[0]);
        let i1 = 0;

        for (let i21 = 1; i21 < i; i21++) {
            if (ai1[i21] < i20) {
                i20 = ai1[i21];
                k = i21;
            } else if (ai1[i21] > k20) {
                k20 = ai1[i21];
            }
        }

        for (let j21 = 1; j21 < j; j21++) {
            if (ai3[j21] < j20) {
                j20 = ai3[j21];
                i1 = j21;
            } else if (ai3[j21] > l20) {
                l20 = ai3[j21];
            }
        }

        if (j20 >= k20) {
            return false;
        }

        if (i20 >= l20) {
            return false;
        }

        let l = 0;
        let j1 = 0;
        let flag = false;

        if (ai1[k] < ai3[i1]) {
            for (l = k; ai1[l] < ai3[i1]; l = (l + 1) % i);
            for (; ai1[k] < ai3[i1]; k = (k - 1 + i) % i);
            let k1 = this.method306(
                ai[(k + 1) % i],
                ai1[(k + 1) % i],
                ai[k],
                ai1[k],
                ai3[i1]
            );
            let k6 = this.method306(
                ai[(l - 1 + i) % i],
                ai1[(l - 1 + i) % i],
                ai[l],
                ai1[l],
                ai3[i1]
            );
            let l10 = ai2[i1];
            flag = (k1 < l10) | (k6 < l10);

            if (this.method308(k1, k6, l10, flag)) {
                return true;
            }

            j1 = (i1 + 1) % j;
            i1 = (i1 - 1 + j) % j;

            if (k === l) {
                byte0 = 1;
            }
        } else {
            for (j1 = i1; ai3[j1] < ai1[k]; j1 = (j1 + 1) % j);
            for (; ai3[i1] < ai1[k]; i1 = (i1 - 1 + j) % j);
            let l1 = ai[k];
            let i11 = this.method306(
                ai2[(i1 + 1) % j],
                ai3[(i1 + 1) % j],
                ai2[i1],
                ai3[i1],
                ai1[k]
            );
            let l15 = this.method306(
                ai2[(j1 - 1 + j) % j],
                ai3[(j1 - 1 + j) % j],
                ai2[j1],
                ai3[j1],
                ai1[k]
            );
            flag = (l1 < i11) | (l1 < l15);

            if (this.method308(i11, l15, l1, !flag)) {
                return true;
            }

            l = (k + 1) % i;
            k = (k - 1 + i) % i;

            if (i1 === j1) {
                byte0 = 2;
            }
        }

        while (byte0 === 0) {
            if (ai1[k] < ai1[l]) {
                if (ai1[k] < ai3[i1]) {
                    if (ai1[k] < ai3[j1]) {
                        let i2 = ai[k];
                        let l6 = this.method306(
                            ai[(l - 1 + i) % i],
                            ai1[(l - 1 + i) % i],
                            ai[l],
                            ai1[l],
                            ai1[k]
                        );
                        let j11 = this.method306(
                            ai2[(i1 + 1) % j],
                            ai3[(i1 + 1) % j],
                            ai2[i1],
                            ai3[i1],
                            ai1[k]
                        );
                        let i16 = this.method306(
                            ai2[(j1 - 1 + j) % j],
                            ai3[(j1 - 1 + j) % j],
                            ai2[j1],
                            ai3[j1],
                            ai1[k]
                        );

                        if (this.method307(i2, l6, j11, i16, flag)) {
                            return true;
                        }

                        k = (k - 1 + i) % i;

                        if (k === l) {
                            byte0 = 1;
                        }
                    } else {
                        let j2 = this.method306(
                            ai[(k + 1) % i],
                            ai1[(k + 1) % i],
                            ai[k],
                            ai1[k],
                            ai3[j1]
                        );
                        let i7 = this.method306(
                            ai[(l - 1 + i) % i],
                            ai1[(l - 1 + i) % i],
                            ai[l],
                            ai1[l],
                            ai3[j1]
                        );
                        let k11 = this.method306(
                            ai2[(i1 + 1) % j],
                            ai3[(i1 + 1) % j],
                            ai2[i1],
                            ai3[i1],
                            ai3[j1]
                        );
                        let j16 = ai2[j1];

                        if (this.method307(j2, i7, k11, j16, flag)) {
                            return true;
                        }

                        j1 = (j1 + 1) % j;

                        if (i1 === j1) {
                            byte0 = 2;
                        }
                    }
                } else if (ai3[i1] < ai3[j1]) {
                    let k2 = this.method306(
                        ai[(k + 1) % i],
                        ai1[(k + 1) % i],
                        ai[k],
                        ai1[k],
                        ai3[i1]
                    );
                    let j7 = this.method306(
                        ai[(l - 1 + i) % i],
                        ai1[(l - 1 + i) % i],
                        ai[l],
                        ai1[l],
                        ai3[i1]
                    );
                    let l11 = ai2[i1];
                    let k16 = this.method306(
                        ai2[(j1 - 1 + j) % j],
                        ai3[(j1 - 1 + j) % j],
                        ai2[j1],
                        ai3[j1],
                        ai3[i1]
                    );

                    if (this.method307(k2, j7, l11, k16, flag)) {
                        return true;
                    }

                    i1 = (i1 - 1 + j) % j;

                    if (i1 === j1) {
                        byte0 = 2;
                    }
                } else {
                    let l2 = this.method306(
                        ai[(k + 1) % i],
                        ai1[(k + 1) % i],
                        ai[k],
                        ai1[k],
                        ai3[j1]
                    );
                    let k7 = this.method306(
                        ai[(l - 1 + i) % i],
                        ai1[(l - 1 + i) % i],
                        ai[l],
                        ai1[l],
                        ai3[j1]
                    );
                    let i12 = this.method306(
                        ai2[(i1 + 1) % j],
                        ai3[(i1 + 1) % j],
                        ai2[i1],
                        ai3[i1],
                        ai3[j1]
                    );
                    let l16 = ai2[j1];

                    if (this.method307(l2, k7, i12, l16, flag)) {
                        return true;
                    }

                    j1 = (j1 + 1) % j;

                    if (i1 === j1) {
                        byte0 = 2;
                    }
                }
            } else if (ai1[l] < ai3[i1]) {
                if (ai1[l] < ai3[j1]) {
                    let i3 = this.method306(
                        ai[(k + 1) % i],
                        ai1[(k + 1) % i],
                        ai[k],
                        ai1[k],
                        ai1[l]
                    );
                    let l7 = ai[l];
                    let j12 = this.method306(
                        ai2[(i1 + 1) % j],
                        ai3[(i1 + 1) % j],
                        ai2[i1],
                        ai3[i1],
                        ai1[l]
                    );
                    let i17 = this.method306(
                        ai2[(j1 - 1 + j) % j],
                        ai3[(j1 - 1 + j) % j],
                        ai2[j1],
                        ai3[j1],
                        ai1[l]
                    );

                    if (this.method307(i3, l7, j12, i17, flag)) {
                        return true;
                    }

                    l = (l + 1) % i;

                    if (k === l) {
                        byte0 = 1;
                    }
                } else {
                    let j3 = this.method306(
                        ai[(k + 1) % i],
                        ai1[(k + 1) % i],
                        ai[k],
                        ai1[k],
                        ai3[j1]
                    );
                    let i8 = this.method306(
                        ai[(l - 1 + i) % i],
                        ai1[(l - 1 + i) % i],
                        ai[l],
                        ai1[l],
                        ai3[j1]
                    );
                    let k12 = this.method306(
                        ai2[(i1 + 1) % j],
                        ai3[(i1 + 1) % j],
                        ai2[i1],
                        ai3[i1],
                        ai3[j1]
                    );
                    let j17 = ai2[j1];

                    if (this.method307(j3, i8, k12, j17, flag)) {
                        return true;
                    }

                    j1 = (j1 + 1) % j;

                    if (i1 === j1) {
                        byte0 = 2;
                    }
                }
            } else if (ai3[i1] < ai3[j1]) {
                let k3 = this.method306(
                    ai[(k + 1) % i],
                    ai1[(k + 1) % i],
                    ai[k],
                    ai1[k],
                    ai3[i1]
                );
                let j8 = this.method306(
                    ai[(l - 1 + i) % i],
                    ai1[(l - 1 + i) % i],
                    ai[l],
                    ai1[l],
                    ai3[i1]
                );
                let l12 = ai2[i1];
                let k17 = this.method306(
                    ai2[(j1 - 1 + j) % j],
                    ai3[(j1 - 1 + j) % j],
                    ai2[j1],
                    ai3[j1],
                    ai3[i1]
                );

                if (this.method307(k3, j8, l12, k17, flag)) {
                    return true;
                }

                i1 = (i1 - 1 + j) % j;

                if (i1 === j1) {
                    byte0 = 2;
                }
            } else {
                let l3 = this.method306(
                    ai[(k + 1) % i],
                    ai1[(k + 1) % i],
                    ai[k],
                    ai1[k],
                    ai3[j1]
                );
                let k8 = this.method306(
                    ai[(l - 1 + i) % i],
                    ai1[(l - 1 + i) % i],
                    ai[l],
                    ai1[l],
                    ai3[j1]
                );
                let i13 = this.method306(
                    ai2[(i1 + 1) % j],
                    ai3[(i1 + 1) % j],
                    ai2[i1],
                    ai3[i1],
                    ai3[j1]
                );
                let l17 = ai2[j1];

                if (this.method307(l3, k8, i13, l17, flag)) {
                    return true;
                }

                j1 = (j1 + 1) % j;

                if (i1 === j1) {
                    byte0 = 2;
                }
            }
        }

        while (byte0 === 1) {
            if (ai1[k] < ai3[i1]) {
                if (ai1[k] < ai3[j1]) {
                    let i4 = ai[k];
                    let j13 = this.method306(
                        ai2[(i1 + 1) % j],
                        ai3[(i1 + 1) % j],
                        ai2[i1],
                        ai3[i1],
                        ai1[k]
                    );
                    let i18 = this.method306(
                        ai2[(j1 - 1 + j) % j],
                        ai3[(j1 - 1 + j) % j],
                        ai2[j1],
                        ai3[j1],
                        ai1[k]
                    );
                    return this.method308(j13, i18, i4, !flag);
                }
                let j4 = this.method306(
                    ai[(k + 1) % i],
                    ai1[(k + 1) % i],
                    ai[k],
                    ai1[k],
                    ai3[j1]
                );
                let l8 = this.method306(
                    ai[(l - 1 + i) % i],
                    ai1[(l - 1 + i) % i],
                    ai[l],
                    ai1[l],
                    ai3[j1]
                );
                let k13 = this.method306(
                    ai2[(i1 + 1) % j],
                    ai3[(i1 + 1) % j],
                    ai2[i1],
                    ai3[i1],
                    ai3[j1]
                );
                let j18 = ai2[j1];

                if (this.method307(j4, l8, k13, j18, flag)) {
                    return true;
                }

                j1 = (j1 + 1) % j;

                if (i1 === j1) {
                    byte0 = 0;
                }
            } else if (ai3[i1] < ai3[j1]) {
                let k4 = this.method306(
                    ai[(k + 1) % i],
                    ai1[(k + 1) % i],
                    ai[k],
                    ai1[k],
                    ai3[i1]
                );
                let i9 = this.method306(
                    ai[(l - 1 + i) % i],
                    ai1[(l - 1 + i) % i],
                    ai[l],
                    ai1[l],
                    ai3[i1]
                );
                let l13 = ai2[i1];
                let k18 = this.method306(
                    ai2[(j1 - 1 + j) % j],
                    ai3[(j1 - 1 + j) % j],
                    ai2[j1],
                    ai3[j1],
                    ai3[i1]
                );

                if (this.method307(k4, i9, l13, k18, flag)) {
                    return true;
                }

                i1 = (i1 - 1 + j) % j;

                if (i1 === j1) {
                    byte0 = 0;
                }
            } else {
                let l4 = this.method306(
                    ai[(k + 1) % i],
                    ai1[(k + 1) % i],
                    ai[k],
                    ai1[k],
                    ai3[j1]
                );
                let j9 = this.method306(
                    ai[(l - 1 + i) % i],
                    ai1[(l - 1 + i) % i],
                    ai[l],
                    ai1[l],
                    ai3[j1]
                );
                let i14 = this.method306(
                    ai2[(i1 + 1) % j],
                    ai3[(i1 + 1) % j],
                    ai2[i1],
                    ai3[i1],
                    ai3[j1]
                );
                let l18 = ai2[j1];

                if (this.method307(l4, j9, i14, l18, flag)) {
                    return true;
                }

                j1 = (j1 + 1) % j;

                if (i1 === j1) {
                    byte0 = 0;
                }
            }
        }

        while (byte0 === 2) {
            if (ai3[i1] < ai1[k]) {
                if (ai3[i1] < ai1[l]) {
                    let i5 = this.method306(
                        ai[(k + 1) % i],
                        ai1[(k + 1) % i],
                        ai[k],
                        ai1[k],
                        ai3[i1]
                    );
                    let k9 = this.method306(
                        ai[(l - 1 + i) % i],
                        ai1[(l - 1 + i) % i],
                        ai[l],
                        ai1[l],
                        ai3[i1]
                    );
                    let j14 = ai2[i1];

                    return this.method308(i5, k9, j14, flag);
                }

                let j5 = this.method306(
                    ai[(k + 1) % i],
                    ai1[(k + 1) % i],
                    ai[k],
                    ai1[k],
                    ai1[l]
                );
                let l9 = ai[l];
                let k14 = this.method306(
                    ai2[(i1 + 1) % j],
                    ai3[(i1 + 1) % j],
                    ai2[i1],
                    ai3[i1],
                    ai1[l]
                );
                let i19 = this.method306(
                    ai2[(j1 - 1 + j) % j],
                    ai3[(j1 - 1 + j) % j],
                    ai2[j1],
                    ai3[j1],
                    ai1[l]
                );

                if (this.method307(j5, l9, k14, i19, flag)) {
                    return true;
                }

                l = (l + 1) % i;

                if (k === l) {
                    byte0 = 0;
                }
            } else if (ai1[k] < ai1[l]) {
                let k5 = ai[k];
                let i10 = this.method306(
                    ai[(l - 1 + i) % i],
                    ai1[(l - 1 + i) % i],
                    ai[l],
                    ai1[l],
                    ai1[k]
                );
                let l14 = this.method306(
                    ai2[(i1 + 1) % j],
                    ai3[(i1 + 1) % j],
                    ai2[i1],
                    ai3[i1],
                    ai1[k]
                );
                let j19 = this.method306(
                    ai2[(j1 - 1 + j) % j],
                    ai3[(j1 - 1 + j) % j],
                    ai2[j1],
                    ai3[j1],
                    ai1[k]
                );

                if (this.method307(k5, i10, l14, j19, flag)) {
                    return true;
                }

                k = (k - 1 + i) % i;

                if (k === l) {
                    byte0 = 0;
                }
            } else {
                let l5 = this.method306(
                    ai[(k + 1) % i],
                    ai1[(k + 1) % i],
                    ai[k],
                    ai1[k],
                    ai1[l]
                );
                let j10 = ai[l];
                let i15 = this.method306(
                    ai2[(i1 + 1) % j],
                    ai3[(i1 + 1) % j],
                    ai2[i1],
                    ai3[i1],
                    ai1[l]
                );
                let k19 = this.method306(
                    ai2[(j1 - 1 + j) % j],
                    ai3[(j1 - 1 + j) % j],
                    ai2[j1],
                    ai3[j1],
                    ai1[l]
                );

                if (this.method307(l5, j10, i15, k19, flag)) {
                    return true;
                }

                l = (l + 1) % i;

                if (k === l) {
                    byte0 = 0;
                }
            }
        }

        if (ai1[k] < ai3[i1]) {
            let i6 = ai[k];
            let j15 = this.method306(
                ai2[(i1 + 1) % j],
                ai3[(i1 + 1) % j],
                ai2[i1],
                ai3[i1],
                ai1[k]
            );
            let l19 = this.method306(
                ai2[(j1 - 1 + j) % j],
                ai3[(j1 - 1 + j) % j],
                ai2[j1],
                ai3[j1],
                ai1[k]
            );

            return this.method308(j15, l19, i6, !flag);
        }

        let j6 = this.method306(
            ai[(k + 1) % i],
            ai1[(k + 1) % i],
            ai[k],
            ai1[k],
            ai3[i1]
        );
        let k10 = this.method306(
            ai[(l - 1 + i) % i],
            ai1[(l - 1 + i) % i],
            ai[l],
            ai1[l],
            ai3[i1]
        );
        let k15 = ai2[i1];

        return this.method308(j6, k10, k15, flag);
    }
}

Scene.aByteArray434 = null;
Scene.frustumFarZ = 0;
Scene.frustumMaxX = 0;
Scene.frustumMaxY = 0;
Scene.frustumMinX = 0;
Scene.frustumMinY = 0;
Scene.frustumNearZ = 0;
Scene.sin512Cache = new Int32Array(512);
Scene.sinCosCache = new Int32Array(2048);
Scene.textureCountLoaded = new Long(0);

module.exports = Scene;

},{"./polygon":70,"./scanline":71,"long":33}],73:[function(require,module,exports){
const PCMPlayer = require('pcm-player');
const { mulaw } = require('alawmulaw');

class StreamAudioPlayer {
    constructor() {
        this.player = new PCMPlayer({
            encoding: '16bitInt',
            channels: 1,
            sampleRate: 8000
        });
    }

    stopPlayer() {
        this.player.destroy();
    }

    writeStream(buffer, offset, length) {
        const decoded = mulaw.decode(
            new Uint8Array(buffer.slice(offset, offset + length))
        );

        this.player.feed(decoded);
    }
}

module.exports = StreamAudioPlayer;

},{"alawmulaw":26,"pcm-player":35}],74:[function(require,module,exports){
const Utility = require('./utility');

const BLACK = 0;
const DARK_GREY = 0xa0a0a0;
const LIGHT_GREY = 0xdcdcdc;

const C_0 = '0'.charCodeAt(0);
const C_9 = '9'.charCodeAt(0);

// canvas imagedata needs an alpha channel, but the client only uses rgb
function fixPixel(pixel) {
    const r = (pixel >> 16) & 255;
    const g = (pixel >> 8) & 255;
    const b = pixel & 255;
    const a = 255; // alpha always 255

    return (a << 24) + (b << 16) + (g << 8) + r;
}

class Surface {
    constructor(width, height, limit, component) {
        this.image = null;
        this.landscapeColours = null;
        this.anIntArray340 = null;
        this.anIntArray341 = null;
        this.anIntArray342 = null;
        this.anIntArray343 = null;
        this.anIntArray344 = null;
        this.anIntArray345 = null;
        this.boundsTopY = 0;
        this.boundsTopX = 0;

        this.interlace = false;
        this.loggedIn = false;
        this.boundsBottomY = height;
        this.boundsBottomX = width;
        this.width1 = this.width2 = width;
        this.height1 = this.height2 = height;
        this.area = width * height;
        this.pixels = new Int32Array(width * height);

        this.surfacePixels = [];
        this.surfacePixels.length = limit;
        this.surfacePixels.fill(null);
        this.spriteColoursUsed = [];
        this.spriteColoursUsed.length = limit;
        this.spriteColoursUsed.fill(null);
        this.spriteColourList = [];
        this.spriteColourList.length = limit;
        this.spriteColourList.fill(null);
        this.spriteTranslate = new Int8Array(limit);
        this.spriteWidth = new Int32Array(limit);
        this.spriteHeight = new Int32Array(limit);
        this.spriteWidthFull = new Int32Array(limit);
        this.spriteHeightFull = new Int32Array(limit);
        this.spriteTranslateX = new Int32Array(limit);
        this.spriteTranslateY = new Int32Array(limit);

        this.imageData = component._graphics.ctx.getImageData(
            0,
            0,
            width,
            height
        );
        this.bufferedPixels = new Int32Array(width * height);
        this.pixelBytes = new Uint8ClampedArray(this.bufferedPixels.buffer);

        this.setComplete();
    }

    static rgbToInt(red, green, blue) {
        return (red << 16) + (green << 8) + blue;
    }

    static createFont(bytes, id) {
        Surface.gameFonts[id] = bytes;
    }

    setComplete() {
        for (let i = 0; i < this.area; i += 1) {
            this.bufferedPixels[i] = fixPixel(this.pixels[i]);
        }

        this.imageData.data.set(this.pixelBytes, 0, 0);
    }

    setBounds(x1, y1, x2, y2) {
        if (x1 < 0) {
            x1 = 0;
        }

        if (y1 < 0) {
            y1 = 0;
        }

        if (x2 > this.width2) {
            x2 = this.width2;
        }

        if (y2 > this.height2) {
            y2 = this.height2;
        }

        this.boundsTopX = x1;
        this.boundsTopY = y1;
        this.boundsBottomX = x2;
        this.boundsBottomY = y2;
    }

    resetBounds() {
        this.boundsTopX = 0;
        this.boundsTopY = 0;
        this.boundsBottomX = this.width2;
        this.boundsBottomY = this.height2;
    }

    draw(g, x, y) {
        // blit our canvas to the page's canvas
        this.setComplete();
        g.drawImage(this.imageData, x, y);
    }

    blackScreen() {
        let area = this.width2 * this.height2;

        if (!this.interlace) {
            for (let j = 0; j < area; j++) {
                this.pixels[j] = 0;
            }

            return;
        }

        let k = 0;

        for (let l = -this.height2; l < 0; l += 2) {
            for (let i1 = -this.width2; i1 < 0; i1++) {
                this.pixels[k++] = 0;
            }

            k += this.width2;
        }
    }

    drawCircle(x, y, radius, colour, alpha) {
        const bgAlpha = 256 - alpha;
        const red = ((colour >> 16) & 0xff) * alpha;
        const green = ((colour >> 8) & 0xff) * alpha;
        const blue = (colour & 0xff) * alpha;
        let top = y - radius;

        if (top < 0) {
            top = 0;
        }

        let bottom = y + radius;

        if (bottom >= this.height2) {
            bottom = this.height2 - 1;
        }

        let vertInc = 1;

        if (this.interlace) {
            vertInc = 2;

            if ((top & 1) !== 0) {
                top++;
            }
        }

        for (let yy = top; yy <= bottom; yy += vertInc) {
            const l3 = yy - y;
            const i4 = Math.sqrt(radius * radius - l3 * l3) | 0;
            let j4 = x - i4;

            if (j4 < 0) {
                j4 = 0;
            }

            let k4 = x + i4;

            if (k4 >= this.width2) {
                k4 = this.width2 - 1;
            }

            let index = j4 + yy * this.width2;

            for (let i = j4; i <= k4; i++) {
                const bgRed = ((this.pixels[index] >> 16) & 0xff) * bgAlpha;
                const bgGreen = ((this.pixels[index] >> 8) & 0xff) * bgAlpha;
                const bgBlue = (this.pixels[index] & 0xff) * bgAlpha;

                const newColour =
                    (((red + bgRed) >> 8) << 16) +
                    (((green + bgGreen) >> 8) << 8) +
                    ((blue + bgBlue) >> 8);

                this.pixels[index++] = newColour;
            }
        }
    }

    drawBoxAlpha(x, y, width, height, colour, alpha) {
        if (x < this.boundsTopX) {
            width -= this.boundsTopX - x;
            x = this.boundsTopX;
        }

        if (y < this.boundsTopY) {
            height -= this.boundsTopY - y;
            y = this.boundsTopY;
        }

        if (x + width > this.boundsBottomX) {
            width = this.boundsBottomX - x;
        }

        if (y + height > this.boundsBottomY) {
            height = this.boundsBottomY - y;
        }

        let bgAlpha = 256 - alpha;
        let red = ((colour >> 16) & 0xff) * alpha;
        let green = ((colour >> 8) & 0xff) * alpha;
        let blue = (colour & 0xff) * alpha;
        let j3 = this.width2 - width; // wat
        let vertInc = 1;

        if (this.interlace) {
            vertInc = 2;
            j3 += this.width2;

            if ((y & 1) !== 0) {
                y++;
                height--;
            }
        }

        let pixelIdx = x + y * this.width2;

        for (let l3 = 0; l3 < height; l3 += vertInc) {
            for (let i4 = -width; i4 < 0; i4++) {
                let bgRed = ((this.pixels[pixelIdx] >> 16) & 0xff) * bgAlpha;
                let bgGreen = ((this.pixels[pixelIdx] >> 8) & 0xff) * bgAlpha;
                let bgBlue = (this.pixels[pixelIdx] & 0xff) * bgAlpha;
                let newColour =
                    (((red + bgRed) >> 8) << 16) +
                    (((green + bgGreen) >> 8) << 8) +
                    ((blue + bgBlue) >> 8);
                this.pixels[pixelIdx++] = newColour;
            }

            pixelIdx += j3;
        }
    }

    drawGradient(x, y, width, height, colourTop, colourBottom) {
        if (x < this.boundsTopX) {
            width -= this.boundsTopX - x;
            x = this.boundsTopX;
        }

        if (x + width > this.boundsBottomX) {
            width = this.boundsBottomX - x;
        }

        let btmRed = (colourBottom >> 16) & 0xff;
        let btmGreen = (colourBottom >> 8) & 0xff;
        let btmBlue = colourBottom & 0xff;
        let topRed = (colourTop >> 16) & 0xff;
        let topGreen = (colourTop >> 8) & 0xff;
        let topBlue = colourTop & 0xff;
        let i3 = this.width2 - width; // wat
        let vertInc = 1;

        if (this.interlace) {
            vertInc = 2;
            i3 += this.width2;

            if ((y & 1) !== 0) {
                y++;
                height--;
            }
        }

        let pixelIdx = x + y * this.width2;

        for (let k3 = 0; k3 < height; k3 += vertInc) {
            if (k3 + y >= this.boundsTopY && k3 + y < this.boundsBottomY) {
                let newColour =
                    (((btmRed * k3 + topRed * (height - k3)) / height) << 16) +
                    (((btmGreen * k3 + topGreen * (height - k3)) / height) <<
                        8) +
                    (((btmBlue * k3 + topBlue * (height - k3)) / height) | 0);

                for (let i4 = -width; i4 < 0; i4++) {
                    this.pixels[pixelIdx++] = newColour;
                }

                pixelIdx += i3;
            } else {
                pixelIdx += this.width2;
            }
        }
    }

    drawBox(x, y, w, h, colour) {
        if (x < this.boundsTopX) {
            w -= this.boundsTopX - x;
            x = this.boundsTopX;
        }

        if (y < this.boundsTopY) {
            h -= this.boundsTopY - y;
            y = this.boundsTopY;
        }

        if (x + w > this.boundsBottomX) {
            w = this.boundsBottomX - x;
        }

        if (y + h > this.boundsBottomY) {
            h = this.boundsBottomY - y;
        }

        let j1 = this.width2 - w; // wat
        let vertInc = 1;

        if (this.interlace) {
            vertInc = 2;
            j1 += this.width2;

            if ((y & 1) !== 0) {
                y++;
                h--;
            }
        }

        let pixelIdx = x + y * this.width2;

        for (let l1 = -h; l1 < 0; l1 += vertInc) {
            for (let i2 = -w; i2 < 0; i2++) {
                this.pixels[pixelIdx++] = colour;
            }

            pixelIdx += j1;
        }
    }

    drawBoxEdge(x, y, width, height, colour) {
        this.drawLineHoriz(x, y, width, colour);
        this.drawLineHoriz(x, y + height - 1, width, colour);
        this.drawLineVert(x, y, height, colour);
        this.drawLineVert(x + width - 1, y, height, colour);
    }

    drawLineHoriz(x, y, width, colour) {
        if (y < this.boundsTopY || y >= this.boundsBottomY) {
            return;
        }

        if (x < this.boundsTopX) {
            width -= this.boundsTopX - x;
            x = this.boundsTopX;
        }

        if (x + width > this.boundsBottomX) {
            width = this.boundsBottomX - x;
        }

        let i1 = x + y * this.width2;

        for (let j1 = 0; j1 < width; j1++) {
            this.pixels[i1 + j1] = colour;
        }
    }

    drawLineVert(x, y, height, colour) {
        if (x < this.boundsTopX || x >= this.boundsBottomX) {
            return;
        }

        if (y < this.boundsTopY) {
            height -= this.boundsTopY - y;
            y = this.boundsTopY;
        }

        if (y + height > this.boundsBottomX) {
            height = this.boundsBottomY - y;
        }

        let i1 = x + y * this.width2;

        for (let j1 = 0; j1 < height; j1++) {
            this.pixels[i1 + j1 * this.width2] = colour;
        }
    }

    setPixel(x, y, colour) {
        if (
            x < this.boundsTopX ||
            y < this.boundsTopY ||
            x >= this.boundsBottomX ||
            y >= this.boundsBottomY
        ) {
            return;
        } else {
            this.pixels[x + y * this.width2] = colour;

            return;
        }
    }

    fadeToBlack() {
        let k = this.width2 * this.height2;

        for (let j = 0; j < k; j++) {
            let i = this.pixels[j] & 0xffffff;
            this.pixels[j] =
                ((i >>> 1) & 0x7f7f7f) +
                ((i >>> 2) & 0x3f3f3f) +
                ((i >>> 3) & 0x1f1f1f) +
                ((i >>> 4) & 0xf0f0f);
        }
    }

    drawLineAlpha(i, j, x, y, width, height) {
        for (let xx = x; xx < x + width; xx++) {
            for (let yy = y; yy < y + height; yy++) {
                let i2 = 0;
                let j2 = 0;
                let k2 = 0;
                let l2 = 0;

                for (let i3 = xx - i; i3 <= xx + i; i3++)
                    if (i3 >= 0 && i3 < this.width2) {
                        for (let j3 = yy - j; j3 <= yy + j; j3++) {
                            if (j3 >= 0 && j3 < this.height2) {
                                let k3 = this.pixels[i3 + this.width2 * j3];
                                i2 += (k3 >> 16) & 0xff;
                                j2 += (k3 >> 8) & 0xff;
                                k2 += k3 & 0xff;
                                l2++;
                            }
                        }
                    }

                this.pixels[xx + this.width2 * yy] =
                    ((i2 / l2) << 16) + ((j2 / l2) << 8) + ((k2 / l2) | 0);
            }
        }
    }

    clear() {
        for (let i = 0; i < this.surfacePixels.length; i++) {
            this.surfacePixels[i] = null;
            this.spriteWidth[i] = 0;
            this.spriteHeight[i] = 0;
            this.spriteColoursUsed[i] = null;
            this.spriteColourList[i] = null;
        }
    }

    parseSprite(spriteId, spriteData, indexData, frameCount) {
        let indexOff = Utility.getUnsignedShort(spriteData, 0);
        let fullWidth = Utility.getUnsignedShort(indexData, indexOff);
        indexOff += 2;

        let fullHeight = Utility.getUnsignedShort(indexData, indexOff);
        indexOff += 2;

        let colourCount = indexData[indexOff++] & 0xff;
        let colours = new Int32Array(colourCount);
        colours[0] = 0xff00ff;

        for (let i = 0; i < colourCount - 1; i++) {
            colours[i + 1] =
                ((indexData[indexOff] & 0xff) << 16) +
                ((indexData[indexOff + 1] & 0xff) << 8) +
                (indexData[indexOff + 2] & 0xff);
            indexOff += 3;
        }

        let spriteOff = 2;

        for (let id = spriteId; id < spriteId + frameCount; id++) {
            this.spriteTranslateX[id] = indexData[indexOff++] & 0xff;
            this.spriteTranslateY[id] = indexData[indexOff++] & 0xff;
            this.spriteWidth[id] = Utility.getUnsignedShort(
                indexData,
                indexOff
            );
            indexOff += 2;

            this.spriteHeight[id] = Utility.getUnsignedShort(
                indexData,
                indexOff
            );
            indexOff += 2;

            let unknown = indexData[indexOff++] & 0xff;
            let size = this.spriteWidth[id] * this.spriteHeight[id];

            this.spriteColoursUsed[id] = new Int8Array(size);
            this.spriteColourList[id] = colours;
            this.spriteWidthFull[id] = fullWidth;
            this.spriteHeightFull[id] = fullHeight;
            this.surfacePixels[id] = null;
            this.spriteTranslate[id] = false;

            if (
                this.spriteTranslateX[id] !== 0 ||
                this.spriteTranslateY[id] !== 0
            ) {
                this.spriteTranslate[id] = true;
            }

            if (unknown === 0) {
                for (let pixel = 0; pixel < size; pixel++) {
                    this.spriteColoursUsed[id][pixel] = spriteData[spriteOff++];

                    if (this.spriteColoursUsed[id][pixel] === 0) {
                        this.spriteTranslate[id] = true;
                    }
                }
            } else if (unknown === 1) {
                for (let x = 0; x < this.spriteWidth[id]; x++) {
                    for (let y = 0; y < this.spriteHeight[id]; y++) {
                        this.spriteColoursUsed[id][
                            x + y * this.spriteWidth[id]
                        ] = spriteData[spriteOff++];

                        if (
                            this.spriteColoursUsed[id][
                                x + y * this.spriteWidth[id]
                            ] === 0
                        ) {
                            this.spriteTranslate[id] = true;
                        }
                    }
                }
            }
        }
    }

    readSleepWord(spriteId, spriteData) {
        const pixels = (this.surfacePixels[spriteId] = new Int32Array(10200));

        this.spriteWidth[spriteId] = 255;
        this.spriteHeight[spriteId] = 40;
        this.spriteTranslateX[spriteId] = 0;
        this.spriteTranslateY[spriteId] = 0;
        this.spriteWidthFull[spriteId] = 255;
        this.spriteHeightFull[spriteId] = 40;
        this.spriteTranslate[spriteId] = false;

        let colour = 0;
        let packetOffset = 1;
        let pixelOffset = 0;

        for (pixelOffset = 0; pixelOffset < 255; ) {
            const length = spriteData[packetOffset++] & 0xff;

            for (let i = 0; i < length; i++) {
                pixels[pixelOffset++] = colour;
            }

            // alternate between black and white
            colour = 0xffffff - colour;
        }

        for (let y = 1; y < 40; y++) {
            for (let x = 0; x < 255; ) {
                const length = spriteData[packetOffset++] & 0xff;

                for (let i = 0; i < length; i++) {
                    pixels[pixelOffset] = pixels[pixelOffset - 255];
                    pixelOffset++;
                    x++;
                }

                if (x < 255) {
                    pixels[pixelOffset] = 0xffffff - pixels[pixelOffset - 255];
                    pixelOffset++;
                    x++;
                }
            }
        }
    }

    drawWorld(spriteId) {
        let spriteSize =
            this.spriteWidth[spriteId] * this.spriteHeight[spriteId];
        let spritePixels = this.surfacePixels[spriteId];
        let ai1 = new Int32Array(32768);

        for (let k = 0; k < spriteSize; k++) {
            let l = spritePixels[k];
            ai1[
                ((l & 0xf80000) >> 9) + ((l & 0xf800) >> 6) + ((l & 0xf8) >> 3)
            ]++;
        }

        let ai2 = new Int32Array(256);
        ai2[0] = 0xff00ff;

        let ai3 = new Int32Array(256);

        for (let i1 = 0; i1 < 32768; i1++) {
            let j1 = ai1[i1];

            if (j1 > ai3[255]) {
                for (let k1 = 1; k1 < 256; k1++) {
                    if (j1 <= ai3[k1]) {
                        continue;
                    }

                    for (let i2 = 255; i2 > k1; i2--) {
                        ai2[i2] = ai2[i2 - 1];
                        ai3[i2] = ai3[i2 - 1];
                    }

                    ai2[k1] =
                        ((i1 & 0x7c00) << 9) +
                        ((i1 & 0x3e0) << 6) +
                        ((i1 & 0x1f) << 3) +
                        0x40404;
                    ai3[k1] = j1;
                    break;
                }
            }

            ai1[i1] = -1;
        }

        let abyte0 = new Int8Array(spriteSize);

        for (let l1 = 0; l1 < spriteSize; l1++) {
            let j2 = spritePixels[l1];
            let k2 =
                ((j2 & 0xf80000) >> 9) +
                ((j2 & 0xf800) >> 6) +
                ((j2 & 0xf8) >> 3);
            let l2 = ai1[k2];

            if (l2 === -1) {
                let i3 = 999999999;
                let j3 = (j2 >> 16) & 0xff;
                let k3 = (j2 >> 8) & 0xff;
                let l3 = j2 & 0xff;

                for (let i4 = 0; i4 < 256; i4++) {
                    let j4 = ai2[i4];
                    let k4 = (j4 >> 16) & 0xff;
                    let l4 = (j4 >> 8) & 0xff;
                    let i5 = j4 & 0xff;
                    let j5 =
                        (j3 - k4) * (j3 - k4) +
                        (k3 - l4) * (k3 - l4) +
                        (l3 - i5) * (l3 - i5);

                    if (j5 < i3) {
                        i3 = j5;
                        l2 = i4;
                    }
                }

                ai1[k2] = l2;
            }

            abyte0[l1] = l2 & 0xff; // << 24 >> 24
        }

        this.spriteColoursUsed[spriteId] = abyte0;
        this.spriteColourList[spriteId] = ai2;
        this.surfacePixels[spriteId] = null;
    }

    loadSprite(spriteId) {
        if (this.spriteColoursUsed[spriteId] === null) {
            return;
        }

        let size = this.spriteWidth[spriteId] * this.spriteHeight[spriteId];
        let idx = this.spriteColoursUsed[spriteId];
        let cols = this.spriteColourList[spriteId];
        let pixels = new Int32Array(size);

        for (let pixel = 0; pixel < size; pixel++) {
            let colour = cols[idx[pixel] & 0xff];

            if (colour === 0) {
                colour = 1;
            } else if (colour === 0xff00ff) {
                colour = 0;
            }

            pixels[pixel] = colour;
        }

        this.surfacePixels[spriteId] = pixels;
        this.spriteColoursUsed[spriteId] = null;
        this.spriteColourList[spriteId] = null;
    }

    // used from World
    drawSpriteMinimap(sprite, x, y, width, height) {
        this.spriteWidth[sprite] = width;
        this.spriteHeight[sprite] = height;
        this.spriteTranslate[sprite] = false;
        this.spriteTranslateX[sprite] = 0;
        this.spriteTranslateY[sprite] = 0;
        this.spriteWidthFull[sprite] = width;
        this.spriteHeightFull[sprite] = height;

        let area = width * height;
        let pixel = 0;

        this.surfacePixels[sprite] = new Int32Array(area);

        for (let xx = x; xx < x + width; xx++) {
            for (let yy = y; yy < y + height; yy++) {
                this.surfacePixels[sprite][pixel++] = this.pixels[
                    xx + yy * this.width2
                ];
            }
        }
    }

    // used from mudclient
    _drawSprite_from5(sprite, x, y, width, height) {
        this.spriteWidth[sprite] = width;
        this.spriteHeight[sprite] = height;
        this.spriteTranslate[sprite] = false;
        this.spriteTranslateX[sprite] = 0;
        this.spriteTranslateY[sprite] = 0;
        this.spriteWidthFull[sprite] = width;
        this.spriteHeightFull[sprite] = height;

        let area = width * height;
        let pixel = 0;

        this.surfacePixels[sprite] = new Int32Array(area);

        for (let yy = y; yy < y + height; yy++) {
            for (let xx = x; xx < x + width; xx++) {
                this.surfacePixels[sprite][pixel++] = this.pixels[
                    xx + yy * this.width2
                ];
            }
        }
    }

    _drawSprite_from3(x, y, id) {
        if (this.spriteTranslate[id]) {
            x += this.spriteTranslateX[id];
            y += this.spriteTranslateY[id];
        }

        let rY = x + y * this.width2;
        let rX = 0;
        let height = this.spriteHeight[id];
        let width = this.spriteWidth[id];
        let w2 = this.width2 - width;
        let h2 = 0;

        if (y < this.boundsTopY) {
            let j2 = this.boundsTopY - y;
            height -= j2;
            y = this.boundsTopY;
            rX += j2 * width;
            rY += j2 * this.width2;
        }

        if (y + height >= this.boundsBottomY) {
            height -= y + height - this.boundsBottomY + 1;
        }

        if (x < this.boundsTopX) {
            let k2 = this.boundsTopX - x;
            width -= k2;
            x = this.boundsTopX;
            rX += k2;
            rY += k2;
            h2 += k2;
            w2 += k2;
        }

        if (x + width >= this.boundsBottomX) {
            let l2 = x + width - this.boundsBottomX + 1;
            width -= l2;
            h2 += l2;
            w2 += l2;
        }

        if (width <= 0 || height <= 0) {
            return;
        }

        let inc = 1;

        if (this.interlace) {
            inc = 2;
            w2 += this.width2;
            h2 += this.spriteWidth[id];

            if ((y & 1) !== 0) {
                rY += this.width2;
                height--;
            }
        }

        if (this.surfacePixels[id] === null) {
            this._drawSprite_from10A(
                this.pixels,
                this.spriteColoursUsed[id],
                this.spriteColourList[id],
                rX,
                rY,
                width,
                height,
                w2,
                h2,
                inc
            );
            return;
        } else {
            this._drawSprite_from10(
                this.pixels,
                this.surfacePixels[id],
                0,
                rX,
                rY,
                width,
                height,
                w2,
                h2,
                inc
            );
            return;
        }
    }

    _spriteClipping_from5(x, y, width, height, spriteId) {
        try {
            let spriteWidth = this.spriteWidth[spriteId];
            let spriteHeight = this.spriteHeight[spriteId];
            let l1 = 0;
            let i2 = 0;
            let j2 = ((spriteWidth << 16) / width) | 0;
            let k2 = ((spriteHeight << 16) / height) | 0;

            if (this.spriteTranslate[spriteId]) {
                let l2 = this.spriteWidthFull[spriteId];
                let j3 = this.spriteHeightFull[spriteId];
                j2 = ((l2 << 16) / width) | 0;
                k2 = ((j3 << 16) / height) | 0;

                x +=
                    ((this.spriteTranslateX[spriteId] * width + l2 - 1) / l2) |
                    0;
                y +=
                    ((this.spriteTranslateY[spriteId] * height + j3 - 1) / j3) |
                    0;

                if ((this.spriteTranslateX[spriteId] * width) % l2 !== 0) {
                    l1 =
                        (((l2 -
                            ((this.spriteTranslateX[spriteId] * width) % l2)) <<
                            16) /
                            width) |
                        0;
                }

                if ((this.spriteTranslateY[spriteId] * height) % j3 !== 0) {
                    i2 =
                        (((j3 -
                            ((this.spriteTranslateY[spriteId] * height) %
                                j3)) <<
                            16) /
                            height) |
                        0;
                }

                width =
                    ((width * (this.spriteWidth[spriteId] - (l1 >> 16))) / l2) |
                    0;
                height =
                    ((height * (this.spriteHeight[spriteId] - (i2 >> 16))) /
                        j3) |
                    0;
            }

            let i3 = x + y * this.width2;
            let k3 = this.width2 - width;

            if (y < this.boundsTopY) {
                let l3 = this.boundsTopY - y;
                height -= l3;
                y = 0;
                i3 += l3 * this.width2;
                i2 += k2 * l3;
            }

            if (y + height >= this.boundsBottomY) {
                height -= y + height - this.boundsBottomY + 1;
            }

            if (x < this.boundsTopX) {
                let i4 = this.boundsTopX - x;
                width -= i4;
                x = 0;
                i3 += i4;
                l1 += j2 * i4;
                k3 += i4;
            }

            if (x + width >= this.boundsBottomX) {
                let j4 = x + width - this.boundsBottomX + 1;
                width -= j4;
                k3 += j4;
            }

            let yInc = 1;

            if (this.interlace) {
                yInc = 2;
                k3 += this.width2;
                k2 += k2;

                if ((y & 1) !== 0) {
                    i3 += this.width2;
                    height--;
                }
            }

            this._plotScale_from13(
                this.pixels,
                this.surfacePixels[spriteId],
                0,
                l1,
                i2,
                i3,
                k3,
                width,
                height,
                j2,
                k2,
                spriteWidth,
                yInc
            );
        } catch (e) {
            console.log('error in sprite clipping routine');
        }
    }

    _spriteClipping_from7(x, y, w, h, id, tx, ty) {
        if (id >= 50000) {
            this.mudclientref.drawTeleportBubble(
                x,
                y,
                w,
                h,
                id - 50000,
                tx,
                ty
            );
            return;
        }

        if (id >= 40000) {
            this.mudclientref.drawItem(x, y, w, h, id - 40000, tx, ty);
            return;
        }

        if (id >= 20000) {
            this.mudclientref.drawNpc(x, y, w, h, id - 20000, tx, ty);
            return;
        }

        if (id >= 5000) {
            this.mudclientref.drawPlayer(x, y, w, h, id - 5000, tx, ty);
            return;
        } else {
            this._spriteClipping_from5(x, y, w, h, id);
            return;
        }
    }

    _drawSpriteAlpha_from4(x, y, spriteId, alpha) {
        if (this.spriteTranslate[spriteId]) {
            x += this.spriteTranslateX[spriteId];
            y += this.spriteTranslateY[spriteId];
        }

        let size = x + y * this.width2;
        let j1 = 0;
        let height = this.spriteHeight[spriteId];
        let width = this.spriteWidth[spriteId];
        let extraXSpace = this.width2 - width;
        let j2 = 0;

        if (y < this.boundsTopY) {
            let k2 = this.boundsTopY - y;
            height -= k2;
            y = this.boundsTopY;
            j1 += k2 * width;
            size += k2 * this.width2;
        }

        if (y + height >= this.boundsBottomY) {
            height -= y + height - this.boundsBottomY + 1;
        }

        if (x < this.boundsTopX) {
            let l2 = this.boundsTopX - x;
            width -= l2;
            x = this.boundsTopX;
            j1 += l2;
            size += l2;
            j2 += l2;
            extraXSpace += l2;
        }

        if (x + width >= this.boundsBottomX) {
            let i3 = x + width - this.boundsBottomX + 1;
            width -= i3;
            j2 += i3;
            extraXSpace += i3;
        }

        if (width <= 0 || height <= 0) {
            return;
        }

        let yInc = 1;

        if (this.interlace) {
            yInc = 2;
            extraXSpace += this.width2;
            j2 += this.spriteWidth[spriteId];

            if ((y & 1) !== 0) {
                size += this.width2;
                height--;
            }
        }

        if (this.surfacePixels[spriteId] === null) {
            this._drawSpriteAlpha_from11A(
                this.pixels,
                this.spriteColoursUsed[spriteId],
                this.spriteColourList[spriteId],
                j1,
                size,
                width,
                height,
                extraXSpace,
                j2,
                yInc,
                alpha
            );
            return;
        } else {
            this._drawSpriteAlpha_from11(
                this.pixels,
                this.surfacePixels[spriteId],
                0,
                j1,
                size,
                width,
                height,
                extraXSpace,
                j2,
                yInc,
                alpha
            );
            return;
        }
    }

    drawActionBubble(x, y, scaleX, scaleY, sprite, alpha) {
        try {
            let spriteWidth = this.spriteWidth[sprite];
            let spriteHeight = this.spriteHeight[sprite];
            let i2 = 0;
            let j2 = 0;
            let k2 = ((spriteWidth << 16) / scaleX) | 0;
            let l2 = ((spriteHeight << 16) / scaleY) | 0;

            if (this.spriteTranslate[sprite]) {
                let i3 = this.spriteWidthFull[sprite];
                let k3 = this.spriteHeightFull[sprite];
                k2 = ((i3 << 16) / scaleX) | 0;
                l2 = ((k3 << 16) / scaleY) | 0;

                x +=
                    ((this.spriteTranslateX[sprite] * scaleX + i3 - 1) / i3) |
                    0;
                y +=
                    ((this.spriteTranslateY[sprite] * scaleY + k3 - 1) / k3) |
                    0;

                if ((this.spriteTranslateX[sprite] * scaleX) % i3 !== 0) {
                    i2 =
                        (((i3 -
                            ((this.spriteTranslateX[sprite] * scaleX) % i3)) <<
                            16) /
                            scaleX) |
                        0;
                }

                if ((this.spriteTranslateY[sprite] * scaleY) % k3 !== 0) {
                    j2 =
                        (((k3 -
                            ((this.spriteTranslateY[sprite] * scaleY) % k3)) <<
                            16) /
                            scaleY) |
                        0;
                }

                scaleX =
                    ((scaleX * (this.spriteWidth[sprite] - (i2 >> 16))) / i3) |
                    0;
                scaleY =
                    ((scaleY * (this.spriteHeight[sprite] - (j2 >> 16))) / k3) |
                    0;
            }

            let j3 = x + y * this.width2;
            let l3 = this.width2 - scaleX;

            if (y < this.boundsTopY) {
                let i4 = this.boundsTopY - y;
                scaleY -= i4;
                y = 0;
                j3 += i4 * this.width2;
                j2 += l2 * i4;
            }

            if (y + scaleY >= this.boundsBottomY)
                scaleY -= y + scaleY - this.boundsBottomY + 1;

            if (x < this.boundsTopX) {
                let j4 = this.boundsTopX - x;
                scaleX -= j4;
                x = 0;
                j3 += j4;
                i2 += k2 * j4;
                l3 += j4;
            }

            if (x + scaleX >= this.boundsBottomX) {
                let k4 = x + scaleX - this.boundsBottomX + 1;
                scaleX -= k4;
                l3 += k4;
            }

            let yInc = 1;

            if (this.interlace) {
                yInc = 2;
                l3 += this.width2;
                l2 += l2;

                if ((y & 1) !== 0) {
                    j3 += this.width2;
                    scaleY--;
                }
            }

            this.transparentScale(
                this.pixels,
                this.surfacePixels[sprite],
                0,
                i2,
                j2,
                j3,
                l3,
                scaleX,
                scaleY,
                k2,
                l2,
                spriteWidth,
                yInc,
                alpha
            );
            return;
        } catch (e) {
            console.log('error in sprite clipping routine');
        }
    }

    _spriteClipping_from6(x, y, width, height, spriteId, colour) {
        try {
            let k1 = this.spriteWidth[spriteId];
            let l1 = this.spriteHeight[spriteId];
            let i2 = 0;
            let j2 = 0;
            let k2 = ((k1 << 16) / width) | 0;
            let l2 = ((l1 << 16) / height) | 0;

            if (this.spriteTranslate[spriteId]) {
                let i3 = this.spriteWidthFull[spriteId];
                let k3 = this.spriteHeightFull[spriteId];
                k2 = ((i3 << 16) / width) | 0;
                l2 = ((k3 << 16) / height) | 0;
                x +=
                    ((this.spriteTranslateX[spriteId] * width + i3 - 1) / i3) |
                    0;
                y +=
                    ((this.spriteTranslateY[spriteId] * height + k3 - 1) / k3) |
                    0;

                if ((this.spriteTranslateX[spriteId] * width) % i3 !== 0) {
                    i2 =
                        (((i3 -
                            ((this.spriteTranslateX[spriteId] * width) % i3)) <<
                            16) /
                            width) |
                        0;
                }

                if ((this.spriteTranslateY[spriteId] * height) % k3 !== 0) {
                    j2 =
                        (((k3 -
                            ((this.spriteTranslateY[spriteId] * height) %
                                k3)) <<
                            16) /
                            height) |
                        0;
                }

                width =
                    ((width * (this.spriteWidth[spriteId] - (i2 >> 16))) / i3) |
                    0;
                height =
                    ((height * (this.spriteHeight[spriteId] - (j2 >> 16))) /
                        k3) |
                    0;
            }

            let j3 = x + y * this.width2;
            let l3 = this.width2 - width;

            if (y < this.boundsTopY) {
                let i4 = this.boundsTopY - y;
                height -= i4;
                y = 0;
                j3 += i4 * this.width2;
                j2 += l2 * i4;
            }

            if (y + height >= this.boundsBottomY) {
                height -= y + height - this.boundsBottomY + 1;
            }

            if (x < this.boundsTopX) {
                let j4 = this.boundsTopX - x;
                width -= j4;
                x = 0;
                j3 += j4;
                i2 += k2 * j4;
                l3 += j4;
            }

            if (x + width >= this.boundsBottomX) {
                let k4 = x + width - this.boundsBottomX + 1;
                width -= k4;
                l3 += k4;
            }

            let yInc = 1;

            if (this.interlace) {
                yInc = 2;
                l3 += this.width2;
                l2 += l2;

                if ((y & 1) !== 0) {
                    j3 += this.width2;
                    height--;
                }
            }

            this._plotScale_from14(
                this.pixels,
                this.surfacePixels[spriteId],
                0,
                i2,
                j2,
                j3,
                l3,
                width,
                height,
                k2,
                l2,
                k1,
                yInc,
                colour
            );
            return;
        } catch (e) {
            console.log('error in sprite clipping routine');
            console.error(e);
        }
    }

    _drawSprite_from10(
        dest,
        src,
        i,
        srcPos,
        destPos,
        width,
        height,
        j1,
        k1,
        yInc
    ) {
        let i2 = -(width >> 2);
        width = -(width & 3);

        for (let j2 = -height; j2 < 0; j2 += yInc) {
            for (let k2 = i2; k2 < 0; k2++) {
                i = src[srcPos++];

                if (i !== 0) {
                    dest[destPos++] = i;
                } else {
                    destPos++;
                }

                i = src[srcPos++];

                if (i !== 0) {
                    dest[destPos++] = i;
                } else {
                    destPos++;
                }

                i = src[srcPos++];

                if (i !== 0) {
                    dest[destPos++] = i;
                } else {
                    destPos++;
                }

                i = src[srcPos++];

                if (i !== 0) {
                    dest[destPos++] = i;
                } else {
                    destPos++;
                }
            }

            for (let l2 = width; l2 < 0; l2++) {
                i = src[srcPos++];

                if (i !== 0) {
                    dest[destPos++] = i;
                } else {
                    destPos++;
                }
            }

            destPos += j1;
            srcPos += k1;
        }
    }

    _drawSprite_from10A(
        target,
        colourIdx,
        colours,
        srcPos,
        destPos,
        width,
        height,
        w2,
        h2,
        rowInc
    ) {
        let l1 = -(width >> 2);
        width = -(width & 3);

        for (let i2 = -height; i2 < 0; i2 += rowInc) {
            for (let j2 = l1; j2 < 0; j2++) {
                let byte0 = colourIdx[srcPos++];

                if (byte0 !== 0) {
                    target[destPos++] = colours[byte0 & 0xff];
                } else {
                    destPos++;
                }

                byte0 = colourIdx[srcPos++];

                if (byte0 !== 0) {
                    target[destPos++] = colours[byte0 & 0xff];
                } else {
                    destPos++;
                }

                byte0 = colourIdx[srcPos++];

                if (byte0 !== 0) {
                    target[destPos++] = colours[byte0 & 0xff];
                } else {
                    destPos++;
                }

                byte0 = colourIdx[srcPos++];

                if (byte0 !== 0) {
                    target[destPos++] = colours[byte0 & 0xff];
                } else {
                    destPos++;
                }
            }

            for (let k2 = width; k2 < 0; k2++) {
                let byte1 = colourIdx[srcPos++];

                if (byte1 !== 0) {
                    target[destPos++] = colours[byte1 & 0xff];
                } else {
                    destPos++;
                }
            }

            destPos += w2;
            srcPos += h2;
        }
    }

    _plotScale_from13(dest, src, i, j, k, destPos, i1, j1, k1, l1, i2, j2, k2) {
        try {
            let l2 = j;

            for (let i3 = -k1; i3 < 0; i3 += k2) {
                let j3 = (k >> 16) * j2;

                for (let k3 = -j1; k3 < 0; k3++) {
                    i = src[(j >> 16) + j3];

                    if (i !== 0) {
                        dest[destPos++] = i;
                    } else {
                        destPos++;
                    }

                    j += l1;
                }

                k += i2;
                j = l2;
                destPos += i1;
            }

            return;
        } catch (e) {
            console.log('error in plotScale');
        }
    }

    _drawSpriteAlpha_from11(
        dest,
        src,
        i,
        srcPos,
        size,
        width,
        height,
        extraXSpace,
        k1,
        yInc,
        alpha
    ) {
        let j2 = 256 - alpha;

        for (let k2 = -height; k2 < 0; k2 += yInc) {
            for (let l2 = -width; l2 < 0; l2++) {
                i = src[srcPos++];

                if (i !== 0) {
                    let i3 = dest[size];
                    dest[size++] =
                        ((((i & 0xff00ff) * alpha + (i3 & 0xff00ff) * j2) &
                            -16711936) +
                            (((i & 0xff00) * alpha + (i3 & 0xff00) * j2) &
                                0xff0000)) >>
                        8;
                } else {
                    size++;
                }
            }

            size += extraXSpace;
            srcPos += k1;
        }
    }

    _drawSpriteAlpha_from11A(
        dest,
        coloursUsed,
        colourList,
        listPos,
        size,
        width,
        height,
        extraXSpace,
        j1,
        yInc,
        alpha
    ) {
        let i2 = 256 - alpha;

        for (let j2 = -height; j2 < 0; j2 += yInc) {
            for (let k2 = -width; k2 < 0; k2++) {
                let l2 = coloursUsed[listPos++];

                if (l2 !== 0) {
                    l2 = colourList[l2 & 0xff];
                    let i3 = dest[size];
                    dest[size++] =
                        ((((l2 & 0xff00ff) * alpha + (i3 & 0xff00ff) * i2) &
                            -16711936) +
                            (((l2 & 0xff00) * alpha + (i3 & 0xff00) * i2) &
                                0xff0000)) >>
                        8;
                } else {
                    size++;
                }
            }

            size += extraXSpace;
            listPos += j1;
        }
    }

    transparentScale(
        dest,
        src,
        i,
        j,
        k,
        destPos,
        i1,
        j1,
        k1,
        l1,
        i2,
        j2,
        yInc,
        alpha
    ) {
        let i3 = 256 - alpha;

        try {
            let j3 = j;

            for (let k3 = -k1; k3 < 0; k3 += yInc) {
                let l3 = (k >> 16) * j2;

                for (let i4 = -j1; i4 < 0; i4++) {
                    i = src[(j >> 16) + l3];

                    if (i !== 0) {
                        let j4 = dest[destPos];
                        dest[destPos++] =
                            ((((i & 0xff00ff) * alpha + (j4 & 0xff00ff) * i3) &
                                -16711936) +
                                (((i & 0xff00) * alpha + (j4 & 0xff00) * i3) &
                                    0xff0000)) >>
                            8;
                    } else {
                        destPos++;
                    }

                    j += l1;
                }

                k += i2;
                j = j3;
                destPos += i1;
            }

            return;
        } catch (e) {
            console.log('error in tranScale');
        }
    }

    _plotScale_from14(
        target,
        pixels,
        i,
        j,
        k,
        l,
        i1,
        width,
        height,
        l1,
        i2,
        j2,
        yInc,
        colour
    ) {
        let i3 = (colour >> 16) & 0xff;
        let j3 = (colour >> 8) & 0xff;
        let k3 = colour & 0xff;

        try {
            let l3 = j;

            for (let i4 = -height; i4 < 0; i4 += yInc) {
                let j4 = (k >> 16) * j2;
                for (let k4 = -width; k4 < 0; k4++) {
                    i = pixels[(j >> 16) + j4];

                    if (i !== 0) {
                        let l4 = (i >> 16) & 0xff;
                        let i5 = (i >> 8) & 0xff;
                        let j5 = i & 0xff;

                        if (l4 === i5 && i5 === j5) {
                            target[l++] =
                                (((l4 * i3) >> 8) << 16) +
                                (((i5 * j3) >> 8) << 8) +
                                ((j5 * k3) >> 8);
                        } else {
                            target[l++] = i;
                        }
                    } else {
                        l++;
                    }

                    j += l1;
                }

                k += i2;
                j = l3;
                l += i1;
            }

            return;
        } catch (e) {
            console.log('error in plotScale');
        }
    }

    // "scale" is not actually scaling when it comes to the landscape
    drawMinimapSprite(x, y, sprite, rotation, scale) {
        let j1 = this.width2;
        let k1 = this.height2;

        if (this.landscapeColours === null) {
            this.landscapeColours = new Int32Array(512);

            for (let l1 = 0; l1 < 256; l1++) {
                this.landscapeColours[l1] =
                    (Math.sin(l1 * 0.02454369) * 32768) | 0;
                this.landscapeColours[l1 + 256] =
                    (Math.cos(l1 * 0.02454369) * 32768) | 0;
            }
        }

        let i2 = -((this.spriteWidthFull[sprite] / 2) | 0);
        let j2 = -((this.spriteHeightFull[sprite] / 2) | 0);

        if (this.spriteTranslate[sprite]) {
            i2 += this.spriteTranslateX[sprite];
            j2 += this.spriteTranslateY[sprite];
        }

        let k2 = i2 + this.spriteWidth[sprite];
        let l2 = j2 + this.spriteHeight[sprite];
        let i3 = k2;
        let j3 = j2;
        let k3 = i2;
        let l3 = l2;
        rotation &= 0xff;
        let i4 = this.landscapeColours[rotation] * scale;
        let j4 = this.landscapeColours[rotation + 256] * scale;
        let k4 = x + ((j2 * i4 + i2 * j4) >> 22);
        let l4 = y + ((j2 * j4 - i2 * i4) >> 22);
        let i5 = x + ((j3 * i4 + i3 * j4) >> 22);
        let j5 = y + ((j3 * j4 - i3 * i4) >> 22);
        let k5 = x + ((l2 * i4 + k2 * j4) >> 22);
        let l5 = y + ((l2 * j4 - k2 * i4) >> 22);
        let i6 = x + ((l3 * i4 + k3 * j4) >> 22);
        let j6 = y + ((l3 * j4 - k3 * i4) >> 22);

        if (scale === 192 && (rotation & 0x3f) === (Surface.anInt348 & 0x3f)) {
            Surface.anInt346++;
        } else if (scale === 128) {
            Surface.anInt348 = rotation;
        } else {
            Surface.anInt347++;
        }

        let k6 = l4;
        let l6 = l4;

        if (j5 < k6) {
            k6 = j5;
        } else if (j5 > l6) {
            l6 = j5;
        }

        if (l5 < k6) {
            k6 = l5;
        } else if (l5 > l6) {
            l6 = l5;
        }

        if (j6 < k6) {
            k6 = j6;
        } else if (j6 > l6) {
            l6 = j6;
        }

        if (k6 < this.boundsTopY) {
            k6 = this.boundsTopY;
        }

        if (l6 > this.boundsBottomY) {
            l6 = this.boundsBottomY;
        }

        if (
            this.anIntArray340 === null ||
            this.anIntArray340.length !== k1 + 1
        ) {
            this.anIntArray340 = new Int32Array(k1 + 1);
            this.anIntArray341 = new Int32Array(k1 + 1);
            this.anIntArray342 = new Int32Array(k1 + 1);
            this.anIntArray343 = new Int32Array(k1 + 1);
            this.anIntArray344 = new Int32Array(k1 + 1);
            this.anIntArray345 = new Int32Array(k1 + 1);
        }

        for (let i7 = k6; i7 <= l6; i7++) {
            this.anIntArray340[i7] = 99999999;
            this.anIntArray341[i7] = -99999999;
        }

        let i8 = 0;
        let k8 = 0;
        let i9 = 0;
        let j9 = this.spriteWidth[sprite];
        let k9 = this.spriteHeight[sprite];

        i2 = 0;
        j2 = 0;
        i3 = j9 - 1;
        j3 = 0;
        k2 = j9 - 1;
        l2 = k9 - 1;
        k3 = 0;
        l3 = k9 - 1;

        if (j6 !== l4) {
            i8 = (((i6 - k4) << 8) / (j6 - l4)) | 0;
            i9 = (((l3 - j2) << 8) / (j6 - l4)) | 0;
        }

        let j7 = 0;
        let k7 = 0;
        let l7 = 0;
        let l8 = 0;

        if (l4 > j6) {
            l7 = i6 << 8;
            l8 = l3 << 8;
            j7 = j6;
            k7 = l4;
        } else {
            l7 = k4 << 8;
            l8 = j2 << 8;
            j7 = l4;
            k7 = j6;
        }

        if (j7 < 0) {
            l7 -= i8 * j7;
            l8 -= i9 * j7;
            j7 = 0;
        }

        if (k7 > k1 - 1) {
            k7 = k1 - 1;
        }

        for (let l9 = j7; l9 <= k7; l9++) {
            this.anIntArray340[l9] = this.anIntArray341[l9] = l7;
            l7 += i8;
            this.anIntArray342[l9] = this.anIntArray343[l9] = 0;
            this.anIntArray344[l9] = this.anIntArray345[l9] = l8;
            l8 += i9;
        }

        if (j5 !== l4) {
            i8 = (((i5 - k4) << 8) / (j5 - l4)) | 0;
            k8 = (((i3 - i2) << 8) / (j5 - l4)) | 0;
        }

        let j8 = 0;

        if (l4 > j5) {
            l7 = i5 << 8;
            j8 = i3 << 8;
            j7 = j5;
            k7 = l4;
        } else {
            l7 = k4 << 8;
            j8 = i2 << 8;
            j7 = l4;
            k7 = j5;
        }

        if (j7 < 0) {
            l7 -= i8 * j7;
            j8 -= k8 * j7;
            j7 = 0;
        }

        if (k7 > k1 - 1) {
            k7 = k1 - 1;
        }

        for (let i10 = j7; i10 <= k7; i10++) {
            if (l7 < this.anIntArray340[i10]) {
                this.anIntArray340[i10] = l7;
                this.anIntArray342[i10] = j8;
                this.anIntArray344[i10] = 0;
            }

            if (l7 > this.anIntArray341[i10]) {
                this.anIntArray341[i10] = l7;
                this.anIntArray343[i10] = j8;
                this.anIntArray345[i10] = 0;
            }

            l7 += i8;
            j8 += k8;
        }

        if (l5 !== j5) {
            i8 = (((k5 - i5) << 8) / (l5 - j5)) | 0;
            i9 = (((l2 - j3) << 8) / (l5 - j5)) | 0;
        }

        if (j5 > l5) {
            l7 = k5 << 8;
            j8 = k2 << 8;
            l8 = l2 << 8;
            j7 = l5;
            k7 = j5;
        } else {
            l7 = i5 << 8;
            j8 = i3 << 8;
            l8 = j3 << 8;
            j7 = j5;
            k7 = l5;
        }

        if (j7 < 0) {
            l7 -= i8 * j7;
            l8 -= i9 * j7;
            j7 = 0;
        }

        if (k7 > k1 - 1) {
            k7 = k1 - 1;
        }

        for (let j10 = j7; j10 <= k7; j10++) {
            if (l7 < this.anIntArray340[j10]) {
                this.anIntArray340[j10] = l7;
                this.anIntArray342[j10] = j8;
                this.anIntArray344[j10] = l8;
            }

            if (l7 > this.anIntArray341[j10]) {
                this.anIntArray341[j10] = l7;
                this.anIntArray343[j10] = j8;
                this.anIntArray345[j10] = l8;
            }

            l7 += i8;
            l8 += i9;
        }

        if (j6 !== l5) {
            i8 = (((i6 - k5) << 8) / (j6 - l5)) | 0;
            k8 = (((k3 - k2) << 8) / (j6 - l5)) | 0;
        }

        if (l5 > j6) {
            l7 = i6 << 8;
            j8 = k3 << 8;
            l8 = l3 << 8;
            j7 = j6;
            k7 = l5;
        } else {
            l7 = k5 << 8;
            j8 = k2 << 8;
            l8 = l2 << 8;
            j7 = l5;
            k7 = j6;
        }

        if (j7 < 0) {
            l7 -= i8 * j7;
            j8 -= k8 * j7;
            j7 = 0;
        }

        if (k7 > k1 - 1) {
            k7 = k1 - 1;
        }

        for (let k10 = j7; k10 <= k7; k10++) {
            if (l7 < this.anIntArray340[k10]) {
                this.anIntArray340[k10] = l7;
                this.anIntArray342[k10] = j8;
                this.anIntArray344[k10] = l8;
            }

            if (l7 > this.anIntArray341[k10]) {
                this.anIntArray341[k10] = l7;
                this.anIntArray343[k10] = j8;
                this.anIntArray345[k10] = l8;
            }

            l7 += i8;
            j8 += k8;
        }

        let l10 = k6 * j1;
        let ai = this.surfacePixels[sprite];

        for (let i11 = k6; i11 < l6; i11++) {
            let j11 = this.anIntArray340[i11] >> 8;
            let k11 = this.anIntArray341[i11] >> 8;

            if (k11 - j11 <= 0) {
                l10 += j1;
            } else {
                let l11 = this.anIntArray342[i11] << 9;
                let i12 =
                    (((this.anIntArray343[i11] << 9) - l11) / (k11 - j11)) | 0;
                let j12 = this.anIntArray344[i11] << 9;
                let k12 =
                    (((this.anIntArray345[i11] << 9) - j12) / (k11 - j11)) | 0;

                if (j11 < this.boundsTopX) {
                    l11 += (this.boundsTopX - j11) * i12;
                    j12 += (this.boundsTopX - j11) * k12;
                    j11 = this.boundsTopX;
                }

                if (k11 > this.boundsBottomX) {
                    k11 = this.boundsBottomX;
                }

                if (!this.interlace || (i11 & 1) === 0) {
                    if (!this.spriteTranslate[sprite]) {
                        this.drawMinimap(
                            this.pixels,
                            ai,
                            0,
                            l10 + j11,
                            l11,
                            j12,
                            i12,
                            k12,
                            j11 - k11,
                            j9
                        );
                    } else {
                        this.drawMinimapTranslate(
                            this.pixels,
                            ai,
                            0,
                            l10 + j11,
                            l11,
                            j12,
                            i12,
                            k12,
                            j11 - k11,
                            j9
                        );
                    }
                }

                l10 += j1;
            }
        }
    }

    drawMinimap(ai, ai1, i, j, k, l, i1, j1, k1, l1) {
        for (i = k1; i < 0; i++) {
            this.pixels[j++] = ai1[(k >> 17) + (l >> 17) * l1];
            k += i1;
            l += j1;
        }
    }

    drawMinimapTranslate(ai, ai1, i, j, k, l, i1, j1, k1, l1) {
        for (let i2 = k1; i2 < 0; i2++) {
            i = ai1[(k >> 17) + (l >> 17) * l1];

            if (i !== 0) {
                this.pixels[j++] = i;
            } else {
                j++;
            }

            k += i1;
            l += j1;
        }
    }

    _spriteClipping_from9(x, y, w, h, sprite, colour1, colour2, l1, flag) {
        try {
            if (colour1 === 0) {
                colour1 = 0xffffff;
            }

            if (colour2 === 0) {
                colour2 = 0xffffff;
            }

            let width = this.spriteWidth[sprite];
            let height = this.spriteHeight[sprite];
            let k2 = 0;
            let l2 = 0;
            let i3 = l1 << 16;
            let j3 = ((width << 16) / w) | 0;
            let k3 = ((height << 16) / h) | 0;
            let l3 = -(((l1 << 16) / h) | 0);

            if (this.spriteTranslate[sprite]) {
                let fullWidth = this.spriteWidthFull[sprite];
                let fullHeight = this.spriteHeightFull[sprite];
                j3 = ((fullWidth << 16) / w) | 0;
                k3 = ((fullHeight << 16) / h) | 0;
                let j5 = this.spriteTranslateX[sprite];
                let k5 = this.spriteTranslateY[sprite];

                if (flag) {
                    j5 = fullWidth - this.spriteWidth[sprite] - j5;
                }

                x += ((j5 * w + fullWidth - 1) / fullWidth) | 0;
                let l5 = ((k5 * h + fullHeight - 1) / fullHeight) | 0;
                y += l5;
                i3 += l5 * l3;

                if ((j5 * w) % fullWidth !== 0) {
                    k2 = (((fullWidth - ((j5 * w) % fullWidth)) << 16) / w) | 0;
                }

                if ((k5 * h) % fullHeight !== 0) {
                    l2 =
                        (((fullHeight - ((k5 * h) % fullHeight)) << 16) / h) |
                        0;
                }

                w = (((this.spriteWidth[sprite] << 16) - k2 + j3 - 1) / j3) | 0;
                h =
                    (((this.spriteHeight[sprite] << 16) - l2 + k3 - 1) / k3) |
                    0;
            }

            let j4 = y * this.width2;
            i3 += x << 16;

            if (y < this.boundsTopY) {
                let l4 = this.boundsTopY - y;
                h -= l4;
                y = this.boundsTopY;
                j4 += l4 * this.width2;
                l2 += k3 * l4;
                i3 += l3 * l4;
            }

            if (y + h >= this.boundsBottomY) {
                h -= y + h - this.boundsBottomY + 1;
            }

            let i5 = (j4 / this.width2) & 1;

            if (!this.interlace) {
                i5 = 2;
            }

            if (colour2 === 0xffffff) {
                if (this.surfacePixels[sprite] !== null) {
                    if (!flag) {
                        this._transparentSpritePlot_from15(
                            this.pixels,
                            this.surfacePixels[sprite],
                            0,
                            k2,
                            l2,
                            j4,
                            w,
                            h,
                            j3,
                            k3,
                            width,
                            colour1,
                            i3,
                            l3,
                            i5
                        );
                        return;
                    } else {
                        this._transparentSpritePlot_from15(
                            this.pixels,
                            this.surfacePixels[sprite],
                            0,
                            (this.spriteWidth[sprite] << 16) - k2 - 1,
                            l2,
                            j4,
                            w,
                            h,
                            -j3,
                            k3,
                            width,
                            colour1,
                            i3,
                            l3,
                            i5
                        );
                        return;
                    }
                }

                if (!flag) {
                    this._transparentSpritePlot_from16A(
                        this.pixels,
                        this.spriteColoursUsed[sprite],
                        this.spriteColourList[sprite],
                        0,
                        k2,
                        l2,
                        j4,
                        w,
                        h,
                        j3,
                        k3,
                        width,
                        colour1,
                        i3,
                        l3,
                        i5
                    );
                    return;
                } else {
                    this._transparentSpritePlot_from16A(
                        this.pixels,
                        this.spriteColoursUsed[sprite],
                        this.spriteColourList[sprite],
                        0,
                        (this.spriteWidth[sprite] << 16) - k2 - 1,
                        l2,
                        j4,
                        w,
                        h,
                        -j3,
                        k3,
                        width,
                        colour1,
                        i3,
                        l3,
                        i5
                    );
                    return;
                }
            }

            if (this.surfacePixels[sprite] !== null) {
                if (!flag) {
                    this._transparentSpritePlot_from16(
                        this.pixels,
                        this.surfacePixels[sprite],
                        0,
                        k2,
                        l2,
                        j4,
                        w,
                        h,
                        j3,
                        k3,
                        width,
                        colour1,
                        colour2,
                        i3,
                        l3,
                        i5
                    );
                    return;
                } else {
                    this._transparentSpritePlot_from16(
                        this.pixels,
                        this.surfacePixels[sprite],
                        0,
                        (this.spriteWidth[sprite] << 16) - k2 - 1,
                        l2,
                        j4,
                        w,
                        h,
                        -j3,
                        k3,
                        width,
                        colour1,
                        colour2,
                        i3,
                        l3,
                        i5
                    );
                    return;
                }
            }

            if (!flag) {
                this._transparentSpritePlot_from17(
                    this.pixels,
                    this.spriteColoursUsed[sprite],
                    this.spriteColourList[sprite],
                    0,
                    k2,
                    l2,
                    j4,
                    w,
                    h,
                    j3,
                    k3,
                    width,
                    colour1,
                    colour2,
                    i3,
                    l3,
                    i5
                );
                return;
            } else {
                this._transparentSpritePlot_from17(
                    this.pixels,
                    this.spriteColoursUsed[sprite],
                    this.spriteColourList[sprite],
                    0,
                    (this.spriteWidth[sprite] << 16) - k2 - 1,
                    l2,
                    j4,
                    w,
                    h,
                    -j3,
                    k3,
                    width,
                    colour1,
                    colour2,
                    i3,
                    l3,
                    i5
                );
                return;
            }
        } catch (e) {
            console.log('error in sprite clipping routine');
            console.error(e);
        }
    }

    _transparentSpritePlot_from15(
        dest,
        src,
        i,
        j,
        k,
        destPos,
        i1,
        j1,
        k1,
        l1,
        i2,
        j2,
        k2,
        l2,
        i3
    ) {
        let i4 = (j2 >> 16) & 0xff;
        let j4 = (j2 >> 8) & 0xff;
        let k4 = j2 & 0xff;

        try {
            let l4 = j;

            for (let i5 = -j1; i5 < 0; i5++) {
                let j5 = (k >> 16) * i2;
                let k5 = k2 >> 16;
                let l5 = i1;

                if (k5 < this.boundsTopX) {
                    let i6 = this.boundsTopX - k5;

                    l5 -= i6;
                    k5 = this.boundsTopX;
                    j += k1 * i6;
                }

                if (k5 + l5 >= this.boundsBottomX) {
                    let j6 = k5 + l5 - this.boundsBottomX;

                    l5 -= j6;
                }

                i3 = 1 - i3;

                if (i3 !== 0) {
                    for (let k6 = k5; k6 < k5 + l5; k6++) {
                        i = src[(j >> 16) + j5];

                        if (i !== 0) {
                            let j3 = (i >> 16) & 0xff;
                            let k3 = (i >> 8) & 0xff;
                            let l3 = i & 0xff;

                            if (j3 === k3 && k3 === l3) {
                                dest[k6 + destPos] =
                                    (((j3 * i4) >> 8) << 16) +
                                    (((k3 * j4) >> 8) << 8) +
                                    ((l3 * k4) >> 8);
                            } else {
                                dest[k6 + destPos] = i;
                            }
                        }

                        j += k1;
                    }
                }

                k += l1;
                j = l4;
                destPos += this.width2;
                k2 += l2;
            }

            return;
        } catch (e) {
            console.error('error in transparent sprite plot routine');
        }
    }

    _transparentSpritePlot_from16(
        dest,
        src,
        i,
        j,
        k,
        destPos,
        i1,
        j1,
        k1,
        l1,
        i2,
        j2,
        k2,
        l2,
        i3,
        j3
    ) {
        let j4 = (j2 >> 16) & 0xff;
        let k4 = (j2 >> 8) & 0xff;
        let l4 = j2 & 0xff;
        let i5 = (k2 >> 16) & 0xff;
        let j5 = (k2 >> 8) & 0xff;
        let k5 = k2 & 0xff;

        try {
            let l5 = j;

            for (let i6 = -j1; i6 < 0; i6++) {
                let j6 = (k >> 16) * i2;
                let k6 = l2 >> 16;
                let l6 = i1;

                if (k6 < this.boundsTopX) {
                    let i7 = this.boundsTopX - k6;
                    l6 -= i7;
                    k6 = this.boundsTopX;
                    j += k1 * i7;
                }

                if (k6 + l6 >= this.boundsBottomX) {
                    let j7 = k6 + l6 - this.boundsBottomX;
                    l6 -= j7;
                }

                j3 = 1 - j3;

                if (j3 !== 0) {
                    for (let k7 = k6; k7 < k6 + l6; k7++) {
                        i = src[(j >> 16) + j6];

                        if (i !== 0) {
                            let k3 = (i >> 16) & 0xff;
                            let l3 = (i >> 8) & 0xff;
                            let i4 = i & 0xff;

                            if (k3 === l3 && l3 === i4) {
                                dest[k7 + destPos] =
                                    (((k3 * j4) >> 8) << 16) +
                                    (((l3 * k4) >> 8) << 8) +
                                    ((i4 * l4) >> 8);
                            } else if (k3 === 255 && l3 === i4) {
                                dest[k7 + destPos] =
                                    (((k3 * i5) >> 8) << 16) +
                                    (((l3 * j5) >> 8) << 8) +
                                    ((i4 * k5) >> 8);
                            } else {
                                dest[k7 + destPos] = i;
                            }
                        }

                        j += k1;
                    }
                }

                k += l1;
                j = l5;
                destPos += this.width2;
                l2 += i3;
            }

            return;
        } catch (e) {
            console.log('error in transparent sprite plot routine');
        }
    }

    _transparentSpritePlot_from16A(
        dest,
        colourIdx,
        colours,
        i,
        j,
        k,
        l,
        i1,
        j1,
        k1,
        l1,
        i2,
        j2,
        k2,
        l2,
        i3
    ) {
        let i4 = (j2 >> 16) & 0xff;
        let j4 = (j2 >> 8) & 0xff;
        let k4 = j2 & 0xff;

        try {
            let l4 = j;

            for (let i5 = -j1; i5 < 0; i5++) {
                let j5 = (k >> 16) * i2;
                let k5 = k2 >> 16;
                let l5 = i1;

                if (k5 < this.boundsTopX) {
                    let i6 = this.boundsTopX - k5;
                    l5 -= i6;
                    k5 = this.boundsTopX;
                    j += k1 * i6;
                }

                if (k5 + l5 >= this.boundsBottomX) {
                    let j6 = k5 + l5 - this.boundsBottomX;
                    l5 -= j6;
                }

                i3 = 1 - i3;

                if (i3 !== 0) {
                    for (let k6 = k5; k6 < k5 + l5; k6++) {
                        i = colourIdx[(j >> 16) + j5] & 0xff;

                        if (i !== 0) {
                            i = colours[i];

                            let j3 = (i >> 16) & 0xff;
                            let k3 = (i >> 8) & 0xff;
                            let l3 = i & 0xff;

                            if (j3 === k3 && k3 === l3) {
                                dest[k6 + l] =
                                    (((j3 * i4) >> 8) << 16) +
                                    (((k3 * j4) >> 8) << 8) +
                                    ((l3 * k4) >> 8);
                            } else {
                                dest[k6 + l] = i;
                            }
                        }

                        j += k1;
                    }
                }

                k += l1;
                j = l4;
                l += this.width2;
                k2 += l2;
            }

            return;
        } catch (e) {
            console.log('error in transparent sprite plot routine');
        }
    }

    _transparentSpritePlot_from17(
        dest,
        coloursUsed,
        colourList,
        i,
        j,
        k,
        l,
        i1,
        j1,
        k1,
        l1,
        i2,
        j2,
        k2,
        l2,
        i3,
        j3
    ) {
        let j4 = (j2 >> 16) & 0xff;
        let k4 = (j2 >> 8) & 0xff;
        let l4 = j2 & 0xff;
        let i5 = (k2 >> 16) & 0xff;
        let j5 = (k2 >> 8) & 0xff;
        let k5 = k2 & 0xff;

        try {
            let l5 = j;

            for (let i6 = -j1; i6 < 0; i6++) {
                let j6 = (k >> 16) * i2;
                let k6 = l2 >> 16;
                let l6 = i1;

                if (k6 < this.boundsTopX) {
                    let i7 = this.boundsTopX - k6;
                    l6 -= i7;
                    k6 = this.boundsTopX;
                    j += k1 * i7;
                }

                if (k6 + l6 >= this.boundsBottomX) {
                    let j7 = k6 + l6 - this.boundsBottomX;
                    l6 -= j7;
                }

                j3 = 1 - j3;

                if (j3 !== 0) {
                    for (let k7 = k6; k7 < k6 + l6; k7++) {
                        i = coloursUsed[(j >> 16) + j6] & 0xff;

                        if (i !== 0) {
                            i = colourList[i];
                            let k3 = (i >> 16) & 0xff;
                            let l3 = (i >> 8) & 0xff;
                            let i4 = i & 0xff;

                            if (k3 === l3 && l3 === i4) {
                                dest[k7 + l] =
                                    (((k3 * j4) >> 8) << 16) +
                                    (((l3 * k4) >> 8) << 8) +
                                    ((i4 * l4) >> 8);
                            } else if (k3 === 255 && l3 === i4) {
                                dest[k7 + l] =
                                    (((k3 * i5) >> 8) << 16) +
                                    (((l3 * j5) >> 8) << 8) +
                                    ((i4 * k5) >> 8);
                            } else {
                                dest[k7 + l] = i;
                            }
                        }

                        j += k1;
                    }
                }

                k += l1;
                j = l5;
                l += this.width2;
                l2 += i3;
            }

            return;
        } catch (e) {
            console.log('error in transparent sprite plot routine');
        }
    }

    drawStringRight(text, x, y, font, colour) {
        this.drawString(text, x - this.textWidth(text, font), y, font, colour);
    }

    drawStringCenter(text, x, y, font, colour) {
        this.drawString(
            text,
            x - ((this.textWidth(text, font) / 2) | 0),
            y,
            font,
            colour
        );
    }

    drawParagraph(text, x, y, font, colour, max) {
        try {
            let width = 0;
            let fontData = Surface.gameFonts[font];
            let start = 0;
            let end = 0;

            for (let index = 0; index < text.length; index++) {
                if (
                    text[index] === '@' &&
                    index + 4 < text.length &&
                    text[index + 4] === '@'
                ) {
                    index += 4;
                } else if (
                    text[index] === '~' &&
                    index + 4 < text.length &&
                    text[index + 4] === '~'
                ) {
                    index += 4;
                } else {
                    width +=
                        fontData[
                            Surface.characterWidth[text.charCodeAt(index)] + 7
                        ];
                }

                if (text[index] === ' ') {
                    end = index;
                }

                if (text[index] === '%') {
                    end = index;
                    width = 1000;
                }

                if (width > max) {
                    if (end <= start) {
                        end = index;
                    }

                    this.drawStringCenter(
                        text.slice(start, end),
                        x,
                        y,
                        font,
                        colour
                    );
                    width = 0;
                    start = index = end + 1;
                    y += this.textHeight(font);
                }
            }

            if (width > 0) {
                this.drawStringCenter(text.slice(start), x, y, font, colour);
                return;
            }
        } catch (e) {
            console.error(e);
        }
    }

    drawString(text, x, y, font, colour) {
        try {
            let fontData = Surface.gameFonts[font];

            for (let i = 0; i < text.length; i++) {
                if (
                    text[i] === '@' &&
                    i + 4 < text.length &&
                    text[i + 4] === '@'
                ) {
                    if (text.slice(i + 1, i + 4).toLowerCase() === 'red') {
                        colour = 0xff0000;
                    } else if (
                        text.slice(i + 1, i + 4).toLowerCase() === 'lre'
                    ) {
                        colour = 0xff9040;
                    } else if (
                        text.slice(i + 1, i + 4).toLowerCase() === 'yel'
                    ) {
                        colour = 0xffff00;
                    } else if (
                        text.slice(i + 1, i + 4).toLowerCase() === 'gre'
                    ) {
                        colour = 65280;
                    } else if (
                        text.slice(i + 1, i + 4).toLowerCase() === 'blu'
                    ) {
                        colour = 255;
                    } else if (
                        text.slice(i + 1, i + 4).toLowerCase() === 'cya'
                    ) {
                        colour = 65535;
                    } else if (
                        text.slice(i + 1, i + 4).toLowerCase() === 'mag'
                    ) {
                        colour = 0xff00ff;
                    } else if (
                        text.slice(i + 1, i + 4).toLowerCase() === 'whi'
                    ) {
                        colour = 0xffffff;
                    } else if (
                        text.slice(i + 1, i + 4).toLowerCase() === 'bla'
                    ) {
                        colour = 0;
                    } else if (
                        text.slice(i + 1, i + 4).toLowerCase() === 'dre'
                    ) {
                        colour = 0xc00000;
                    } else if (
                        text.slice(i + 1, i + 4).toLowerCase() === 'ora'
                    ) {
                        colour = 0xff9040;
                    } else if (
                        text.slice(i + 1, i + 4).toLowerCase() === 'ran'
                    ) {
                        colour = (Math.random() * 16777215) | 0;
                    } else if (
                        text.slice(i + 1, i + 4).toLowerCase() === 'or1'
                    ) {
                        colour = 0xffb000;
                    } else if (
                        text.slice(i + 1, i + 4).toLowerCase() === 'or2'
                    ) {
                        colour = 0xff7000;
                    } else if (
                        text.slice(i + 1, i + 4).toLowerCase() === 'or3'
                    ) {
                        colour = 0xff3000;
                    } else if (
                        text.slice(i + 1, i + 4).toLowerCase() === 'gr1'
                    ) {
                        colour = 0xc0ff00;
                    } else if (
                        text.slice(i + 1, i + 4).toLowerCase() === 'gr2'
                    ) {
                        colour = 0x80ff00;
                    } else if (
                        text.slice(i + 1, i + 4).toLowerCase() === 'gr3'
                    ) {
                        colour = 0x40ff00;
                    }

                    i += 4;
                } else if (
                    text[i] === '~' &&
                    i + 4 < text.length &&
                    text[i + 4] === '~'
                ) {
                    let c = text.charCodeAt(i + 1);
                    let c1 = text.charCodeAt(i + 2);
                    let c2 = text.charCodeAt(i + 3);

                    if (
                        c >= C_0 &&
                        c <= C_9 &&
                        c1 >= C_0 &&
                        c1 <= C_9 &&
                        c2 >= C_0 &&
                        c2 <= C_9
                    ) {
                        x = Number(text.substring(i + 1, i + 4)) | 0;
                    }

                    i += 4;
                } else {
                    let width = Surface.characterWidth[text.charCodeAt(i)];

                    if (this.loggedIn && colour !== 0) {
                        this.drawCharacter(width, x + 1, y, 0, fontData);
                        this.drawCharacter(width, x, y + 1, 0, fontData);
                    }

                    this.drawCharacter(width, x, y, colour, fontData);
                    x += fontData[width + 7];
                }
            }
        } catch (e) {
            console.error(e);
            return;
        }
    }

    drawCharacter(width, x, y, colour, font) {
        let i1 = x + font[width + 5];
        let j1 = y - font[width + 6];
        let k1 = font[width + 3];
        let l1 = font[width + 4];
        let i2 = font[width] * 16384 + font[width + 1] * 128 + font[width + 2];
        let j2 = i1 + j1 * this.width2;
        let k2 = this.width2 - k1;
        let l2 = 0;

        if (j1 < this.boundsTopY) {
            let i3 = this.boundsTopY - j1;
            l1 -= i3;
            j1 = this.boundsTopY;
            i2 += i3 * k1;
            j2 += i3 * this.width2;
        }

        if (j1 + l1 >= this.boundsBottomY) {
            l1 -= j1 + l1 - this.boundsBottomY + 1;
        }

        if (i1 < this.boundsTopX) {
            let j3 = this.boundsTopX - i1;
            k1 -= j3;
            i1 = this.boundsTopX;
            i2 += j3;
            j2 += j3;
            l2 += j3;
            k2 += j3;
        }

        if (i1 + k1 >= this.boundsBottomX) {
            let k3 = i1 + k1 - this.boundsBottomX + 1;
            k1 -= k3;
            l2 += k3;
            k2 += k3;
        }

        if (k1 > 0 && l1 > 0) {
            this.plotLetter(this.pixels, font, colour, i2, j2, k1, l1, k2, l2);
        }
    }

    plotLetter(ai, abyte0, i, j, k, l, i1, j1, k1) {
        try {
            let l1 = -(l >> 2);

            l = -(l & 3);

            for (let i2 = -i1; i2 < 0; i2++) {
                for (let j2 = l1; j2 < 0; j2++) {
                    if (abyte0[j++] !== 0) {
                        ai[k++] = i;
                    } else {
                        k++;
                    }

                    if (abyte0[j++] !== 0) {
                        ai[k++] = i;
                    } else {
                        k++;
                    }

                    if (abyte0[j++] !== 0) {
                        ai[k++] = i;
                    } else {
                        k++;
                    }

                    if (abyte0[j++] !== 0) {
                        ai[k++] = i;
                    } else {
                        k++;
                    }
                }

                for (let k2 = l; k2 < 0; k2++) {
                    if (abyte0[j++] !== 0) {
                        ai[k++] = i;
                    } else {
                        k++;
                    }
                }

                k += j1;
                j += k1;
            }
        } catch (e) {
            console.error(e);
        }
    }

    // todo
    method259(ai, abyte0, i, j, k, l, i1, j1, k1) {
        for (let l1 = -i1; l1 < 0; l1++) {
            for (let i2 = -l; i2 < 0; i2++) {
                let j2 = abyte0[j++] & 0xff;

                if (j2 > 30) {
                    if (j2 >= 230) {
                        ai[k++] = i;
                    } else {
                        let k2 = ai[k];
                        ai[k++] =
                            ((((i & 0xff00ff) * j2 +
                                (k2 & 0xff00ff) * (256 - j2)) &
                                0xff00ff00) +
                                (((i & 0xff00) * j2 +
                                    (k2 & 0xff00) * (256 - j2)) &
                                    0xff0000)) >>
                            8;
                    }
                } else {
                    k++;
                }
            }

            k += j1;
            j += k1;
        }
    }

    textHeight(fontId) {
        if (fontId === 0) {
            return 12;
        }

        if (fontId === 1) {
            return 14;
        }

        if (fontId === 2) {
            return 14;
        }

        if (fontId === 3) {
            return 15;
        }

        if (fontId === 4) {
            return 15;
        }

        if (fontId === 5) {
            return 19;
        }

        if (fontId === 6) {
            return 24;
        }

        if (fontId === 7) {
            return 29;
        } else {
            return this.textHeightFont(fontId);
        }
    }

    textHeightFont(fontId) {
        if (fontId === 0) {
            return Surface.gameFonts[fontId][8] - 2;
        } else {
            return Surface.gameFonts[fontId][8] - 1;
        }
    }

    textWidth(text, fontId) {
        let total = 0;
        let font = Surface.gameFonts[fontId];

        for (let idx = 0; idx < text.length; idx++) {
            if (
                text[idx] === '@' &&
                idx + 4 < text.length &&
                text[idx + 4] === '@'
            ) {
                idx += 4;
            } else if (
                text[idx] === '~' &&
                idx + 4 < text.length &&
                text[idx + 4] === '~'
            ) {
                idx += 4;
            } else {
                total += font[Surface.characterWidth[text.charCodeAt(idx)] + 7];
            }
        }

        return total;
    }

    drawTabs(x, y, width, height, tabs, selected) {
        const tabWidth = (width / tabs.length) | 0;
        let xOffset = 0;

        for (let i = 0; i < tabs.length; i += 1) {
            const tabColour = selected === i ? LIGHT_GREY : DARK_GREY;

            this.drawBoxAlpha(x + xOffset, y, tabWidth, height, tabColour, 128);
            this.drawStringCenter(
                tabs[i],
                x + xOffset + ((tabWidth / 2) | 0),
                y + 16,
                4,
                BLACK
            );

            if (i > 0) {
                this.drawLineVert(x + xOffset, y, height, BLACK);
            }

            xOffset += tabWidth;
        }

        this.drawLineHoriz(x, y + height, width, BLACK);
    }
}

Surface.anInt346 = 0;
Surface.anInt347 = 0;
Surface.anInt348 = 0;

Surface.gameFonts = [];
Surface.gameFonts.length = 50;
Surface.gameFonts.fill(null);

Surface.characterWidth = new Int32Array(256);

let s =
    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!"\243$%^&*()-_=+[{]};:\'@#~,<.>/?\\| ';

for (let i = 0; i < 256; i++) {
    let j = s.indexOf(String.fromCharCode(i));

    if (j === -1) {
        j = 74;
    }

    Surface.characterWidth[i] = j * 9;
}

module.exports = Surface;

},{"./utility":100}],75:[function(require,module,exports){
module.exports = {
    black : 0,
    white: 0xffffff,
    grey: 0x989898,
    darkGrey : 0xb5b5b5,
    lightGrey: 0xdcdcdc,
    lightGrey2: 0xd0d0d0,
    red : 0xff0000,
    yellow : 0xffff00,
    cyan: 0x00ffff,
    green: 0x00ff00,
    orange: 0xff8000
};

},{}],76:[function(require,module,exports){
const GameData = require('../game-data');
const Panel = require('../panel');
const clientOpcodes = require('../opcodes/client');

// size of the -> sprite
const ARROW_SIZE = 20;

// box around the type text
const BOX_WIDTH = 53;
const BOX_HEIGHT = 41;

// the width of each option column including the arrows
const COLUMN_WIDTH = 54;

// size of the accept button
const ACCEPT_WIDTH = 200;
const ACCEPT_HEIGHT = 30;

// draw a box with two arrows
function drawOptionBox(panel, type, x, y) {
    panel.addBoxRounded(x, y, BOX_WIDTH, BOX_HEIGHT);

    const typeSplit = type.split('\n');

    if (typeSplit.length === 1) {
        panel.addTextCentre(x, y, type, 1, true);
    } else {
        panel.addTextCentre(x, y - 8, typeSplit[0], 1, true);
        panel.addTextCentre(x, y + 8, typeSplit[1], 1, true);
    }

    const leftButton = panel.addButton(x - 40, y, ARROW_SIZE, ARROW_SIZE);
    panel.addSprite(x - 40, y, Panel.baseSpriteStart + 7);

    const rightButton = panel.addButton(x + 40, y, ARROW_SIZE, ARROW_SIZE);
    panel.addSprite(x + 40, y, Panel.baseSpriteStart + 6);

    return { leftButton, rightButton };
}

function createAppearancePanel() {
    this.panelAppearance = new Panel(this.surface, 100);

    const x = 256;

    this.panelAppearance.addTextCentre(
        x,
        10,
        'Please design Your Character',
        4,
        true
    );

    let y = 24;

    this.panelAppearance.addTextCentre(x - 55, y + 110, 'Front', 3, true);
    this.panelAppearance.addTextCentre(x, y + 110, 'Side', 3, true);
    this.panelAppearance.addTextCentre(x + 55, y + 110, 'Back', 3, true);

    y += 145;

    const { leftButton: headLeft, rightButton: headRight } = drawOptionBox(
        this.panelAppearance,
        'Head\nType',
        x - COLUMN_WIDTH,
        y
    );

    this.controlButtonAppearanceHeadLeft = headLeft;
    this.controlButtonAppearanceHeadRight = headRight;

    const { leftButton: hairLeft, rightButton: hairRight } = drawOptionBox(
        this.panelAppearance,
        'Hair\nColor',
        x + COLUMN_WIDTH,
        y
    );

    this.controlButtonAppearanceHairLeft = hairLeft;
    this.controlButtonAppearanceHairRight = hairRight;

    y += 50;

    const { leftButton: genderLeft, rightButton: genderRight } = drawOptionBox(
        this.panelAppearance,
        'Gender',
        x - COLUMN_WIDTH,
        y
    );

    this.controlButtonAppearanceGenderLeft = genderLeft;
    this.controlButtonAppearanceGenderRight = genderRight;

    const { leftButton: topLeft, rightButton: topRight } = drawOptionBox(
        this.panelAppearance,
        'Top\nColor',
        x + COLUMN_WIDTH,
        y
    );

    this.controlButtonAppearanceTopLeft = topLeft;
    this.controlButtonAppearanceTopRight = topRight;

    y += 50;

    const { leftButton: skinLeft, rightButton: skinRight } = drawOptionBox(
        this.panelAppearance,
        'Skin\nColor',
        x - COLUMN_WIDTH,
        y
    );

    this.controlButtonAppearanceSkinLeft = skinLeft;
    this.controlButtonAppearanceSkinRight = skinRight;

    const { leftButton: bottomLeft, rightButton: bottomRight } = drawOptionBox(
        this.panelAppearance,
        'Bottom\nColor',
        x + COLUMN_WIDTH,
        y
    );

    this.controlButtonAppearanceBottomLeft = bottomLeft;
    this.controlButtonAppearanceBottomRight = bottomRight;

    y += 47;

    this.panelAppearance.addButtonBackground(x, y, ACCEPT_WIDTH, ACCEPT_HEIGHT);
    this.panelAppearance.addTextCentre(x, y, 'Accept', 4, false);

    this.controlButtonAppearanceAccept = this.panelAppearance.addButton(
        x,
        y,
        ACCEPT_WIDTH,
        ACCEPT_HEIGHT
    );
}

function handleAppearancePanelInput() {
    this.panelAppearance.handleMouse(
        this.mouseX,
        this.mouseY,
        this.lastMouseButtonDown,
        this.mouseButtonDown
    );

    if (this.panelAppearance.isClicked(this.controlButtonAppearanceHeadLeft)) {
        do {
            this.appearanceHeadType =
                (this.appearanceHeadType - 1 + GameData.animationCount) %
                GameData.animationCount;
        } while (
            (GameData.animationGender[this.appearanceHeadType] & 3) !== 1 ||
            (GameData.animationGender[this.appearanceHeadType] &
                (4 * this.appearanceHeadGender)) ===
                0
        );
    }

    if (this.panelAppearance.isClicked(this.controlButtonAppearanceHeadRight)) {
        do {
            this.appearanceHeadType =
                (this.appearanceHeadType + 1) % GameData.animationCount;
        } while (
            (GameData.animationGender[this.appearanceHeadType] & 3) !== 1 ||
            (GameData.animationGender[this.appearanceHeadType] &
                (4 * this.appearanceHeadGender)) ===
                0
        );
    }

    if (this.panelAppearance.isClicked(this.controlButtonAppearanceHairLeft)) {
        this.appearanceHairColour =
            (this.appearanceHairColour - 1 + this.characterHairColours.length) %
            this.characterHairColours.length;
    }

    if (this.panelAppearance.isClicked(this.controlButtonAppearanceHairRight)) {
        this.appearanceHairColour =
            (this.appearanceHairColour + 1) % this.characterHairColours.length;
    }

    if (
        this.panelAppearance.isClicked(
            this.controlButtonAppearanceGenderLeft
        ) ||
        this.panelAppearance.isClicked(this.controlButtonAppearanceGenderRight)
    ) {
        for (
            this.appearanceHeadGender = 3 - this.appearanceHeadGender;
            (GameData.animationGender[this.appearanceHeadType] & 3) !== 1 ||
            (GameData.animationGender[this.appearanceHeadType] &
                (4 * this.appearanceHeadGender)) ===
                0;
            this.appearanceHeadType =
                (this.appearanceHeadType + 1) % GameData.animationCount
        );

        for (
            ;
            (GameData.animationGender[this.appearanceBodyGender] & 3) !==
                2 ||
            (GameData.animationGender[this.appearanceBodyGender] &
                (4 * this.appearanceHeadGender)) ===
                0;
            this.appearanceBodyGender =
                (this.appearanceBodyGender + 1) % GameData.animationCount
        );
    }

    if (this.panelAppearance.isClicked(this.controlButtonAppearanceTopLeft)) {
        this.appearanceTopColour =
            (this.appearanceTopColour -
                1 +
                this.characterTopBottomColours.length) %
            this.characterTopBottomColours.length;
    }

    if (this.panelAppearance.isClicked(this.controlButtonAppearanceTopRight)) {
        this.appearanceTopColour =
            (this.appearanceTopColour + 1) %
            this.characterTopBottomColours.length;
    }

    if (this.panelAppearance.isClicked(this.controlButtonAppearanceSkinLeft)) {
        this.appearanceSkinColour =
            (this.appearanceSkinColour - 1 + this.characterSkinColours.length) %
            this.characterSkinColours.length;
    }

    if (this.panelAppearance.isClicked(this.controlButtonAppearanceSkinRight)) {
        this.appearanceSkinColour =
            (this.appearanceSkinColour + 1) % this.characterSkinColours.length;
    }

    if (
        this.panelAppearance.isClicked(this.controlButtonAppearanceBottomLeft)
    ) {
        this.appearanceBottomColour =
            (this.appearanceBottomColour -
                1 +
                this.characterTopBottomColours.length) %
            this.characterTopBottomColours.length;
    }

    if (
        this.panelAppearance.isClicked(this.controlButtonAppearanceBottomRight)
    ) {
        this.appearanceBottomColour =
            (this.appearanceBottomColour + 1) %
            this.characterTopBottomColours.length;
    }

    if (this.panelAppearance.isClicked(this.controlButtonAppearanceAccept)) {
        this.packetStream.newPacket(clientOpcodes.APPEARANCE);
        this.packetStream.putByte(this.appearanceHeadGender);
        this.packetStream.putByte(this.appearanceHeadType);
        this.packetStream.putByte(this.appearanceBodyGender);
        this.packetStream.putByte(this.appearance2Colour);
        this.packetStream.putByte(this.appearanceHairColour);
        this.packetStream.putByte(this.appearanceTopColour);
        this.packetStream.putByte(this.appearanceBottomColour);
        this.packetStream.putByte(this.appearanceSkinColour);
        this.packetStream.sendPacket();

        this.surface.blackScreen();
        this.showAppearanceChange = false;
    }
}

module.exports = {
    createAppearancePanel,
    handleAppearancePanelInput
};

},{"../game-data":44,"../opcodes/client":54,"../panel":69}],77:[function(require,module,exports){
const GameData = require('../game-data');
const clientOpcodes = require('../opcodes/client');
const colours = require('./_colours');

const WIDTH = 408;
const HEIGHT = 334;

const ITEMS_PER_PAGE = 48;
const MAGIC_DEPOSIT = 0x87654321;
const MAGIC_WITHDRAW = 0x12345678;

function drawDialogBank() {
    if (this.bankActivePage > 0 && this.bankItemCount <= ITEMS_PER_PAGE) {
        this.bankActivePage = 0;
    }

    if (this.bankActivePage > 1 && this.bankItemCount <= 96) {
        this.bankActivePage = 1;
    }

    if (this.bankActivePage > 2 && this.bankItemCount <= 144) {
        this.bankActivePage = 2;
    }

    if (
        this.bankSelectedItemSlot >= this.bankItemCount ||
        this.bankSelectedItemSlot < 0
    ) {
        this.bankSelectedItemSlot = -1;
    }

    if (
        this.bankSelectedItemSlot !== -1 &&
        this.bankItems[this.bankSelectedItemSlot] !== this.bankSelectedItem
    ) {
        this.bankSelectedItemSlot = -1;
        this.bankSelectedItem = -2;
    }

    if (this.mouseButtonClick !== 0) {
        this.mouseButtonClick = 0;

        let mouseX =
            this.mouseX - (((this.gameWidth / 2) | 0) - ((WIDTH / 2) | 0));

        let mouseY =
            this.mouseY - (((this.gameHeight / 2) | 0) - ((HEIGHT / 2) | 0));

        if (mouseX >= 0 && mouseY >= 12 && mouseX < 408 && mouseY < 280) {
            let slotIndex = this.bankActivePage * ITEMS_PER_PAGE;

            for (let row = 0; row < 6; row++) {
                for (let col = 0; col < 8; col++) {
                    const slotX = 7 + col * 49;
                    const slotY = 28 + row * 34;

                    if (
                        mouseX > slotX &&
                        mouseX < slotX + 49 &&
                        mouseY > slotY &&
                        mouseY < slotY + 34 &&
                        slotIndex < this.bankItemCount &&
                        this.bankItems[slotIndex] !== -1
                    ) {
                        this.bankSelectedItem = this.bankItems[slotIndex];
                        this.bankSelectedItemSlot = slotIndex;
                    }

                    slotIndex++;
                }
            }

            mouseX = 256 - ((WIDTH / 2) | 0);
            mouseY = 170 - ((HEIGHT / 2) | 0);

            let slot = 0;

            if (this.bankSelectedItemSlot < 0) {
                slot = -1;
            } else {
                slot = this.bankItems[this.bankSelectedItemSlot];
            }

            if (slot !== -1) {
                let itemAmount = this.bankItemsCount[this.bankSelectedItemSlot];

                if (GameData.itemStackable[slot] === 1 && itemAmount > 1) {
                    itemAmount = 1;
                }

                if (
                    itemAmount >= 1 &&
                    this.mouseX >= mouseX + 220 &&
                    this.mouseY >= mouseY + 238 &&
                    this.mouseX < mouseX + 250 &&
                    this.mouseY <= mouseY + 249
                ) {
                    this.packetStream.newPacket(clientOpcodes.BANK_WITHDRAW);
                    this.packetStream.putShort(slot);
                    this.packetStream.putShort(1);
                    this.packetStream.putInt(MAGIC_WITHDRAW);
                    this.packetStream.sendPacket();
                }

                if (
                    itemAmount >= 5 &&
                    this.mouseX >= mouseX + 250 &&
                    this.mouseY >= mouseY + 238 &&
                    this.mouseX < mouseX + 280 &&
                    this.mouseY <= mouseY + 249
                ) {
                    this.packetStream.newPacket(clientOpcodes.BANK_WITHDRAW);
                    this.packetStream.putShort(slot);
                    this.packetStream.putShort(5);
                    this.packetStream.putInt(MAGIC_WITHDRAW);
                    this.packetStream.sendPacket();
                }

                if (
                    itemAmount >= 25 &&
                    this.mouseX >= mouseX + 280 &&
                    this.mouseY >= mouseY + 238 &&
                    this.mouseX < mouseX + 305 &&
                    this.mouseY <= mouseY + 249
                ) {
                    this.packetStream.newPacket(clientOpcodes.BANK_WITHDRAW);
                    this.packetStream.putShort(slot);
                    this.packetStream.putShort(25);
                    this.packetStream.putInt(MAGIC_WITHDRAW);
                    this.packetStream.sendPacket();
                }

                if (
                    itemAmount >= 100 &&
                    this.mouseX >= mouseX + 305 &&
                    this.mouseY >= mouseY + 238 &&
                    this.mouseX < mouseX + 335 &&
                    this.mouseY <= mouseY + 249
                ) {
                    this.packetStream.newPacket(clientOpcodes.BANK_WITHDRAW);
                    this.packetStream.putShort(slot);
                    this.packetStream.putShort(100);
                    this.packetStream.putInt(MAGIC_WITHDRAW);
                    this.packetStream.sendPacket();
                }

                if (
                    itemAmount >= 500 &&
                    this.mouseX >= mouseX + 335 &&
                    this.mouseY >= mouseY + 238 &&
                    this.mouseX < mouseX + 368 &&
                    this.mouseY <= mouseY + 249
                ) {
                    this.packetStream.newPacket(clientOpcodes.BANK_WITHDRAW);
                    this.packetStream.putShort(slot);
                    this.packetStream.putShort(500);
                    this.packetStream.putInt(MAGIC_WITHDRAW);
                    this.packetStream.sendPacket();
                }

                if (
                    itemAmount >= 2500 &&
                    this.mouseX >= mouseX + 370 &&
                    this.mouseY >= mouseY + 238 &&
                    this.mouseX < mouseX + 400 &&
                    this.mouseY <= mouseY + 249
                ) {
                    this.packetStream.newPacket(clientOpcodes.BANK_WITHDRAW);
                    this.packetStream.putShort(slot);
                    this.packetStream.putShort(2500);
                    this.packetStream.putInt(MAGIC_WITHDRAW);
                    this.packetStream.sendPacket();
                }

                if (
                    this.getInventoryCount(slot) >= 1 &&
                    this.mouseX >= mouseX + 220 &&
                    this.mouseY >= mouseY + 263 &&
                    this.mouseX < mouseX + 250 &&
                    this.mouseY <= mouseY + 274
                ) {
                    this.packetStream.newPacket(clientOpcodes.BANK_DEPOSIT);
                    this.packetStream.putShort(slot);
                    this.packetStream.putShort(1);
                    this.packetStream.putInt(MAGIC_DEPOSIT);
                    this.packetStream.sendPacket();
                }

                if (
                    this.getInventoryCount(slot) >= 5 &&
                    this.mouseX >= mouseX + 250 &&
                    this.mouseY >= mouseY + 263 &&
                    this.mouseX < mouseX + 280 &&
                    this.mouseY <= mouseY + 274
                ) {
                    this.packetStream.newPacket(clientOpcodes.BANK_DEPOSIT);
                    this.packetStream.putShort(slot);
                    this.packetStream.putShort(5);
                    this.packetStream.putInt(MAGIC_DEPOSIT);
                    this.packetStream.sendPacket();
                }
                if (
                    this.getInventoryCount(slot) >= 25 &&
                    this.mouseX >= mouseX + 280 &&
                    this.mouseY >= mouseY + 263 &&
                    this.mouseX < mouseX + 305 &&
                    this.mouseY <= mouseY + 274
                ) {
                    this.packetStream.newPacket(clientOpcodes.BANK_DEPOSIT);
                    this.packetStream.putShort(slot);
                    this.packetStream.putShort(25);
                    this.packetStream.putInt(MAGIC_DEPOSIT);
                    this.packetStream.sendPacket();
                }

                if (
                    this.getInventoryCount(slot) >= 100 &&
                    this.mouseX >= mouseX + 305 &&
                    this.mouseY >= mouseY + 263 &&
                    this.mouseX < mouseX + 335 &&
                    this.mouseY <= mouseY + 274
                ) {
                    this.packetStream.newPacket(clientOpcodes.BANK_DEPOSIT);
                    this.packetStream.putShort(slot);
                    this.packetStream.putShort(100);
                    this.packetStream.putInt(MAGIC_DEPOSIT);
                    this.packetStream.sendPacket();
                }

                if (
                    this.getInventoryCount(slot) >= 500 &&
                    this.mouseX >= mouseX + 335 &&
                    this.mouseY >= mouseY + 263 &&
                    this.mouseX < mouseX + 368 &&
                    this.mouseY <= mouseY + 274
                ) {
                    this.packetStream.newPacket(clientOpcodes.BANK_DEPOSIT);
                    this.packetStream.putShort(slot);
                    this.packetStream.putShort(500);
                    this.packetStream.putInt(MAGIC_DEPOSIT);
                    this.packetStream.sendPacket();
                }

                if (
                    this.getInventoryCount(slot) >= 2500 &&
                    this.mouseX >= mouseX + 370 &&
                    this.mouseY >= mouseY + 263 &&
                    this.mouseX < mouseX + 400 &&
                    this.mouseY <= mouseY + 274
                ) {
                    this.packetStream.newPacket(clientOpcodes.BANK_DEPOSIT);
                    this.packetStream.putShort(slot);
                    this.packetStream.putShort(2500);
                    this.packetStream.putInt(MAGIC_DEPOSIT);
                    this.packetStream.sendPacket();
                }
            }
        } else if (
            this.bankItemCount > ITEMS_PER_PAGE &&
            mouseX >= 50 &&
            mouseX <= 115 &&
            mouseY <= 12
        ) {
            this.bankActivePage = 0;
        } else if (
            this.bankItemCount > ITEMS_PER_PAGE &&
            mouseX >= 115 &&
            mouseX <= 180 &&
            mouseY <= 12
        ) {
            this.bankActivePage = 1;
        } else if (
            this.bankItemCount > ITEMS_PER_PAGE * 2 &&
            mouseX >= 180 &&
            mouseX <= 245 &&
            mouseY <= 12
        ) {
            this.bankActivePage = 2;
        } else if (
            this.bankItemCount > ITEMS_PER_PAGE * 3 &&
            mouseX >= 245 &&
            mouseX <= 310 &&
            mouseY <= 12
        ) {
            this.bankActivePage = 3;
        } else {
            this.packetStream.newPacket(clientOpcodes.BANK_CLOSE);
            this.packetStream.sendPacket();
            this.showDialogBank = false;
            return;
        }
    }

    const x = ((this.gameWidth / 2) | 0) - ((WIDTH / 2) | 0);
    const y = ((this.gameHeight / 2) | 0) - ((HEIGHT / 2) | 0);

    this.surface.drawBox(x, y, 408, 12, 192);
    this.surface.drawBoxAlpha(x, y + 12, 408, 17, colours.grey, 160);
    this.surface.drawBoxAlpha(x, y + 29, 8, 204, colours.grey, 160);
    this.surface.drawBoxAlpha(x + 399, y + 29, 9, 204, colours.grey, 160);
    this.surface.drawBoxAlpha(x, y + 233, 408, 47, colours.grey, 160);
    this.surface.drawString('Bank', x + 1, y + 10, 1, colours.white);

    // TODO drawPages

    let offsetX = 50;

    if (this.bankItemCount > ITEMS_PER_PAGE) {
        let textColour = colours.white;

        if (this.bankActivePage === 0) {
            textColour = colours.red;
        } else if (
            this.mouseX > x + offsetX &&
            this.mouseY >= y &&
            this.mouseX < x + offsetX + 65 &&
            this.mouseY < y + 12
        ) {
            textColour = colours.yellow;
        }

        this.surface.drawString('<page 1>', x + offsetX, y + 10, 1, textColour);

        offsetX += 65;
        textColour = colours.white;

        if (this.bankActivePage === 1) {
            textColour = colours.red;
        } else if (
            this.mouseX > x + offsetX &&
            this.mouseY >= y &&
            this.mouseX < x + offsetX + 65 &&
            this.mouseY < y + 12
        ) {
            textColour = colours.yellow;
        }

        this.surface.drawString('<page 2>', x + offsetX, y + 10, 1, textColour);
        offsetX += 65;
    }

    if (this.bankItemCount > ITEMS_PER_PAGE * 2) {
        let textColour = colours.white;

        if (this.bankActivePage === 2) {
            textColour = colours.red;
        } else if (
            this.mouseX > x + offsetX &&
            this.mouseY >= y &&
            this.mouseX < x + offsetX + 65 &&
            this.mouseY < y + 12
        ) {
            textColour = colours.yellow;
        }

        this.surface.drawString('<page 3>', x + offsetX, y + 10, 1, textColour);
        offsetX += 65;
    }

    if (this.bankItemCount > ITEMS_PER_PAGE * 3) {
        let textColour = colours.white;

        if (this.bankActivePage === 3) {
            textColour = colours.red;
        } else if (
            this.mouseX > x + offsetX &&
            this.mouseY >= y &&
            this.mouseX < x + offsetX + 65 &&
            this.mouseY < y + 12
        ) {
            textColour = colours.yellow;
        }

        this.surface.drawString('<page 4>', x + offsetX, y + 10, 1, textColour);
        offsetX += 65;
    }

    let textColour = colours.white;

    if (
        this.mouseX > x + 320 &&
        this.mouseY >= y &&
        this.mouseX < x + 408 &&
        this.mouseY < y + 12
    ) {
        textColour = colours.red;
    }

    this.surface.drawStringRight(
        'Close window',
        x + 406,
        y + 10,
        1,
        textColour
    );

    this.surface.drawString(
        'Number in bank in green',
        x + 7,
        y + 24,
        1,
        colours.green
    );

    this.surface.drawString(
        'Number held in blue',
        x + 289,
        y + 24,
        1,
        colours.cyan
    );

    let selectedIndex = this.bankActivePage * ITEMS_PER_PAGE;

    for (let row = 0; row < 6; row++) {
        for (let col = 0; col < 8; col++) {
            const slotX = x + 7 + col * 49;
            const slotY = y + 28 + row * 34;

            if (this.bankSelectedItemSlot === selectedIndex) {
                this.surface.drawBoxAlpha(
                    slotX,
                    slotY,
                    49,
                    34,
                    colours.red,
                    160
                );
            } else {
                this.surface.drawBoxAlpha(
                    slotX,
                    slotY,
                    49,
                    34,
                    colours.lightGrey2,
                    160
                );
            }

            this.surface.drawBoxEdge(slotX, slotY, 50, 35, 0);

            if (
                selectedIndex < this.bankItemCount &&
                this.bankItems[selectedIndex] !== -1
            ) {
                this.surface._spriteClipping_from9(
                    slotX,
                    slotY,
                    48,
                    32,
                    this.spriteItem +
                        GameData.itemPicture[this.bankItems[selectedIndex]],
                    GameData.itemMask[this.bankItems[selectedIndex]],
                    0,
                    0,
                    false
                );

                this.surface.drawString(
                    this.bankItemsCount[selectedIndex].toString(),
                    slotX + 1,
                    slotY + 10,
                    1,
                    colours.green
                );

                this.surface.drawStringRight(
                    this.getInventoryCount(
                        this.bankItems[selectedIndex]
                    ).toString(),
                    slotX + 47,
                    slotY + 29,
                    1,
                    colours.cyan
                );
            }

            selectedIndex++;
        }
    }

    this.surface.drawLineHoriz(x + 5, y + 256, 398, 0);

    if (this.bankSelectedItemSlot === -1) {
        this.surface.drawStringCenter(
            'Select an object to withdraw or deposit',
            x + 204,
            y + 248,
            3,
            colours.yellow
        );

        return;
    }

    let itemType = 0;

    if (this.bankSelectedItemSlot < 0) {
        itemType = -1;
    } else {
        itemType = this.bankItems[this.bankSelectedItemSlot];
    }

    if (itemType !== -1) {
        let itemCount = this.bankItemsCount[this.bankSelectedItemSlot];

        if (GameData.itemStackable[itemType] === 1 && itemCount > 1) {
            itemCount = 1;
        }

        if (itemCount > 0) {
            this.surface.drawString(
                `Withdraw ${GameData.itemName[itemType]}`,
                x + 2,
                y + 248,
                1,
                colours.white
            );

            textColour = colours.white;

            if (
                this.mouseX >= x + 220 &&
                this.mouseY >= y + 238 &&
                this.mouseX < x + 250 &&
                this.mouseY <= y + 249
            ) {
                textColour = colours.red;
            }

            this.surface.drawString('One', x + 222, y + 248, 1, textColour);

            if (itemCount >= 5) {
                textColour = colours.white;

                if (
                    this.mouseX >= x + 250 &&
                    this.mouseY >= y + 238 &&
                    this.mouseX < x + 280 &&
                    this.mouseY <= y + 249
                ) {
                    textColour = colours.red;
                }

                this.surface.drawString(
                    'Five',
                    x + 252,
                    y + 248,
                    1,
                    textColour
                );
            }

            if (itemCount >= 25) {
                textColour = colours.white;

                if (
                    this.mouseX >= x + 280 &&
                    this.mouseY >= y + 238 &&
                    this.mouseX < x + 305 &&
                    this.mouseY <= y + 249
                ) {
                    textColour = colours.red;
                }

                this.surface.drawString('25', x + 282, y + 248, 1, textColour);
            }

            if (itemCount >= 100) {
                textColour = colours.white;

                if (
                    this.mouseX >= x + 305 &&
                    this.mouseY >= y + 238 &&
                    this.mouseX < x + 335 &&
                    this.mouseY <= y + 249
                ) {
                    textColour = colours.red;
                }

                this.surface.drawString('100', x + 307, y + 248, 1, textColour);
            }

            if (itemCount >= 500) {
                textColour = colours.white;

                if (
                    this.mouseX >= x + 335 &&
                    this.mouseY >= y + 238 &&
                    this.mouseX < x + 368 &&
                    this.mouseY <= y + 249
                ) {
                    textColour = colours.red;
                }

                this.surface.drawString('500', x + 337, y + 248, 1, textColour);
            }

            if (itemCount >= 2500) {
                textColour = colours.white;

                if (
                    this.mouseX >= x + 370 &&
                    this.mouseY >= y + 238 &&
                    this.mouseX < x + 400 &&
                    this.mouseY <= y + 249
                ) {
                    textColour = colours.red;
                }

                this.surface.drawString(
                    '2500',
                    x + 370,
                    y + 248,
                    1,
                    textColour
                );
            }
        }

        if (this.getInventoryCount(itemType) > 0) {
            this.surface.drawString(
                `Deposit ${GameData.itemName[itemType]}`,
                x + 2,
                y + 273,
                1,
                colours.white
            );

            textColour = colours.white;

            if (
                this.mouseX >= x + 220 &&
                this.mouseY >= y + 263 &&
                this.mouseX < x + 250 &&
                this.mouseY <= y + 274
            ) {
                textColour = colours.red;
            }

            this.surface.drawString('One', x + 222, y + 273, 1, textColour);

            if (this.getInventoryCount(itemType) >= 5) {
                textColour = colours.white;

                if (
                    this.mouseX >= x + 250 &&
                    this.mouseY >= y + 263 &&
                    this.mouseX < x + 280 &&
                    this.mouseY <= y + 274
                ) {
                    textColour = colours.red;
                }

                this.surface.drawString(
                    'Five',
                    x + 252,
                    y + 273,
                    1,
                    textColour
                );
            }

            if (this.getInventoryCount(itemType) >= 25) {
                textColour = colours.white;

                if (
                    this.mouseX >= x + 280 &&
                    this.mouseY >= y + 263 &&
                    this.mouseX < x + 305 &&
                    this.mouseY <= y + 274
                ) {
                    textColour = colours.red;
                }

                this.surface.drawString('25', x + 282, y + 273, 1, textColour);
            }

            if (this.getInventoryCount(itemType) >= 100) {
                textColour = colours.white;

                if (
                    this.mouseX >= x + 305 &&
                    this.mouseY >= y + 263 &&
                    this.mouseX < x + 335 &&
                    this.mouseY <= y + 274
                ) {
                    textColour = colours.red;
                }

                this.surface.drawString('100', x + 307, y + 273, 1, textColour);
            }

            if (this.getInventoryCount(itemType) >= 500) {
                textColour = colours.white;

                if (
                    this.mouseX >= x + 335 &&
                    this.mouseY >= y + 263 &&
                    this.mouseX < x + 368 &&
                    this.mouseY <= y + 274
                ) {
                    textColour = colours.red;
                }

                this.surface.drawString('500', x + 337, y + 273, 1, textColour);
            }

            if (this.getInventoryCount(itemType) >= 2500) {
                textColour = colours.white;

                if (
                    this.mouseX >= x + 370 &&
                    this.mouseY >= y + 263 &&
                    this.mouseX < x + 400 &&
                    this.mouseY <= y + 274
                ) {
                    textColour = colours.red;
                }

                this.surface.drawString(
                    '2500',
                    x + 370,
                    y + 273,
                    1,
                    textColour
                );
            }
        }
    }
}

module.exports = { drawDialogBank };

},{"../game-data":44,"../opcodes/client":54,"./_colours":75}],78:[function(require,module,exports){
const clientOpcodes = require('../opcodes/client');
const colours = require('./_colours');

const GREY = 0xbebebe;

const BUTTON_HEIGHT = 20;
const UI_X = 7;
const UI_Y = 15;
const WIDTH = 175;

const COMBAT_STYLES = [
    'Controlled (+1 of each)',
    'Aggressive (+3 strength)',
    'Accurate (+3 attack)',
    'Defensive (+3 defense)'
];

function drawDialogCombatStyle() {
    if (this.mouseButtonClick !== 0) {
        for (let i = 0; i < COMBAT_STYLES.length + 1; i++) {
            if (
                i <= 0 ||
                this.mouseX <= UI_X ||
                this.mouseX >= UI_X + WIDTH ||
                this.mouseY <= UI_Y + i * BUTTON_HEIGHT ||
                this.mouseY >= UI_Y + i * BUTTON_HEIGHT + BUTTON_HEIGHT
            ) {
                continue;
            }

            this.combatStyle = i - 1;
            this.mouseButtonClick = 0;

            this.packetStream.newPacket(clientOpcodes.COMBAT_STYLE);
            this.packetStream.putByte(this.combatStyle);
            this.packetStream.sendPacket();
            break;
        }
    }

    for (let i = 0; i < COMBAT_STYLES.length + 1; i++) {
        const boxColour = i === this.combatStyle + 1 ? colours.red : GREY;

        this.surface.drawBoxAlpha(
            UI_X,
            UI_Y + i * BUTTON_HEIGHT,
            WIDTH,
            BUTTON_HEIGHT,
            boxColour,
            128
        );
        this.surface.drawLineHoriz(
            UI_X,
            UI_Y + i * BUTTON_HEIGHT,
            WIDTH,
            colours.black
        );
        this.surface.drawLineHoriz(
            UI_X,
            UI_Y + i * BUTTON_HEIGHT + BUTTON_HEIGHT,
            WIDTH,
            colours.black
        );
    }

    let y = 16;

    this.surface.drawStringCenter(
        'Select combat style',
        UI_X + ((WIDTH / 2) | 0),
        UI_Y + y,
        3,
        colours.white
    );

    y += BUTTON_HEIGHT;

    for (const combatStyle of COMBAT_STYLES) {
        this.surface.drawStringCenter(
            combatStyle,
            UI_X + ((WIDTH / 2) | 0),
            UI_Y + y,
            3,
            colours.black
        );

        y += BUTTON_HEIGHT;
    }
}

module.exports = {
    combatStyle: 0,
    drawDialogCombatStyle
};

},{"../opcodes/client":54,"./_colours":75}],79:[function(require,module,exports){


function applyUIComponents(mudclient) {
    const components = (function () {var f = require("./index.js");f["_colours"]=require("./_colours.js");f["appearance-panel"]=require("./appearance-panel.js");f["bank-dialog"]=require("./bank-dialog.js");f["combat-style"]=require("./combat-style.js");f["index"]=require("./index.js");f["inventory-tab"]=require("./inventory-tab.js");f["login-panels"]=require("./login-panels.js");f["logout-dialog"]=require("./logout-dialog.js");f["magic-tab"]=require("./magic-tab.js");f["minimap-tab"]=require("./minimap-tab.js");f["option-menu"]=require("./option-menu.js");f["options-tab"]=require("./options-tab.js");f["password-dialog"]=require("./password-dialog.js");f["player-info-tab"]=require("./player-info-tab.js");f["recovery-panel"]=require("./recovery-panel.js");f["report-dialog"]=require("./report-dialog.js");f["server-message-dialog"]=require("./server-message-dialog.js");f["shop-dialog"]=require("./shop-dialog.js");f["sleep"]=require("./sleep.js");f["social-dialog"]=require("./social-dialog.js");f["social-tab"]=require("./social-tab.js");f["trade-confirm-dialog"]=require("./trade-confirm-dialog.js");f["trade-dialog"]=require("./trade-dialog.js");f["welcome-dialog"]=require("./welcome-dialog.js");f["wilderness-dialog"]=require("./wilderness-dialog.js");return f;})();

    for (const [componentName, component] of Object.entries(components)) {
        if (/^_|index/.test(componentName)) {
            continue;
        }

        for (const [propertyName, member] of Object.entries(component)) {
            if (typeof member === 'function') {
                mudclient[propertyName] = member.bind(mudclient);
            } else {
                mudclient[propertyName] = member;
            }
        }
    }
}

module.exports = applyUIComponents;

},{"./_colours.js":75,"./appearance-panel.js":76,"./bank-dialog.js":77,"./combat-style.js":78,"./index.js":79,"./inventory-tab.js":80,"./login-panels.js":81,"./logout-dialog.js":82,"./magic-tab.js":83,"./minimap-tab.js":84,"./option-menu.js":85,"./options-tab.js":86,"./password-dialog.js":87,"./player-info-tab.js":88,"./recovery-panel.js":89,"./report-dialog.js":90,"./server-message-dialog.js":91,"./shop-dialog.js":92,"./sleep.js":93,"./social-dialog.js":94,"./social-tab.js":95,"./trade-confirm-dialog.js":96,"./trade-dialog.js":97,"./welcome-dialog.js":98,"./wilderness-dialog.js":99}],80:[function(require,module,exports){
const GameData = require('../game-data');
const colours = require('./_colours');

const UI_X = 512 - 248;
const UI_Y = 36;

function drawUiTabInventory(noMenus) {
    this.surface._drawSprite_from3(UI_X, 3, this.spriteMedia + 1);

    for (let i = 0; i < this.inventoryMaxItemCount; i++) {
        const slotX = UI_X + (i % 5) * 49;
        const slotY = 36 + ((i / 5) | 0) * 34;

        if (i < this.inventoryItemsCount && this.inventoryEquipped[i] === 1) {
            this.surface.drawBoxAlpha(slotX, slotY, 49, 34, colours.red, 128);
        } else {
            this.surface.drawBoxAlpha(
                slotX,
                slotY,
                49,
                34,
                colours.darkGrey,
                128
            );
        }

        if (i < this.inventoryItemsCount) {
            const spriteId =
                this.spriteItem + GameData.itemPicture[this.inventoryItemId[i]];
            const spriteMask = GameData.itemMask[this.inventoryItemId[i]];

            this.surface._spriteClipping_from9(
                slotX,
                slotY,
                48,
                32,
                spriteId,
                spriteMask,
                0,
                0,
                false
            );

            if (GameData.itemStackable[this.inventoryItemId[i]] === 0) {
                this.surface.drawString(
                    this.inventoryItemStackCount[i].toString(),
                    slotX + 1,
                    slotY + 10,
                    1,
                    colours.yellow
                );
            }
        }
    }

    // rows and columns
    for (let i = 1; i <= 4; i++) {
        this.surface.drawLineVert(
            UI_X + i * 49,
            36,
            ((this.inventoryMaxItemCount / 5) | 0) * 34,
            colours.black
        );
    }

    for (let i = 1; i <= ((this.inventoryMaxItemCount / 5) | 0) - 1; i++) {
        this.surface.drawLineHoriz(UI_X, 36 + i * 34, 245, colours.black);
    }

    if (!noMenus) {
        return;
    }

    const mouseX = this.mouseX - UI_X;
    const mouseY = this.mouseY - UI_Y;

    if (
        mouseX >= 0 &&
        mouseY >= 0 &&
        mouseX < 248 &&
        mouseY < ((this.inventoryMaxItemCount / 5) | 0) * 34
    ) {
        const itemIndex = ((mouseX / 49) | 0) + ((mouseY / 34) | 0) * 5;

        if (itemIndex < this.inventoryItemsCount) {
            const itemID = this.inventoryItemId[itemIndex];
            const itemName = `@lre@${GameData.itemName[itemID]}`;

            if (this.selectedSpell >= 0) {
                if (GameData.spellType[this.selectedSpell] === 3) {
                    this.menuItemText1[this.menuItemsCount] = `Cast ${
                        GameData.spellName[this.selectedSpell]
                    } on`;
                    this.menuItemText2[this.menuItemsCount] = itemName;
                    this.menuType[this.menuItemsCount] = 600;
                    this.menuIndex[this.menuItemsCount] = itemIndex;
                    this.menuSourceIndex[
                        this.menuItemsCount
                    ] = this.selectedSpell;
                    this.menuItemsCount++;
                    return;
                }
            } else {
                if (this.selectedItemInventoryIndex >= 0) {
                    this.menuItemText1[
                        this.menuItemsCount
                    ] = `Use ${this.selectedItemName} with:`;
                    this.menuItemText2[this.menuItemsCount] = itemName;
                    this.menuType[this.menuItemsCount] = 610;
                    this.menuIndex[this.menuItemsCount] = itemIndex;
                    this.menuSourceIndex[
                        this.menuItemsCount
                    ] = this.selectedItemInventoryIndex;
                    this.menuItemsCount++;
                    return;
                }

                if (this.inventoryEquipped[itemIndex] === 1) {
                    this.menuItemText1[this.menuItemsCount] = 'Remove';
                    this.menuItemText2[this.menuItemsCount] = itemName;
                    this.menuType[this.menuItemsCount] = 620;
                    this.menuIndex[this.menuItemsCount] = itemIndex;
                    this.menuItemsCount++;
                } else if (GameData.itemWearable[itemID] !== 0) {
                    if ((GameData.itemWearable[itemID] & 24) !== 0) {
                        this.menuItemText1[this.menuItemsCount] = 'Wield';
                    } else {
                        this.menuItemText1[this.menuItemsCount] = 'Wear';
                    }

                    this.menuItemText2[this.menuItemsCount] = itemName;
                    this.menuType[this.menuItemsCount] = 630;
                    this.menuIndex[this.menuItemsCount] = itemIndex;
                    this.menuItemsCount++;
                }

                if (GameData.itemCommand[itemID] !== '') {
                    this.menuItemText1[this.menuItemsCount] =
                        GameData.itemCommand[itemID];
                    this.menuItemText2[this.menuItemsCount] = itemName;
                    this.menuType[this.menuItemsCount] = 640;
                    this.menuIndex[this.menuItemsCount] = itemIndex;
                    this.menuItemsCount++;
                }

                this.menuItemText1[this.menuItemsCount] = 'Use';
                this.menuItemText2[this.menuItemsCount] = itemName;
                this.menuType[this.menuItemsCount] = 650;
                this.menuIndex[this.menuItemsCount] = itemIndex;
                this.menuItemsCount++;

                this.menuItemText1[this.menuItemsCount] = 'Drop';
                this.menuItemText2[this.menuItemsCount] = itemName;
                this.menuType[this.menuItemsCount] = 660;
                this.menuIndex[this.menuItemsCount] = itemIndex;
                this.menuItemsCount++;

                this.menuItemText1[this.menuItemsCount] = 'Examine';
                this.menuItemText2[this.menuItemsCount] = itemName;
                this.menuType[this.menuItemsCount] = 3600;
                this.menuIndex[this.menuItemsCount] = itemID;
                this.menuItemsCount++;
            }
        }
    }
}

module.exports = { drawUiTabInventory };

},{"../game-data":44,"./_colours":75}],81:[function(require,module,exports){
const Panel = require('../panel');

function createLoginPanels() {
    this.panelLoginWelcome = new Panel(this.surface, 50);

    let y = 40;
    const x = (this.gameWidth / 2) | 0;

    if (!this.members) {
        this.panelLoginWelcome.addTextCentre(
            x,
            200 + y,
            'Click on an option',
            5,
            true
        );

        this.panelLoginWelcome.addButtonBackground(x - 100, 240 + y, 120, 35);

        this.panelLoginWelcome.addTextCentre(
            x - 100,
            240 + y,
            'New User',
            5,
            false
        );

        this.controlWelcomeNewUser = this.panelLoginWelcome.addButton(
            x - 100,
            240 + y,
            120,
            35
        );

        this.panelLoginWelcome.addButtonBackground(x + 100, 240 + y, 120, 35);

        this.panelLoginWelcome.addTextCentre(
            x + 100,
            240 + y,
            'Existing User',
            5,
            false
        );

        this.controlWelcomeExistingUser = this.panelLoginWelcome.addButton(
            x + 100,
            240 + y,
            120,
            35
        );
    } else {
        this.panelLoginWelcome.addTextCentre(
            x,
            200 + y,
            'Welcome to RuneScape',
            4,
            true
        );

        this.panelLoginWelcome.addTextCentre(
            x,
            215 + y,
            'You need a members account to use this server',
            4,
            true
        );

        this.panelLoginWelcome.addButtonBackground(x, 250 + y, 200, 35);

        this.panelLoginWelcome.addTextCentre(
            x,
            250 + y,
            'Click here to login',
            5,
            false
        );

        this.controlWelcomeExistingUser = this.panelLoginWelcome.addButton(
            x,
            250 + y,
            200,
            35
        );
    }

    this.panelLoginNewUser = new Panel(this.surface, 50);

    if (!this.options.accountManagement) {
        y = 230;

        if (this.referID === 0) {
            this.panelLoginNewUser.addTextCentre(
                x,
                y + 8,
                'To create an account please go back to the',
                4,
                true
            );

            y += 20;

            this.panelLoginNewUser.addTextCentre(
                x,
                y + 8,
                "www.runescape.com front page, and choose 'create account'",
                4,
                true
            );
        } else if (this.referID === 1) {
            this.panelLoginNewUser.addTextCentre(
                x,
                y + 8,
                'To create an account please click on the',
                4,
                true
            );

            y += 20;

            this.panelLoginNewUser.addTextCentre(
                x,
                y + 8,
                "'create account' link below the game window",
                4,
                true
            );
        } else {
            this.panelLoginNewUser.addTextCentre(
                x,
                y + 8,
                'To create an account please go back to the',
                4,
                true
            );

            y += 20;

            this.panelLoginNewUser.addTextCentre(
                x,
                y + 8,
                "runescape front webpage and choose 'create account'",
                4,
                true
            );
        }

        y += 30;

        this.panelLoginNewUser.addButtonBackground(x, y + 17, 150, 34);
        this.panelLoginNewUser.addTextCentre(x, y + 17, 'Ok', 5, false);

        this.controlLoginNewOk = this.panelLoginNewUser.addButton(
            x,
            y + 17,
            150,
            34
        );
    } else {
        y = 70;

        this.controlRegisterStatus = this.panelLoginNewUser.addTextCentre(
            x,
            y + 8,
            'To create an account please enter all the requested details',
            4,
            true
        );

        let offsetY = y + 25;

        this.panelLoginNewUser.addButtonBackground(x, offsetY + 17, 250, 34);

        this.panelLoginNewUser.addTextCentre(
            x,
            offsetY + 8,
            'Choose a Username',
            4,
            false
        );

        this.controlRegisterUser = this.panelLoginNewUser.addTextInput(
            x,
            offsetY + 25,
            200,
            40,
            4,
            12,
            false,
            false
        );

        this.panelLoginNewUser.setFocus(this.controlRegisterUser);

        offsetY += 40;

        this.panelLoginNewUser.addButtonBackground(
            x - 115,
            offsetY + 17,
            220,
            34
        );

        this.panelLoginNewUser.addTextCentre(
            x - 115,
            offsetY + 8,
            'Choose a Password',
            4,
            false
        );

        this.controlRegisterPassword = this.panelLoginNewUser.addTextInput(
            x - 115,
            offsetY + 25,
            220,
            40,
            4,
            20,
            true,
            false
        );

        this.panelLoginNewUser.addButtonBackground(
            x + 115,
            offsetY + 17,
            220,
            34
        );

        this.panelLoginNewUser.addTextCentre(
            x + 115,
            offsetY + 8,
            'Confirm Password',
            4,
            false
        );

        this.controlRegisterConfirmPassword = this.panelLoginNewUser.addTextInput(
            x + 115,
            offsetY + 25,
            220,
            40,
            4,
            20,
            true,
            false
        );

        offsetY += 60;

        this.controlRegisterCheckbox = this.panelLoginNewUser.addCheckbox(
            x - 196 - 7,
            offsetY - 7,
            14,
            14
        );

        this.panelLoginNewUser.addText(
            x - 181,
            offsetY,
            'I have read and agreed to the terms and conditions',
            4,
            true
        );

        offsetY += 15;

        this.panelLoginNewUser.addTextCentre(
            x,
            offsetY,
            '(to view these click the relevant link below this game window)',
            4,
            true
        );

        offsetY += 20;

        this.panelLoginNewUser.addButtonBackground(
            x - 100,
            offsetY + 17,
            150,
            34
        );

        this.panelLoginNewUser.addTextCentre(
            x - 100,
            offsetY + 17,
            'Submit',
            5,
            false
        );

        this.controlRegisterSubmit = this.panelLoginNewUser.addButton(
            x - 100,
            offsetY + 17,
            150,
            34
        );

        this.panelLoginNewUser.addButtonBackground(
            x + 100,
            offsetY + 17,
            150,
            34
        );

        this.panelLoginNewUser.addTextCentre(
            x + 100,
            offsetY + 17,
            'Cancel',
            5,
            false
        );

        this.controlRegisterCancel = this.panelLoginNewUser.addButton(
            x + 100,
            offsetY + 17,
            150,
            34
        );
    }

    this.panelLoginExistingUser = new Panel(this.surface, 50);

    y = 230;

    this.controlLoginStatus = this.panelLoginExistingUser.addTextCentre(
        x,
        y - 10,
        'Please enter your username and password',
        4,
        true
    );

    y += 28;

    this.panelLoginExistingUser.addButtonBackground(x - 116, y, 200, 40);

    this.panelLoginExistingUser.addTextCentre(
        x - 116,
        y - 10,
        'Username:',
        4,
        false
    );

    this.controlLoginUser = this.panelLoginExistingUser.addTextInput(
        x - 116,
        y + 10,
        200,
        40,
        4,
        12,
        false,
        false
    );

    y += 47;

    this.panelLoginExistingUser.addButtonBackground(x - 66, y, 200, 40);

    this.panelLoginExistingUser.addTextCentre(
        x - 66,
        y - 10,
        'Password:',
        4,
        false
    );

    this.controlLoginPassword = this.panelLoginExistingUser.addTextInput(
        x - 66,
        y + 10,
        200,
        40,
        4,
        20,
        true,
        false
    );

    y -= 55;

    this.panelLoginExistingUser.addButtonBackground(x + 154, y, 120, 25);
    this.panelLoginExistingUser.addTextCentre(x + 154, y, 'Ok', 4, false);

    this.controlLoginOk = this.panelLoginExistingUser.addButton(
        x + 154,
        y,
        120,
        25
    );

    y += 30;

    this.panelLoginExistingUser.addButtonBackground(x + 154, y, 120, 25);
    this.panelLoginExistingUser.addTextCentre(x + 154, y, 'Cancel', 4, false);

    this.controlLoginCancel = this.panelLoginExistingUser.addButton(
        x + 154,
        y,
        120,
        25
    );

    if (this.options.accountManagement) {
        y += 30;

        this.panelLoginExistingUser.addButtonBackground(x + 154, y, 160, 25);
        this.panelLoginExistingUser.addTextCentre(
            x + 154,
            y,
            "I've lost my password",
            4,
            false
        );
        this.controlLoginRecover = this.panelLoginExistingUser.addButton(
            x + 154,
            y,
            160,
            25
        );
    }

    this.panelLoginExistingUser.setFocus(this.controlLoginUser);
}

function renderLoginScreenViewports() {
    const plane = 0;
    const regionX = 50; //49;
    const regionY = 50; //47;

    this.world._loadSection_from3(regionX * 48 + 23, regionY * 48 + 23, plane);
    this.world.addModels(this.gameModels);

    let x = 9728;
    let y = 6400;
    let zoom = 1100;
    let rotation = 888;

    this.scene.clipFar3d = 4100;
    this.scene.clipFar2d = 4100;
    this.scene.fogZFalloff = 1;
    this.scene.fogZDistance = 4000;

    this.surface.blackScreen();

    this.scene.setCamera(
        x,
        -this.world.getElevation(x, y),
        y,
        912,
        rotation,
        0,
        zoom * 2
    );

    this.scene.render();

    this.surface.fadeToBlack();
    this.surface.fadeToBlack();

    this.surface.drawBox(0, 0, this.gameWidth, 6, 0);

    for (let i = 6; i >= 1; i--) {
        this.surface.drawLineAlpha(0, i, 0, i, this.gameWidth, 8);
    }

    this.surface.drawBox(0, 194, 512, 20, 0);

    for (let i = 6; i >= 1; i--) {
        this.surface.drawLineAlpha(0, i, 0, 194 - i, this.gameWidth, 8);
    }

    // runescape logo
    this.surface._drawSprite_from3(
        ((this.gameWidth / 2) | 0) -
            ((this.surface.spriteWidth[this.spriteMedia + 10] / 2) | 0),
        15,
        this.spriteMedia + 10
    );

    this.surface._drawSprite_from5(this.spriteLogo, 0, 0, this.gameWidth, 200);

    this.surface.drawWorld(this.spriteLogo);

    x = 9216;
    y = 9216;
    zoom = 1100;
    rotation = 888;

    this.scene.clipFar3d = 4100;
    this.scene.clipFar2d = 4100;
    this.scene.fogZFalloff = 1;
    this.scene.fogZDistance = 4000;

    this.surface.blackScreen();

    this.scene.setCamera(
        x,
        -this.world.getElevation(x, y),
        y,
        912,
        rotation,
        0,
        zoom * 2
    );

    this.scene.render();

    this.surface.fadeToBlack();
    this.surface.fadeToBlack();
    this.surface.drawBox(0, 0, this.gameWidth, 6, 0);

    for (let i = 6; i >= 1; i--) {
        this.surface.drawLineAlpha(0, i, 0, i, this.gameWidth, 8);
    }

    this.surface.drawBox(0, 194, this.gameWidth, 20, 0);

    for (let i = 6; i >= 1; i--) {
        this.surface.drawLineAlpha(0, i, 0, 194 - i, this.gameWidth, 8);
    }

    this.surface._drawSprite_from3(
        ((this.gameWidth / 2) | 0) -
            ((this.surface.spriteWidth[this.spriteMedia + 10] / 2) | 0),
        15,
        this.spriteMedia + 10
    );

    this.surface._drawSprite_from5(
        this.spriteLogo + 1,
        0,
        0,
        this.gameWidth,
        200
    );

    this.surface.drawWorld(this.spriteLogo + 1);

    for (let i = 0; i < 64; i++) {
        this.scene.removeModel(this.world.roofModels[0][i]);
        this.scene.removeModel(this.world.wallModels[1][i]);
        this.scene.removeModel(this.world.roofModels[1][i]);
        this.scene.removeModel(this.world.wallModels[2][i]);
        this.scene.removeModel(this.world.roofModels[2][i]);
    }

    x = 11136;
    y = 10368;
    zoom = 500;
    rotation = 376;

    this.scene.clipFar3d = 4100;
    this.scene.clipFar2d = 4100;
    this.scene.fogZFalloff = 1;
    this.scene.fogZDistance = 4000;

    this.surface.blackScreen();

    this.scene.setCamera(
        x,
        -this.world.getElevation(x, y),
        y,
        912,
        rotation,
        0,
        zoom * 2
    );

    this.scene.render();

    this.surface.fadeToBlack();
    this.surface.fadeToBlack();
    this.surface.drawBox(0, 0, this.gameWidth, 6, 0);

    for (let i = 6; i >= 1; i--) {
        this.surface.drawLineAlpha(0, i, 0, i, this.gameWidth, 8);
    }

    this.surface.drawBox(0, 194, this.gameWidth, 20, 0);

    for (let i = 6; i >= 1; i--) {
        this.surface.drawLineAlpha(0, i, 0, 194, this.gameWidth, 8);
    }

    this.surface._drawSprite_from3(
        ((this.gameWidth / 2) | 0) -
            ((this.surface.spriteWidth[this.spriteMedia + 10] / 2) | 0),
        15,
        this.spriteMedia + 10
    );

    this.surface._drawSprite_from5(
        this.spriteMedia + 10,
        0,
        0,
        this.gameWidth,
        200
    );

    this.surface.drawWorld(this.spriteMedia + 10);
}

function drawLoginScreens() {
    this.welcomScreenAlreadyShown = false;
    this.surface.interlace = false;

    this.surface.blackScreen();

    let showBackground;

    if (this.options.accountManagement) {
        showBackground = this.loginScreen === 0 || this.loginScreen === 2;
    } else {
        showBackground = this.loginScreen >= 0 && this.loginScreen <= 3;
    }

    if (showBackground) {
        const cycle = (this.loginTimer * 2) % 3072;

        if (cycle < 1024) {
            this.surface._drawSprite_from3(0, 10, this.spriteLogo);

            if (cycle > 768) {
                this.surface._drawSpriteAlpha_from4(
                    0,
                    10,
                    this.spriteLogo + 1,
                    cycle - 768
                );
            }
        } else if (cycle < 2048) {
            this.surface._drawSprite_from3(0, 10, this.spriteLogo + 1);

            if (cycle > 1792) {
                this.surface._drawSpriteAlpha_from4(
                    0,
                    10,
                    this.spriteMedia + 10,
                    cycle - 1792
                );
            }
        } else {
            this.surface._drawSprite_from3(0, 10, this.spriteMedia + 10);

            if (cycle > 2816) {
                this.surface._drawSpriteAlpha_from4(
                    0,
                    10,
                    this.spriteLogo,
                    cycle - 2816
                );
            }
        }
    }

    if (this.loginScreen === 0) {
        this.panelLoginWelcome.drawPanel();
    } else if (this.loginScreen === 1) {
        this.panelLoginNewUser.drawPanel();
    } else if (this.loginScreen === 2) {
        this.panelLoginExistingUser.drawPanel();
    }

    // blue bar
    this.surface._drawSprite_from3(
        0,
        this.gameHeight - 4,
        this.spriteMedia + 22
    );

    this.surface.draw(this.graphics, 0, 0);
}

async function handleLoginScreenInput() {
    if (this.worldFullTimeout > 0) {
        this.worldFullTimeout--;
    }

    if (this.loginScreen === 0) {
        this.panelLoginWelcome.handleMouse(
            this.mouseX,
            this.mouseY,
            this.lastMouseButtonDown,
            this.mouseButtonDown
        );

        if (this.panelLoginWelcome.isClicked(this.controlWelcomeNewUser)) {
            this.loginScreen = 1;

            if (this.options.accountManagement) {
                this.panelLoginNewUser.updateText(this.controlRegisterUser, '');

                this.panelLoginNewUser.updateText(
                    this.controlRegisterPassword,
                    ''
                );

                this.panelLoginNewUser.updateText(
                    this.controlRegisterConfirmPassword,
                    ''
                );

                this.panelLoginNewUser.setFocus(this.controlRegisterUser);

                this.panelLoginNewUser.toggleCheckbox(
                    this.controlRegisterCheckbox,
                    false
                );

                this.panelLoginNewUser.updateText(
                    this.controlRegisterStatus,
                    'To create an account please enter all the requested ' +
                        'details'
                );
            }
        }

        if (this.panelLoginWelcome.isClicked(this.controlWelcomeExistingUser)) {
            this.loginScreen = 2;

            this.panelLoginExistingUser.updateText(
                this.controlLoginStatus,
                'Please enter your username and password'
            );

            this.panelLoginExistingUser.updateText(this.controlLoginUser, '');

            this.panelLoginExistingUser.updateText(
                this.controlLoginPassword,
                ''
            );

            this.panelLoginExistingUser.setFocus(this.controlLoginUser);

            return;
        }
    } else if (this.loginScreen === 1) {
        this.panelLoginNewUser.handleMouse(
            this.mouseX,
            this.mouseY,
            this.lastMouseButtonDown,
            this.mouseButtonDown
        );

        if (this.options.accountManagement) {
            if (this.panelLoginNewUser.isClicked(this.controlRegisterCancel)) {
                this.loginScreen = 0;
                return;
            }

            if (this.panelLoginNewUser.isClicked(this.controlRegisterUser)) {
                this.panelLoginNewUser.setFocus(this.controlRegisterPassword);
                return;
            }

            if (
                this.panelLoginNewUser.isClicked(this.controlRegisterPassword)
            ) {
                this.panelLoginNewUser.setFocus(
                    this.controlRegisterConfirmPassword
                );
                return;
            }

            if (
                this.panelLoginNewUser.isClicked(
                    this.controlRegisterConfirmPassword
                ) ||
                this.panelLoginNewUser.isClicked(this.controlRegisterSubmit)
            ) {
                const username = this.panelLoginNewUser.getText(
                    this.controlRegisterUser
                );

                const password = this.panelLoginNewUser.getText(
                    this.controlRegisterPassword
                );

                const confirmPassword = this.panelLoginNewUser.getText(
                    this.controlRegisterConfirmPassword
                );

                if (
                    !username ||
                    username.length === 0 ||
                    !password ||
                    password.length === 0 ||
                    !confirmPassword ||
                    confirmPassword.length === 0
                ) {
                    this.panelLoginNewUser.updateText(
                        this.controlRegisterStatus,
                        '@yel@Please fill in ALL requested information to ' +
                            'continue!'
                    );

                    return;
                }

                if (password !== confirmPassword) {
                    this.panelLoginNewUser.updateText(
                        this.controlRegisterStatus,
                        '@yel@The two passwords entered are not the same as ' +
                            'each other!'
                    );

                    return;
                }

                if (password.length < 5) {
                    this.panelLoginNewUser.updateText(
                        this.controlRegisterStatus,
                        '@yel@Your password must be at least 5 letters long'
                    );

                    return;
                }

                if (
                    !this.panelLoginNewUser.isActivated(
                        this.controlRegisterCheckbox
                    )
                ) {
                    this.panelLoginNewUser.updateText(
                        this.controlRegisterStatus,
                        '@yel@You must agree to the terms+conditions to ' +
                            'continue'
                    );

                    return;
                }

                this.panelLoginNewUser.updateText(
                    this.controlRegisterStatus,
                    'Please wait... Creating new account'
                );

                this.drawLoginScreens();
                this.resetTimings();

                this.registerUser = this.panelLoginNewUser.getText(
                    this.controlRegisterUser
                );

                this.registerPassword = this.panelLoginNewUser.getText(
                    this.controlRegisterPassword
                );

                await this.register(this.registerUser, this.registerPassword);

                return;
            }
        } else {
            if (this.panelLoginNewUser.isClicked(this.controlLoginNewOk)) {
                this.loginScreen = 0;
                return;
            }
        }
    } else if (this.loginScreen === 2) {
        this.panelLoginExistingUser.handleMouse(
            this.mouseX,
            this.mouseY,
            this.lastMouseButtonDown,
            this.mouseButtonDown
        );

        if (this.panelLoginExistingUser.isClicked(this.controlLoginCancel)) {
            this.loginScreen = 0;
        } else if (
            this.panelLoginExistingUser.isClicked(this.controlLoginUser)
        ) {
            this.panelLoginExistingUser.setFocus(this.controlLoginPassword);
        } else if (
            this.panelLoginExistingUser.isClicked(this.controlLoginPassword) ||
            this.panelLoginExistingUser.isClicked(this.controlLoginOk)
        ) {
            this.loginUser = this.panelLoginExistingUser.getText(
                this.controlLoginUser
            );
            this.loginPass = this.panelLoginExistingUser.getText(
                this.controlLoginPassword
            );

            await this.login(this.loginUser, this.loginPass, false);
        } else if (
            this.panelLoginExistingUser.isClicked(this.controlLoginRecover)
        ) {
            this.loginUser = this.panelLoginExistingUser.getText(
                this.controlLoginUser
            );

            if (this.loginUser.trim().length === 0) {
                this.showLoginScreenStatus(
                    'You must enter your username to recover your password',
                    ''
                );
                return;
            }

            await this.recoverAttempt(this.loginUser);
        }
    }
}

module.exports = {
    controlRecoverQuestions: new Int32Array(5),
    controlRecoverAnswers: new Int32Array(5),
    loginScreen: 0,
    createLoginPanels,
    drawLoginScreens,
    handleLoginScreenInput,
    renderLoginScreenViewports
};

},{"../panel":69}],82:[function(require,module,exports){
const colours = require('./_colours');

function drawDialogLogout() {
    this.surface.drawBox(126, 137, 260, 60, colours.black);
    this.surface.drawBoxEdge(126, 137, 260, 60, colours.white);
    this.surface.drawStringCenter('Logging out...', 256, 173, 5, colours.white);
}

module.exports = { drawDialogLogout };

},{"./_colours":75}],83:[function(require,module,exports){
const GameData = require('../game-data');
const clientOpcodes = require('../opcodes/client');
const colours = require('./_colours');

const HEIGHT = 182;
const UI_X = 313;
const UI_Y = 36;
const WIDTH = 196;
const HALF_WIDTH = (WIDTH / 2) | 0;

const TABS = ['Magic', 'Prayers'];
const TAB_HEIGHT = 24;

function drawUiTabMagic(noMenus) {
    this.surface._drawSprite_from3(UI_X - 49, 3, this.spriteMedia + 4);

    this.surface.drawBoxAlpha(
        UI_X,
        UI_Y + TAB_HEIGHT,
        WIDTH,
        HEIGHT - TAB_HEIGHT,
        colours.lightGrey,
        128
    );

    this.surface.drawLineHoriz(UI_X, UI_Y + 113, WIDTH, colours.black);

    this.surface.drawTabs(
        UI_X,
        UI_Y,
        WIDTH,
        TAB_HEIGHT,
        TABS,
        this.uiTabMagicSubTab
    );

    if (this.uiTabMagicSubTab === 0) {
        this.panelMagic.clearList(this.controlListMagic);

        const magicLevel = this.playerStatCurrent[6];

        for (let i = 0; i < GameData.spellCount; i++) {
            let colourPrefix = '@yel@';

            for (let j = 0; j < GameData.spellRunesRequired[i]; j++) {
                const runeId = GameData.spellRunesId[i][j];
                const runeAmount = GameData.spellRunesCount[i][j];

                if (this.hasInventoryItems(runeId, runeAmount)) {
                    continue;
                }

                colourPrefix = '@whi@';
                break;
            }

            if (GameData.spellLevel[i] > magicLevel) {
                colourPrefix = '@bla@';
            }

            this.panelMagic.addListEntry(
                this.controlListMagic,
                i,
                `${colourPrefix}Level ${GameData.spellLevel[i]}: ` +
                    GameData.spellName[i]
            );
        }

        this.panelMagic.drawPanel();

        const spellIndex = this.panelMagic.getListEntryIndex(
            this.controlListMagic
        );

        if (spellIndex !== -1) {
            this.surface.drawString(
                `Level ${GameData.spellLevel[spellIndex]}` +
                    `: ${GameData.spellName[spellIndex]}`,
                UI_X + 2,
                UI_Y + 124,
                1,
                colours.yellow
            );
            this.surface.drawString(
                GameData.spellDescription[spellIndex],
                UI_X + 2,
                UI_Y + 136,
                0,
                colours.white
            );

            for (let i = 0; i < GameData.spellRunesRequired[spellIndex]; i++) {
                const runeId = GameData.spellRunesId[spellIndex][i];
                const inventoryRuneCount = this.getInventoryCount(runeId);
                const runeCount = GameData.spellRunesCount[spellIndex][i];
                let colourPrefix = '@red@';

                if (this.hasInventoryItems(runeId, runeCount)) {
                    colourPrefix = '@gre@';
                }

                this.surface._drawSprite_from3(
                    UI_X + 2 + i * 44,
                    UI_Y + 150,
                    this.spriteItem + GameData.itemPicture[runeId]
                );
                this.surface.drawString(
                    `${colourPrefix}${inventoryRuneCount}/${runeCount}`,
                    UI_X + 2 + i * 44,
                    UI_Y + 150,
                    1,
                    colours.white
                );
            }
        } else {
            this.surface.drawString(
                'Point at a spell for a description',
                UI_X + 2,
                UI_Y + 124,
                1,
                colours.black
            );
        }
    } else if (this.uiTabMagicSubTab === 1) {
        this.panelMagic.clearList(this.controlListMagic);

        for (let i = 0; i < GameData.prayerCount; i++) {
            let colourPrefix = '@whi@';

            if (GameData.prayerLevel[i] > this.playerStatBase[5]) {
                colourPrefix = '@bla@';
            }

            if (this.prayerOn[i]) {
                colourPrefix = '@gre@';
            }

            this.panelMagic.addListEntry(
                this.controlListMagic,
                i,
                `${colourPrefix}Level ${GameData.prayerLevel[i]}: ` +
                    GameData.prayerName[i]
            );
        }

        this.panelMagic.drawPanel();

        const prayerIndex = this.panelMagic.getListEntryIndex(
            this.controlListMagic
        );

        if (prayerIndex !== -1) {
            this.surface.drawStringCenter(
                `Level ${GameData.prayerLevel[prayerIndex]}: ` +
                    GameData.prayerName[prayerIndex],
                UI_X + HALF_WIDTH,
                UI_Y + 130,
                1,
                colours.yellow
            );
            this.surface.drawStringCenter(
                GameData.prayerDescription[prayerIndex],
                UI_X + HALF_WIDTH,
                UI_Y + 145,
                0,
                colours.white
            );
            this.surface.drawStringCenter(
                'Drain rate: ' + GameData.prayerDrain[prayerIndex],
                UI_X + HALF_WIDTH,
                UI_Y + 160,
                1,
                colours.black
            );
        } else {
            this.surface.drawString(
                'Point at a prayer for a description',
                UI_X + 2,
                UI_Y + 124,
                1,
                colours.black
            );
        }
    }

    if (!noMenus) {
        return;
    }

    const mouseX = this.mouseX - UI_X;
    const mouseY = this.mouseY - UI_Y;

    if (mouseX >= 0 && mouseY >= 0 && mouseX < 196 && mouseY < 182) {
        this.panelMagic.handleMouse(
            mouseX + UI_X,
            mouseY + UI_Y,
            this.lastMouseButtonDown,
            this.mouseButtonDown,
            this.mouseScrollDelta
        );

        if (mouseY <= TAB_HEIGHT && this.mouseButtonClick === 1) {
            if (mouseX < HALF_WIDTH && this.uiTabMagicSubTab === 1) {
                this.uiTabMagicSubTab = 0;
                this.panelMagic.resetListProps(this.controlListMagic);
            } else if (mouseX > HALF_WIDTH && this.uiTabMagicSubTab === 0) {
                this.uiTabMagicSubTab = 1;
                this.panelMagic.resetListProps(this.controlListMagic);
            }
        }

        if (this.mouseButtonClick === 1 && this.uiTabMagicSubTab === 0) {
            const spellIndex = this.panelMagic.getListEntryIndex(
                this.controlListMagic
            );

            if (spellIndex !== -1) {
                const magicLevel = this.playerStatCurrent[6];

                if (GameData.spellLevel[spellIndex] > magicLevel) {
                    this.showMessage(
                        'Your magic ability is not high enough for this spell',
                        3
                    );
                } else {
                    let i = 0;

                    for (
                        i = 0;
                        i < GameData.spellRunesRequired[spellIndex];
                        i++
                    ) {
                        const reagantId = GameData.spellRunesId[spellIndex][i];

                        if (
                            this.hasInventoryItems(
                                reagantId,
                                GameData.spellRunesCount[spellIndex][i]
                            )
                        ) {
                            continue;
                        }

                        this.showMessage(
                            "You don't have all the reagents you need for " +
                                'this spell',
                            3
                        );
                        i = -1;
                        break;
                    }

                    if (i === GameData.spellRunesRequired[spellIndex]) {
                        this.selectedSpell = spellIndex;
                        this.selectedItemInventoryIndex = -1;
                    }
                }
            }
        }

        if (this.mouseButtonClick === 1 && this.uiTabMagicSubTab === 1) {
            const prayerIndex = this.panelMagic.getListEntryIndex(
                this.controlListMagic
            );

            if (prayerIndex !== -1) {
                const prayerLevel = this.playerStatBase[5];

                if (GameData.prayerLevel[prayerIndex] > prayerLevel) {
                    this.showMessage(
                        'Your prayer ability is not high enough for this ' +
                            'prayer',
                        3
                    );
                } else if (this.playerStatCurrent[5] === 0) {
                    this.showMessage(
                        'You have run out of prayer points. Return to a ' +
                            'church to recharge',
                        3
                    );
                } else if (this.prayerOn[prayerIndex]) {
                    this.packetStream.newPacket(clientOpcodes.PRAYER_OFF);
                    this.packetStream.putByte(prayerIndex);
                    this.packetStream.sendPacket();
                    this.prayerOn[prayerIndex] = false;
                    this.playSoundFile('prayeroff');
                } else {
                    this.packetStream.newPacket(clientOpcodes.PRAYER_ON);
                    this.packetStream.putByte(prayerIndex);
                    this.packetStream.sendPacket();
                    this.prayerOn[prayerIndex] = true;
                    this.playSoundFile('prayeron');
                }
            }
        }

        this.mouseButtonClick = 0;
    }
}

module.exports = {
    drawUiTabMagic,
    uiTabMagicSubTab: 0
};

},{"../game-data":44,"../opcodes/client":54,"./_colours":75}],84:[function(require,module,exports){
const Scene = require('../scene');
const colours = require('./_colours');

const HEIGHT = 152;
const UI_X = 313;
const UI_Y = 36;
const WIDTH = 156;

const HALF_HEIGHT = (HEIGHT / 2) | 0;
const HALF_WIDTH = (WIDTH / 2) | 0;

function drawMinimapEntity(x, y, colour) {
    this.surface.setPixel(x, y, colour);
    this.surface.setPixel(x - 1, y, colour);
    this.surface.setPixel(x + 1, y, colour);
    this.surface.setPixel(x, y - 1, colour);
    this.surface.setPixel(x, y + 1, colour);
}

function drawUiTabMinimap(noMenus) {
    this.surface._drawSprite_from3(UI_X - 49, 3, this.spriteMedia + 2);

    const x = UI_X + 40;

    this.surface.drawBox(x, UI_Y, WIDTH, HEIGHT, 0);
    this.surface.setBounds(x, UI_Y, x + WIDTH, UI_Y + HEIGHT);

    const scale = 192 + this.minimapRandom2;
    const rotation = (this.cameraRotation + this.minimapRandom1) & 0xff;

    let playerX = (((this.localPlayer.currentX - 6040) * 3 * scale) / 2048) | 0;
    let playerY = (((this.localPlayer.currentY - 6040) * 3 * scale) / 2048) | 0;

    const sin = Scene.sinCosCache[(1024 - rotation * 4) & 0x3ff];
    const cos = Scene.sinCosCache[((1024 - rotation * 4) & 0x3ff) + 1024];
    const tempX = (playerY * sin + playerX * cos) >> 18;

    playerY = (playerY * cos - playerX * sin) >> 18;
    playerX = tempX;

    this.surface.drawMinimapSprite(
        x + HALF_WIDTH - playerX,
        UI_Y + HALF_HEIGHT + playerY,
        this.spriteMedia - 1,
        (rotation + 64) & 255,
        scale
    );

    for (let i = 0; i < this.objectCount; i++) {
        let objectX =
            (((this.objectX[i] * this.magicLoc +
                64 -
                this.localPlayer.currentX) *
                3 *
                scale) /
                2048) |
            0;

        let objectY =
            (((this.objectY[i] * this.magicLoc +
                64 -
                this.localPlayer.currentY) *
                3 *
                scale) /
                2048) |
            0;

        const tempX = (objectY * sin + objectX * cos) >> 18;

        objectY = (objectY * cos - objectX * sin) >> 18;
        objectX = tempX;

        this.drawMinimapEntity(
            x + HALF_WIDTH + objectX,
            UI_Y + HALF_HEIGHT - objectY,
            colours.cyan
        );
    }

    for (let i = 0; i < this.groundItemCount; i++) {
        let itemX =
            (((this.groundItemX[i] * this.magicLoc +
                64 -
                this.localPlayer.currentX) *
                3 *
                scale) /
                2048) |
            0;

        let itemY =
            (((this.groundItemY[i] * this.magicLoc +
                64 -
                this.localPlayer.currentY) *
                3 *
                scale) /
                2048) |
            0;

        const tempX = (itemY * sin + itemX * cos) >> 18;

        itemY = (itemY * cos - itemX * sin) >> 18;
        itemX = tempX;

        this.drawMinimapEntity(
            x + HALF_WIDTH + itemX,
            UI_Y + HALF_HEIGHT - itemY,
            colours.red
        );
    }

    for (let i = 0; i < this.npcCount; i++) {
        const npc = this.npcs[i];

        let npcX =
            (((npc.currentX - this.localPlayer.currentX) * 3 * scale) / 2048) |
            0;

        let npcY =
            (((npc.currentY - this.localPlayer.currentY) * 3 * scale) / 2048) |
            0;

        const tempX = (npcY * sin + npcX * cos) >> 18;

        npcY = (npcY * cos - npcX * sin) >> 18;
        npcX = tempX;

        this.drawMinimapEntity(
            x + HALF_WIDTH + npcX,
            UI_Y + HALF_HEIGHT - npcY,
            colours.yellow
        );
    }

    for (let i = 0; i < this.playerCount; i++) {
        const player = this.players[i];

        let otherPlayerX =
            (((player.currentX - this.localPlayer.currentX) * 3 * scale) /
                2048) |
            0;

        let otherPlayerY =
            (((player.currentY - this.localPlayer.currentY) * 3 * scale) /
                2048) |
            0;

        const tempX = (otherPlayerY * sin + otherPlayerX * cos) >> 18;

        otherPlayerY = (otherPlayerY * cos - otherPlayerX * sin) >> 18;
        otherPlayerX = tempX;

        let playerColour = colours.white;

        for (let j = 0; j < this.friendListCount; j++) {
            if (
                !player.hash.equals(this.friendListHashes[j]) ||
                this.friendListOnline[j] !== 255
            ) {
                continue;
            }

            playerColour = colours.green;
            break;
        }

        this.drawMinimapEntity(
            x + HALF_WIDTH + otherPlayerX,
            UI_Y + HALF_HEIGHT - otherPlayerY,
            playerColour
        );
    }

    this.surface.drawCircle(
        x + HALF_WIDTH,
        UI_Y + HALF_HEIGHT,
        2,
        colours.white,
        255
    );

    // compass
    this.surface.drawMinimapSprite(
        x + 19,
        55,
        this.spriteMedia + 24,
        (this.cameraRotation + 128) & 255,
        128
    );
    this.surface.setBounds(0, 0, this.gameWidth, this.gameHeight + 12);

    if (!noMenus) {
        return;
    }

    const mouseX = this.mouseX - UI_X;
    const mouseY = this.mouseY - UI_Y;

    if (
        this.options.resetCompass &&
        this.mouseButtonClick === 1 &&
        mouseX > 42 &&
        mouseX < 75 &&
        mouseY > 3 &&
        mouseY < UI_Y
    ) {
        this.cameraRotation = 128;
        this.mouseButtonClick = 0;
        return;
    }

    if (mouseX >= 40 && mouseY >= 0 && mouseX < 196 && mouseY < 152) {
        let dX = (((this.mouseX - (x + HALF_WIDTH)) * 16384) / (3 * scale)) | 0;

        let dY =
            (((this.mouseY - (UI_Y + HALF_HEIGHT)) * 16384) / (3 * scale)) | 0;

        const tempX = (dY * sin + dX * cos) >> 15;

        dY = (dY * cos - dX * sin) >> 15;
        dX = tempX;
        dX += this.localPlayer.currentX;
        dY = this.localPlayer.currentY - dY;

        if (this.mouseButtonClick === 1) {
            this._walkToActionSource_from5(
                this.localRegionX,
                this.localRegionY,
                (dX / 128) | 0,
                (dY / 128) | 0,
                false
            );
            this.mouseButtonClick = 0;
        }
    }
}

module.exports = {
    drawMinimapEntity,
    drawUiTabMinimap
};

},{"../scene":72,"./_colours":75}],85:[function(require,module,exports){
const clientOpcodes = require('../opcodes/client');
const colours = require('./_colours');

function drawOptionMenu() {
    if (this.mouseButtonClick !== 0) {
        for (let i = 0; i < this.optionMenuCount; i++) {
            if (
                this.mouseX >=
                    this.surface.textWidth(this.optionMenuEntry[i], 1) ||
                this.mouseY <= i * 12 ||
                this.mouseY >= 12 + i * 12
            ) {
                continue;
            }

            this.packetStream.newPacket(clientOpcodes.CHOOSE_OPTION);
            this.packetStream.putByte(i);
            this.packetStream.sendPacket();
            break;
        }

        this.mouseButtonClick = 0;
        this.showOptionMenu = false;
        return;
    }

    for (let i = 0; i < this.optionMenuCount; i++) {
        let textColour = colours.cyan;

        if (
            this.mouseX < this.surface.textWidth(this.optionMenuEntry[i], 1) &&
            this.mouseY > i * 12 &&
            this.mouseY < 12 + i * 12
        ) {
            textColour = colours.red;
        }

        this.surface.drawString(
            this.optionMenuEntry[i],
            6,
            12 + i * 12,
            1,
            textColour
        );
    }
}

module.exports = { drawOptionMenu };

},{"../opcodes/client":54,"./_colours":75}],86:[function(require,module,exports){
const clientOpcodes = require('../opcodes/client');
const colours = require('./_colours');

const DARK_GREY = 0xb5b5b5;
const LIGHT_GREY = 0xc9c9c9;

const UI_X = 313;
const UI_Y = 36;
const WIDTH = 196;
const LINE_BREAK = 15;

function drawUiTabOptions(noMenus) {
    this.surface._drawSprite_from3(UI_X - 49, 3, this.spriteMedia + 6);

    this.surface.drawBoxAlpha(UI_X, 36, WIDTH, 65, DARK_GREY, 160);
    this.surface.drawBoxAlpha(UI_X, 101, WIDTH, 65, LIGHT_GREY, 160);
    this.surface.drawBoxAlpha(UI_X, 166, WIDTH, 95, DARK_GREY, 160);
    this.surface.drawBoxAlpha(UI_X, 261, WIDTH, 40, LIGHT_GREY, 160);

    const x = UI_X + 3;
    let y = UI_Y + LINE_BREAK;

    this.surface.drawString(
        'Game options - click to toggle',
        x,
        y,
        1,
        colours.black
    );

    y += LINE_BREAK;

    this.surface.drawString(
        'Camera angle mode - ' +
            (this.optionCameraModeAuto ? '@gre@Auto' : '@red@Manual'),
        x,
        y,
        1,
        colours.white
    );

    y += LINE_BREAK;

    this.surface.drawString(
        'Mouse buttons - ' +
            (this.optionMouseButtonOne ? '@red@One' : '@gre@Two'),
        x,
        y,
        1,
        colours.white
    );

    y += LINE_BREAK;

    if (this.members) {
        this.surface.drawString(
            'Sound effects - ' +
                (this.optionSoundDisabled ? '@red@off' : '@gre@on'),
            x,
            y,
            1,
            colours.white
        );
    }

    y += LINE_BREAK;

    if (this.options.accountManagement) {
        y += 5;

        this.surface.drawString('Security settings', x, y, 1, 0);

        y += LINE_BREAK;

        let textColour = 0xffffff;

        if (
            this.mouseX > x &&
            this.mouseX < x + WIDTH &&
            this.mouseY > y - 12 &&
            this.mouseY < y + 4
        ) {
            textColour = colours.yellow;
        }

        this.surface.drawString('Change password', x, y, 1, textColour);

        y += LINE_BREAK;
        textColour = 0xffffff;

        if (
            this.mouseX > x &&
            this.mouseX < x + WIDTH &&
            this.mouseY > y - 12 &&
            this.mouseY < y + 4
        ) {
            textColour = colours.yellow;
        }

        this.surface.drawString(
            'Change recovery questions',
            x,
            y,
            1,
            textColour
        );

        y += LINE_BREAK * 2;
    } else {
        this.surface.drawString(
            'To change your contact details,',
            x,
            y,
            0,
            colours.white
        );

        y += LINE_BREAK;

        this.surface.drawString(
            'password, recovery questions, etc..',
            x,
            y,
            0,
            colours.white
        );

        y += LINE_BREAK;

        this.surface.drawString(
            "please select 'account management'",
            x,
            y,
            0,
            colours.white
        );

        y += LINE_BREAK;

        if (this.referID === 0) {
            this.surface.drawString(
                'from the runescape.com front page',
                x,
                y,
                0,
                colours.white
            );
        } else if (this.referID === 1) {
            this.surface.drawString(
                'from the link below the gamewindow',
                x,
                y,
                0,
                colours.white
            );
        } else {
            this.surface.drawString(
                'from the runescape front webpage',
                x,
                y,
                0,
                colours.white
            );
        }

        y += LINE_BREAK + 5;
    }

    this.surface.drawString(
        'Privacy settings. Will be applied to',
        UI_X + 3,
        y,
        1,
        colours.black
    );

    y += LINE_BREAK;

    this.surface.drawString(
        'all people not on your friends list',
        UI_X + 3,
        y,
        1,
        colours.black
    );

    y += LINE_BREAK;

    this.surface.drawString(
        'Block chat messages: ' +
            (!this.settingsBlockChat ? '@red@<off>' : '@gre@<on>'),
        UI_X + 3,
        y,
        1,
        colours.white
    );

    y += LINE_BREAK;

    this.surface.drawString(
        'Block private messages: ' +
            (!this.settingsBlockPrivate ? '@red@<off>' : '@gre@<on>'),
        UI_X + 3,
        y,
        1,
        colours.white
    );

    y += LINE_BREAK;

    this.surface.drawString(
        'Block trade requests: ' +
            (!this.settingsBlockTrade ? '@red@<off>' : '@gre@<on>'),
        UI_X + 3,
        y,
        1,
        colours.white
    );

    y += LINE_BREAK;

    if (this.members) {
        this.surface.drawString(
            'Block duel requests: ' +
                (!this.settingsBlockDuel ? '@red@<off>' : '@gre@<on>'),
            UI_X + 3,
            y,
            1,
            colours.white
        );
    }

    y += LINE_BREAK + 5;

    this.surface.drawString(
        'Always logout when you finish',
        x,
        y,
        1,
        colours.black
    );

    y += LINE_BREAK;

    let textColour = colours.white;

    if (
        this.mouseX > x &&
        this.mouseX < x + WIDTH &&
        this.mouseY > y - 12 &&
        this.mouseY < y + 4
    ) {
        textColour = colours.yellow;
    }

    this.surface.drawString('Click here to logout', UI_X + 3, y, 1, textColour);

    if (!noMenus) {
        return;
    }

    const mouseX = this.mouseX - (this.surface.width2 - 199);
    const mouseY = this.mouseY - 36;

    if (mouseX >= 0 && mouseY >= 0 && mouseX < 196 && mouseY < 265) {
        const x = UI_X + 3;
        let y = UI_Y + 30;

        if (
            this.mouseX > x &&
            this.mouseX < x + WIDTH &&
            this.mouseY > y - 12 &&
            this.mouseY < y + 4 &&
            this.mouseButtonClick === 1
        ) {
            this.optionCameraModeAuto = !this.optionCameraModeAuto;
            this.packetStream.newPacket(clientOpcodes.SETTINGS_GAME);
            this.packetStream.putByte(0);
            this.packetStream.putByte(this.optionCameraModeAuto ? 1 : 0);
            this.packetStream.sendPacket();
        }

        y += LINE_BREAK;

        if (
            this.mouseX > x &&
            this.mouseX < x + WIDTH &&
            this.mouseY > y - 12 &&
            this.mouseY < y + 4 &&
            this.mouseButtonClick === 1
        ) {
            this.optionMouseButtonOne = !this.optionMouseButtonOne;
            this.packetStream.newPacket(clientOpcodes.SETTINGS_GAME);
            this.packetStream.putByte(2);
            this.packetStream.putByte(this.optionMouseButtonOne ? 1 : 0);
            this.packetStream.sendPacket();
        }

        y += LINE_BREAK;

        if (
            this.members &&
            this.mouseX > x &&
            this.mouseX < x + WIDTH &&
            this.mouseY > y - 12 &&
            this.mouseY < y + 4 &&
            this.mouseButtonClick === 1
        ) {
            this.optionSoundDisabled = !this.optionSoundDisabled;
            this.packetStream.newPacket(clientOpcodes.SETTINGS_GAME);
            this.packetStream.putByte(3);
            this.packetStream.putByte(this.optionSoundDisabled ? 1 : 0);
            this.packetStream.sendPacket();
        }

        if (this.options.accountManagement) {
            y += LINE_BREAK + 20;

            if (
                this.mouseX > x &&
                this.mouseX < x + WIDTH &&
                this.mouseY > y - 12 &&
                this.mouseY < y + 4 &&
                this.mouseButtonClick === 1
            ) {
                this.showChangePasswordStep = 6;
                this.inputTextCurrent = '';
                this.inputTextFinal = '';
            }

            y += LINE_BREAK;

            if (
                this.mouseX > x &&
                this.mouseX < x + WIDTH &&
                this.mouseY > y - 12 &&
                this.mouseY < y + 4 &&
                this.mouseButtonClick === 1
            ) {
                this.packetStream.newPacket(clientOpcodes.RECOVER_SET_REQUEST);
                this.packetStream.sendPacket();
            }

            y += LINE_BREAK * 2;
        } else {
            y += LINE_BREAK * 5;
        }

        let hasChangedSetting = false;

        y += 35;

        if (
            this.mouseX > x &&
            this.mouseX < x + WIDTH &&
            this.mouseY > y - 12 &&
            this.mouseY < y + 4 &&
            this.mouseButtonClick === 1
        ) {
            this.settingsBlockChat = 1 - this.settingsBlockChat;
            hasChangedSetting = true;
        }

        y += LINE_BREAK;

        if (
            this.mouseX > x &&
            this.mouseX < x + WIDTH &&
            this.mouseY > y - 12 &&
            this.mouseY < y + 4 &&
            this.mouseButtonClick === 1
        ) {
            this.settingsBlockPrivate = 1 - this.settingsBlockPrivate;
            hasChangedSetting = true;
        }

        y += LINE_BREAK;

        if (
            this.mouseX > x &&
            this.mouseX < x + WIDTH &&
            this.mouseY > y - 12 &&
            this.mouseY < y + 4 &&
            this.mouseButtonClick === 1
        ) {
            this.settingsBlockTrade = 1 - this.settingsBlockTrade;
            hasChangedSetting = true;
        }

        y += LINE_BREAK;

        if (
            this.members &&
            this.mouseX > x &&
            this.mouseX < x + WIDTH &&
            this.mouseY > y - 12 &&
            this.mouseY < y + 4 &&
            this.mouseButtonClick === 1
        ) {
            this.settingsBlockDuel = 1 - this.settingsBlockDuel;
            hasChangedSetting = true;
        }

        y += LINE_BREAK;

        if (hasChangedSetting) {
            this.sendPrivacySettings(
                this.settingsBlockChat,
                this.settingsBlockPrivate,
                this.settingsBlockTrade,
                this.settingsBlockDuel
            );
        }

        y += 20;

        if (
            this.mouseX > x &&
            this.mouseX < x + WIDTH &&
            this.mouseY > y - 12 &&
            this.mouseY < y + 4 &&
            this.mouseButtonClick === 1
        ) {
            this.sendLogout();
        }

        this.mouseButtonClick = 0;
    }
}

module.exports = { drawUiTabOptions };

},{"../opcodes/client":54,"./_colours":75}],87:[function(require,module,exports){
const colours = require('./_colours');

const DIALOG_X = 106;
const DIALOG_Y = 150;
const HEIGHT = 60;
const LINE_BREAK = 25;
const WIDTH = 300;

function drawDialogChangePassword() {
    if (this.mouseButtonClick !== 0) {
        this.mouseButtonClick = 0;

        if (
            this.mouseX < DIALOG_X ||
            this.mouseY < DIALOG_Y ||
            this.mouseX > WIDTH + DIALOG_X ||
            this.mouseY > HEIGHT + DIALOG_Y
        ) {
            this.showChangePasswordStep = 0;
            return;
        }
    }

    this.surface.drawBox(DIALOG_X, DIALOG_Y, WIDTH, HEIGHT, colours.black);
    this.surface.drawBoxEdge(DIALOG_X, DIALOG_Y, WIDTH, HEIGHT, colours.white);

    let y = DIALOG_Y + 22;
    let passwordInput = '';

    if (this.showChangePasswordStep === 6) {
        this.surface.drawStringCenter(
            'Please enter your current password',
            256,
            y,
            4,
            colours.white
        );

        y += LINE_BREAK;

        passwordInput = '*';

        for (let i = 0; i < this.inputTextCurrent.length; i++) {
            passwordInput = 'X' + passwordInput;
        }

        this.surface.drawStringCenter(passwordInput, 256, y, 4, colours.white);

        if (this.inputTextFinal.length > 0) {
            this.changePasswordOld = this.inputTextFinal;
            this.inputTextCurrent = '';
            this.inputTextFinal = '';
            this.showChangePasswordStep = 1;
            return;
        }
    } else if (this.showChangePasswordStep === 1) {
        this.surface.drawStringCenter(
            'Please enter your new password',
            256,
            y,
            4,
            colours.white
        );

        y += LINE_BREAK;

        passwordInput = '*';

        for (let i = 0; i < this.inputTextCurrent.length; i++) {
            passwordInput = 'X' + passwordInput;
        }

        this.surface.drawStringCenter(passwordInput, 256, y, 4, colours.white);

        if (this.inputTextFinal.length > 0) {
            this.changePasswordNew = this.inputTextFinal;
            this.inputTextCurrent = '';
            this.inputTextFinal = '';

            if (this.changePasswordNew.length >= 5) {
                this.showChangePasswordStep = 2;
                return;
            }

            this.showChangePasswordStep = 5;
            return;
        }
    } else if (this.showChangePasswordStep == 2) {
        this.surface.drawStringCenter(
            'Enter password again to confirm',
            256,
            y,
            4,
            colours.white
        );

        y += LINE_BREAK;

        passwordInput = '*';

        for (let i = 0; i < this.inputTextCurrent.length; ++i) {
            passwordInput = 'X' + passwordInput;
        }

        this.surface.drawStringCenter(passwordInput, 256, y, 4, colours.white);

        if (this.inputTextFinal.length > 0) {
            if (
                this.inputTextFinal.toLowerCase() ===
                this.changePasswordNew.toLowerCase()
            ) {
                this.showChangePasswordStep = 4;
                this.changePassword(
                    this.changePasswordOld,
                    this.changePasswordNew
                );
                return;
            }

            this.showChangePasswordStep = 3;
            return;
        }
    } else {
        if (this.showChangePasswordStep === 3) {
            this.surface.drawStringCenter(
                'Passwords do not match!',
                256,
                y,
                4,
                colours.white
            );

            y += LINE_BREAK;

            this.surface.drawStringCenter(
                'Press any key to close',
                256,
                y,
                4,
                colours.white
            );

            return;
        }

        if (this.showChangePasswordStep === 4) {
            this.surface.drawStringCenter(
                'Ok, your request has been sent',
                256,
                y,
                4,
                colours.white
            );

            y += LINE_BREAK;

            this.surface.drawStringCenter(
                'Press any key to close',
                256,
                y,
                4,
                colours.white
            );

            return;
        }

        if (this.showChangePasswordStep === 5) {
            this.surface.drawStringCenter(
                'Password must be at',
                256,
                y,
                4,
                colours.white
            );

            y += LINE_BREAK;

            this.surface.drawStringCenter(
                'least 5 letters long',
                256,
                y,
                4,
                colours.white
            );
        }
    }
}

module.exports = {
    drawDialogChangePassword,
    showChangePasswordStep: 0
};

},{"./_colours":75}],88:[function(require,module,exports){
const colours = require('./_colours');

const HEIGHT = 275;
const UI_X = 313;
const UI_Y = 36;
const WIDTH = 196;

const HALF_WIDTH = (WIDTH / 2) | 0;
const TABS = ['Stats', 'Quests'];
const TAB_HEIGHT = 24;

const SHORT_SKILL_NAMES = [
    'Attack',
    'Defense',
    'Strength',
    'Hits',
    'Ranged',
    'Prayer',
    'Magic',
    'Cooking',
    'Woodcut',
    'Fletching',
    'Fishing',
    'Firemaking',
    'Crafting',
    'Smithing',
    'Mining',
    'Herblaw',
    'Agility',
    'Thieving'
];

const SKILL_NAMES = [
    'Attack',
    'Defense',
    'Strength',
    'Hits',
    'Ranged',
    'Prayer',
    'Magic',
    'Cooking',
    'Woodcutting',
    'Fletching',
    'Fishing',
    'Firemaking',
    'Crafting',
    'Smithing',
    'Mining',
    'Herblaw',
    'Agility',
    'Thieving'
];

const EQUIPMENT_STAT_NAMES = [
    'Armour',
    'WeaponAim',
    'WeaponPower',
    'Magic',
    'Prayer'
];

const EXPERIENCE_ARRAY = [];

let totalExp = 0;

for (let i = 0; i < 99; i++) {
    const level = i + 1;
    const exp = (level + 300 * Math.pow(2, level / 7)) | 0;
    totalExp += exp;
    EXPERIENCE_ARRAY[i] = totalExp & 0xffffffc;
}

const FREE_QUESTS = [
    "Black knight's fortress",
    "Cook's assistant",
    'Demon slayer',
    "Doric's quest",
    'The restless ghost',
    'Goblin diplomacy',
    'Ernest the chicken',
    'Imp catcher',
    "Pirate's treasure",
    'Prince Ali rescue',
    'Romeo & Juliet',
    'Sheep shearer',
    'Shield of Arrav',
    "The knight's sword",
    'Vampire slayer',
    "Witch's potion",
    'Dragon slayer'
];

const MEMBERS_QUESTS = [
    "Witch's house",
    'Lost city',
    "Hero's quest",
    'Druidic ritual',
    "Merlin's crystal",
    'Scorpion catcher',
    'Family crest',
    'Tribal totem',
    'Fishing contest',
    "Monk's friend",
    'Temple of Ikov',
    'Clock tower',
    'The Holy Grail',
    'Fight Arena',
    'Tree Gnome Village',
    'The Hazeel Cult',
    'Sheep Herder',
    'Plague City',
    'Sea Slug',
    'Waterfall quest',
    'Biohazard',
    'Jungle potion',
    'Grand tree',
    'Shilo village',
    'Underground pass',
    'Observatory quest',
    'Tourist trap',
    'Watchtower',
    'Dwarf Cannon',
    'Murder Mystery',
    'Digsite',
    "Gertrude's Cat",
    "Legend's Quest"
].map((questName) => `${questName} (members)`);

const QUEST_NAMES = FREE_QUESTS.concat(MEMBERS_QUESTS);

function drawUiTabPlayerInfo(noMenus) {
    this.surface._drawSprite_from3(UI_X - 49, 3, this.spriteMedia + 3);

    this.surface.drawBoxAlpha(
        UI_X,
        UI_Y + TAB_HEIGHT,
        WIDTH,
        HEIGHT - TAB_HEIGHT,
        colours.lightGrey,
        128
    );
    this.surface.drawLineHoriz(UI_X, UI_Y + TAB_HEIGHT, WIDTH, colours.black);
    this.surface.drawTabs(
        UI_X,
        UI_Y,
        WIDTH,
        TAB_HEIGHT,
        TABS,
        this.uiTabPlayerInfoSubTab
    );

    // the handler for the Stats tab
    if (this.uiTabPlayerInfoSubTab === 0) {
        let y = 72;
        let selectedSkill = -1;

        this.surface.drawString('Skills', UI_X + 5, y, 3, colours.yellow);

        y += 13;

        // draw two columns with each skill name and current/base levels
        for (let i = 0; i < 9; i++) {
            // left column
            let textColour = colours.white;

            if (
                this.mouseX > UI_X + 3 &&
                this.mouseY >= y - 11 &&
                this.mouseY < y + 2 &&
                this.mouseX < UI_X + 90
            ) {
                textColour = colours.red;
                selectedSkill = i;
            }

            this.surface.drawString(
                `${SHORT_SKILL_NAMES[i]}:@yel@${this.playerStatCurrent[i]}/` +
                    this.playerStatBase[i],
                UI_X + 5,
                y,
                1,
                textColour
            );

            // right column
            textColour = colours.white;

            if (
                this.mouseX >= UI_X + 90 &&
                this.mouseY >= y - 13 - 11 &&
                this.mouseY < y - 13 + 2 &&
                this.mouseX < UI_X + 196
            ) {
                textColour = colours.red;
                selectedSkill = i + 9;
            }

            this.surface.drawString(
                `${SHORT_SKILL_NAMES[i + 9]}:@yel@` +
                    `${this.playerStatCurrent[i + 9]}/` +
                    this.playerStatBase[i + 9],
                UI_X + HALF_WIDTH - 5,
                y - 13,
                1,
                textColour
            );

            y += 13;
        }

        this.surface.drawString(
            `Quest Points:@yel@${this.playerQuestPoints}`,
            UI_X + HALF_WIDTH - 5,
            y - 13,
            1,
            colours.white
        );

        y += 12;

        this.surface.drawString(
            `Fatigue: @yel@${((this.statFatigue * 100) / 750) | 0}%`,
            UI_X + 5,
            y - 13,
            1,
            colours.white
        );

        y += 8;

        this.surface.drawString(
            'Equipment Status',
            UI_X + 5,
            y,
            3,
            colours.yellow
        );

        y += 12;

        for (let i = 0; i < 3; i++) {
            this.surface.drawString(
                `${EQUIPMENT_STAT_NAMES[i]}:@yel@` +
                    this.playerStatEquipment[i],
                UI_X + 5,
                y,
                1,
                colours.white
            );

            if (i < 2) {
                this.surface.drawString(
                    `${EQUIPMENT_STAT_NAMES[i + 3]}:@yel@` +
                        this.playerStatEquipment[i + 3],
                    UI_X + HALF_WIDTH + 25,
                    y,
                    1,
                    colours.white
                );
            }

            y += 13;
        }

        y += 6;

        this.surface.drawLineHoriz(UI_X, y - 15, WIDTH, colours.black);

        if (selectedSkill !== -1) {
            this.surface.drawString(
                `${SKILL_NAMES[selectedSkill]} skill`,
                UI_X + 5,
                y,
                1,
                colours.yellow
            );

            y += 12;

            let nextLevelAt = EXPERIENCE_ARRAY[0];

            for (let i = 0; i < 98; i++) {
                if (
                    this.playerExperience[selectedSkill] >= EXPERIENCE_ARRAY[i]
                ) {
                    nextLevelAt = EXPERIENCE_ARRAY[i + 1];
                }
            }

            this.surface.drawString(
                'Total xp: ' + ((this.playerExperience[selectedSkill] / 4) | 0),
                UI_X + 5,
                y,
                1,
                colours.white
            );
            y += 12;
            this.surface.drawString(
                'Next level at: ' + ((nextLevelAt / 4) | 0),
                UI_X + 5,
                y,
                1,
                colours.white
            );
        } else {
            this.surface.drawString(
                'Overall levels',
                UI_X + 5,
                y,
                1,
                colours.yellow
            );
            y += 12;

            let totalLevel = 0;

            for (let i = 0; i < SKILL_NAMES.length; i++) {
                totalLevel += this.playerStatBase[i];
            }

            this.surface.drawString(
                `Skill total: ${totalLevel}`,
                UI_X + 5,
                y,
                1,
                colours.white
            );

            y += 12;

            this.surface.drawString(
                `Combat level: ${this.localPlayer.level}`,
                UI_X + 5,
                y,
                1,
                colours.white
            );

            y += 12;
        }
    } else if (this.uiTabPlayerInfoSubTab === 1) {
        // the handler for the Quests tab
        this.panelQuestList.clearList(this.controlListQuest);
        this.panelQuestList.addListEntry(
            this.controlListQuest,
            0,
            '@whi@Quest-list (green=completed)'
        );

        for (let i = 0; i < QUEST_NAMES.length; i++) {
            this.panelQuestList.addListEntry(
                this.controlListQuest,
                i + 1,
                (this.questComplete[i] ? '@gre@' : '@red@') + QUEST_NAMES[i]
            );
        }

        this.panelQuestList.drawPanel();
    }

    if (!noMenus) {
        return;
    }

    const mouseX = this.mouseX - UI_X;
    const mouseY = this.mouseY - UI_Y;

    // handle clicking of Stats and Quest tab, and the scroll wheel for the
    // quest list
    if (mouseX >= 0 && mouseY >= 0 && mouseX < WIDTH && mouseY < HEIGHT) {
        if (this.uiTabPlayerInfoSubTab === 1) {
            this.panelQuestList.handleMouse(
                mouseX + UI_X,
                mouseY + UI_Y,
                this.lastMouseButtonDown,
                this.mouseButtonDown,
                this.mouseScrollDelta
            );
        }

        if (mouseY <= TAB_HEIGHT && this.mouseButtonClick === 1) {
            if (mouseX < HALF_WIDTH) {
                this.uiTabPlayerInfoSubTab = 0;
            } else if (mouseX > HALF_WIDTH) {
                this.uiTabPlayerInfoSubTab = 1;
            }
        }
    }
}

module.exports = {
    drawUiTabPlayerInfo,
    uiTabPlayerInfoSubTab: 0
};

},{"./_colours":75}],89:[function(require,module,exports){
const selectedRecoverQuestions = [];
selectedRecoverQuestions.length = 5;
selectedRecoverQuestions.fill(null);

module.exports = {
    selectedRecoverQuestions,
    selectedRecoverIDs: new Int32Array([0, 1, 2, 3, 4]),
    controlRecoverNewQuestions: new Int32Array(5),
    controlRecoverNewAnswers: new Int32Array(5),
    controlRecoverNewQuestionButtons: new Int32Array(5),
    controlRecoverCustomQuestionButtons: new Int32Array(5),
    controlRecoverCreateButton: 0
};

},{}],90:[function(require,module,exports){
const Utility = require('../utility');
const clientOpcodes = require('../opcodes/client');
const colours = require('./_colours');

const DIALOG_X = 56;
const DIALOG_Y = 35;
const HEIGHT = 290;
const LINE_BREAK = 15;
const WIDTH = 400;

const INPUT_DIALOG_Y = DIALOG_Y + 95;
const INPUT_HEIGHT = 100;

const RULES = [
    'Offensive language',
    'Item scamming',
    'Password scamming',
    'Bug abuse',
    'Jagex Staff impersonation',
    'Account sharing/trading',
    'Macroing',
    'Mutiple logging in',
    'Encouraging others to break rules',
    'Misuse of customer support',
    'Advertising / website',
    'Real world item trading'
];

function drawDialogReportAbuse() {
    this.reportAbuseOffence = 0;

    let y = 135;

    for (let i = 0; i < 12; i++) {
        if (
            this.mouseX > 66 &&
            this.mouseX < 446 &&
            this.mouseY >= y - 12 &&
            this.mouseY < y + 3
        ) {
            this.reportAbuseOffence = i + 1;
        }

        y += 14;
    }

    if (this.mouseButtonClick !== 0 && this.reportAbuseOffence !== 0) {
        this.mouseButtonClick = 0;
        this.showDialogReportAbuseStep = 2;
        this.inputTextCurrent = '';
        this.inputTextFinal = '';
        return;
    }

    y += LINE_BREAK;

    if (this.mouseButtonClick !== 0) {
        this.mouseButtonClick = 0;

        if (
            this.mouseX < DIALOG_X ||
            this.mouseY < DIALOG_Y ||
            this.mouseX > 456 ||
            this.mouseY > 325
        ) {
            this.showDialogReportAbuseStep = 0;
            return;
        }

        if (
            this.mouseX > 66 &&
            this.mouseX < 446 &&
            this.mouseY >= y - 15 &&
            this.mouseY < y + 5
        ) {
            this.showDialogReportAbuseStep = 0;
            return;
        }
    }

    this.surface.drawBox(DIALOG_X, DIALOG_Y, WIDTH, HEIGHT, colours.black);
    this.surface.drawBoxEdge(DIALOG_X, DIALOG_Y, WIDTH, HEIGHT, colours.white);

    y = 50;

    this.surface.drawStringCenter(
        'This form is for reporting players who are breaking our rules',
        256,
        y,
        1,
        colours.white
    );

    y += LINE_BREAK;

    this.surface.drawStringCenter(
        'Using it sends a snapshot of the last 60 secs of activity to us',
        256,
        y,
        1,
        colours.white
    );

    y += LINE_BREAK;

    this.surface.drawStringCenter(
        'If you misuse this form you will be banned',
        256,
        y,
        1,
        colours.orange
    );

    y += 25;

    this.surface.drawStringCenter(
        'First indicate which of our 12 rules is being broken. For a detailed',
        256,
        y,
        1,
        colours.yellow
    );

    y += LINE_BREAK;

    this.surface.drawStringCenter(
        'explanation of each rule please read the manual on our website.',
        256,
        y,
        1,
        colours.yellow
    );

    y += LINE_BREAK;

    for (let i = 1; i < RULES.length + 1; i += 1) {
        let textColour = colours.black;

        // draw the box that highlights the string
        if (this.reportAbuseOffence === i) {
            this.surface.drawBoxEdge(66, y - 12, 380, 15, colours.white);
            textColour = colours.orange;
        } else {
            textColour = colours.white;
        }

        const rule = RULES[i - 1];
        this.surface.drawStringCenter(`${i}: ${rule}`, 256, y, 1, textColour);
        y += 14;
    }

    y += LINE_BREAK;

    let textColour = colours.white;

    if (
        this.mouseX > 196 &&
        this.mouseX < 316 &&
        this.mouseY > y - 15 &&
        this.mouseY < y + 5
    ) {
        textColour = colours.yellow;
    }

    this.surface.drawStringCenter(
        'Click here to cancel',
        256,
        y,
        1,
        textColour
    );
}

function drawDialogReportAbuseInput() {
    if (this.inputTextFinal.length > 0) {
        const username = this.inputTextFinal.trim();

        this.inputTextCurrent = '';
        this.inputTextFinal = '';

        if (username.length > 0) {
            const encodedUsername = Utility.usernameToHash(username);

            this.packetStream.newPacket(clientOpcodes.REPORT_ABUSE);
            this.packetStream.putLong(encodedUsername);
            this.packetStream.putByte(this.reportAbuseOffence);
            this.packetStream.putByte(this.reportAbuseMute ? 1 : 0);
            this.packetStream.sendPacket();
        }

        this.showDialogReportAbuseStep = 0;
        return;
    }

    this.surface.drawBox(
        DIALOG_X,
        INPUT_DIALOG_Y,
        WIDTH,
        INPUT_HEIGHT,
        colours.black
    );

    this.surface.drawBoxEdge(
        DIALOG_X,
        INPUT_DIALOG_Y,
        WIDTH,
        INPUT_HEIGHT,
        colours.white
    );

    let y = INPUT_DIALOG_Y + 30;

    this.surface.drawStringCenter(
        'Now type the name of the offending player, and press enter',
        256,
        y,
        1,
        colours.yellow
    );

    y += 18;

    this.surface.drawStringCenter(
        `Name: ${this.inputTextCurrent}*`,
        256,
        y,
        4,
        colours.white
    );

    if (this.moderatorLevel > 0) {
        y = INPUT_DIALOG_Y + 77;

        let textColour = colours.white;
        let toggleText = 'OFF';

        if (this.reportAbuseMute) {
            textColour = colours.orange;
            toggleText = 'ON';
        }

        this.surface.drawStringCenter(
            `Moderator option: Mute player for 48 hours: <${toggleText}>`,
            256,
            y,
            1,
            textColour
        );

        if (
            this.mouseX > 106 &&
            this.mouseX < 406 &&
            this.mouseY > y - 13 &&
            this.mouseY < y + 2 &&
            this.mouseButtonClick === 1
        ) {
            this.mouseButtonClick = 0;
            this.reportAbuseMute = !this.reportAbuseMute;
        }
    }

    y = 222;

    let textColour = colours.white;

    if (
        this.mouseX > 196 &&
        this.mouseX < 316 &&
        this.mouseY > y - 13 &&
        this.mouseY < y + 2
    ) {
        textColour = colours.yellow;

        if (this.mouseButtonClick === 1) {
            this.mouseButtonClick = 0;
            this.showDialogReportAbuseStep = 0;
        }
    }

    this.surface.drawStringCenter(
        'Click here to cancel',
        256,
        y,
        1,
        textColour
    );

    if (
        this.mouseButtonClick === 1 &&
        (this.mouseX < DIALOG_X ||
            this.mouseX > 456 ||
            this.mouseY < 130 ||
            this.mouseY > 230)
    ) {
        this.mouseButtonClick = 0;
        this.showDialogReportAbuseStep = 0;
    }
}

module.exports = {
    drawDialogReportAbuse,
    drawDialogReportAbuseInput,
    reportAbuseMute: false,
    reportAbuseOffence: 0,
    showDialogReportAbuseStep: 0
};

},{"../opcodes/client":54,"../utility":100,"./_colours":75}],91:[function(require,module,exports){
const colours = require('./_colours');

const WIDTH = 400;

function drawDialogServerMessage() {
    let height = 100;

    if (this.serverMessageBoxTop) {
        height = 450;
        height = 300;
    }

    this.surface.drawBox(
        256 - ((WIDTH / 2) | 0),
        167 - ((height / 2) | 0),
        WIDTH,
        height,
        colours.black
    );

    this.surface.drawBoxEdge(
        256 - ((WIDTH / 2) | 0),
        167 - ((height / 2) | 0),
        WIDTH,
        height,
        colours.white
    );

    this.surface.drawParagraph(
        this.serverMessage,
        256,
        167 - ((height / 2) | 0) + 20,
        1,
        colours.white,
        WIDTH - 40
    );

    const offsetY = 157 + ((height / 2) | 0);
    let textColour = colours.white;

    if (
        this.mouseY > offsetY - 12 &&
        this.mouseY <= offsetY &&
        this.mouseX > 106 &&
        this.mouseX < 406
    ) {
        textColour = colours.red;
    }

    this.surface.drawStringCenter(
        'Click here to close window',
        256,
        offsetY,
        1,
        textColour
    );

    if (this.mouseButtonClick === 1) {
        if (textColour === colours.red) {
            this.showDialogServerMessage = false;
        }

        if (
            (this.mouseX < 256 - ((WIDTH / 2) | 0) ||
                this.mouseX > 256 + ((WIDTH / 2) | 0)) &&
            (this.mouseY < 167 - ((height / 2) | 0) ||
                this.mouseY > 167 + ((height / 2) | 0))
        ) {
            this.showDialogServerMessage = false;
        }
    }

    this.mouseButtonClick = 0;
}

module.exports = { drawDialogServerMessage };

},{"./_colours":75}],92:[function(require,module,exports){
const GameData = require('../game-data');
const clientOpcodes = require('../opcodes/client');
const colours = require('./_colours');

const COINS_ID = 10;

function drawDialogShop() {
    if (this.mouseButtonClick !== 0) {
        this.mouseButtonClick = 0;

        const mouseX = this.mouseX - 52;
        const mouseY = this.mouseY - 44;

        if (mouseX >= 0 && mouseY >= 12 && mouseX < 408 && mouseY < 246) {
            let itemIndex = 0;

            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 8; col++) {
                    const slotX = 7 + col * 49;
                    const slotY = 28 + row * 34;

                    if (
                        mouseX > slotX &&
                        mouseX < slotX + 49 &&
                        mouseY > slotY &&
                        mouseY < slotY + 34 &&
                        this.shopItem[itemIndex] !== -1
                    ) {
                        this.shopSelectedItemIndex = itemIndex;
                        this.shopSelectedItemType = this.shopItem[itemIndex];
                    }

                    itemIndex++;
                }
            }

            if (this.shopSelectedItemIndex >= 0) {
                const itemID = this.shopItem[this.shopSelectedItemIndex];

                if (itemID !== -1) {
                    if (
                        this.shopItemCount[this.shopSelectedItemIndex] > 0 &&
                        mouseX > 298 &&
                        mouseY >= 204 &&
                        mouseX < 408 &&
                        mouseY <= 215
                    ) {
                        let priceMod =
                            this.shopBuyPriceMod +
                            this.shopItemPrice[this.shopSelectedItemIndex];

                        if (priceMod < 10) {
                            priceMod = 10;
                        }

                        const itemPrice =
                            ((priceMod * GameData.itemBasePrice[itemID]) /
                                100) |
                            0;

                        this.packetStream.newPacket(clientOpcodes.SHOP_BUY);

                        this.packetStream.putShort(
                            this.shopItem[this.shopSelectedItemIndex]
                        );

                        this.packetStream.putInt(itemPrice);
                        this.packetStream.sendPacket();
                    }

                    if (
                        this.getInventoryCount(itemID) > 0 &&
                        mouseX > 2 &&
                        mouseY >= 229 &&
                        mouseX < 112 &&
                        mouseY <= 240
                    ) {
                        let priceMod =
                            this.shopSellPriceMod +
                            this.shopItemPrice[this.shopSelectedItemIndex];

                        if (priceMod < 10) {
                            priceMod = 10;
                        }

                        const itemPrice =
                            ((priceMod * GameData.itemBasePrice[itemID]) /
                                100) |
                            0;

                        this.packetStream.newPacket(clientOpcodes.SHOP_SELL);

                        this.packetStream.putShort(
                            this.shopItem[this.shopSelectedItemIndex]
                        );

                        this.packetStream.putInt(itemPrice);
                        this.packetStream.sendPacket();
                    }
                }
            }
        } else {
            this.packetStream.newPacket(clientOpcodes.SHOP_CLOSE);
            this.packetStream.sendPacket();
            this.showDialogShop = false;
            return;
        }
    }

    const dialogX = 52;
    const dialogY = 44;

    this.surface.drawBox(dialogX, dialogY, 408, 12, 192);

    this.surface.drawBoxAlpha(
        dialogX,
        dialogY + 12,
        408,
        17,
        colours.grey,
        160
    );

    this.surface.drawBoxAlpha(dialogX, dialogY + 29, 8, 170, colours.grey, 160);

    this.surface.drawBoxAlpha(
        dialogX + 399,
        dialogY + 29,
        9,
        170,
        colours.grey,
        160
    );

    this.surface.drawBoxAlpha(
        dialogX,
        dialogY + 199,
        408,
        47,
        colours.grey,
        160
    );

    this.surface.drawString(
        'Buying and selling items',
        dialogX + 1,
        dialogY + 10,
        1,
        colours.white
    );

    let textColour = colours.white;

    if (
        this.mouseX > dialogX + 320 &&
        this.mouseY >= dialogY &&
        this.mouseX < dialogX + 408 &&
        this.mouseY < dialogY + 12
    ) {
        textColour = colours.red;
    }

    this.surface.drawStringRight(
        'Close window',
        dialogX + 406,
        dialogY + 10,
        1,
        textColour
    );

    this.surface.drawString(
        'Shops stock in green',
        dialogX + 2,
        dialogY + 24,
        1,
        colours.green
    );

    this.surface.drawString(
        'Number you own in blue',
        dialogX + 135,
        dialogY + 24,
        1,
        colours.cyan
    );

    this.surface.drawString(
        `Your money: ${this.getInventoryCount(COINS_ID)}gp`,
        dialogX + 280,
        dialogY + 24,
        1,
        colours.yellow
    );

    let itemIndex = 0;

    for (let row = 0; row < 5; row++) {
        for (let col = 0; col < 8; col++) {
            const slotX = dialogX + 7 + col * 49;
            const slotY = dialogY + 28 + row * 34;

            if (this.shopSelectedItemIndex === itemIndex) {
                this.surface.drawBoxAlpha(
                    slotX,
                    slotY,
                    49,
                    34,
                    colours.red,
                    160
                );
            } else {
                this.surface.drawBoxAlpha(
                    slotX,
                    slotY,
                    49,
                    34,
                    colours.lightGrey2,
                    160
                );
            }

            this.surface.drawBoxEdge(slotX, slotY, 50, 35, 0);

            if (this.shopItem[itemIndex] !== -1) {
                this.surface._spriteClipping_from9(
                    slotX,
                    slotY,
                    48,
                    32,
                    this.spriteItem +
                        GameData.itemPicture[this.shopItem[itemIndex]],
                    GameData.itemMask[this.shopItem[itemIndex]],
                    0,
                    0,
                    false
                );

                this.surface.drawString(
                    this.shopItemCount[itemIndex].toString(),
                    slotX + 1,
                    slotY + 10,
                    1,
                    colours.green
                );

                this.surface.drawStringRight(
                    this.getInventoryCount(this.shopItem[itemIndex]).toString(),
                    slotX + 47,
                    slotY + 10,
                    1,
                    colours.cyan
                );
            }

            itemIndex++;
        }
    }

    this.surface.drawLineHoriz(dialogX + 5, dialogY + 222, 398, 0);

    if (this.shopSelectedItemIndex === -1) {
        this.surface.drawStringCenter(
            'Select an object to buy or sell',
            dialogX + 204,
            dialogY + 214,
            3,
            colours.yellow
        );

        return;
    }

    const selectedItemID = this.shopItem[this.shopSelectedItemIndex];

    if (selectedItemID !== -1) {
        if (this.shopItemCount[this.shopSelectedItemIndex] > 0) {
            let priceMod =
                this.shopBuyPriceMod +
                this.shopItemPrice[this.shopSelectedItemIndex];

            if (priceMod < 10) {
                priceMod = 10;
            }

            const itemPrice =
                ((priceMod * GameData.itemBasePrice[selectedItemID]) / 100) | 0;

            this.surface.drawString(
                `Buy a new ${GameData.itemName[selectedItemID]} for ` +
                    `${itemPrice}gp`,
                dialogX + 2,
                dialogY + 214,
                1,
                colours.yellow
            );

            textColour = colours.white;

            if (
                this.mouseX > dialogX + 298 &&
                this.mouseY >= dialogY + 204 &&
                this.mouseX < dialogX + 408 &&
                this.mouseY <= dialogY + 215
            ) {
                textColour = colours.red;
            }

            this.surface.drawStringRight(
                'Click here to buy',
                dialogX + 405,
                dialogY + 214,
                3,
                textColour
            );
        } else {
            this.surface.drawStringCenter(
                'This item is not currently available to buy',
                dialogX + 204,
                dialogY + 214,
                3,
                colours.yellow
            );
        }

        if (this.getInventoryCount(selectedItemID) > 0) {
            let priceMod =
                this.shopSellPriceMod +
                this.shopItemPrice[this.shopSelectedItemIndex];

            if (priceMod < 10) {
                priceMod = 10;
            }

            const itemPrice =
                ((priceMod * GameData.itemBasePrice[selectedItemID]) / 100) | 0;

            this.surface.drawStringRight(
                `Sell your ${GameData.itemName[selectedItemID]} for ` +
                    `${itemPrice}gp`,
                dialogX + 405,
                dialogY + 239,
                1,
                colours.yellow
            );

            textColour = colours.white;

            if (
                this.mouseX > dialogX + 2 &&
                this.mouseY >= dialogY + 229 &&
                this.mouseX < dialogX + 112 &&
                this.mouseY <= dialogY + 240
            ) {
                textColour = colours.red;
            }

            this.surface.drawString(
                'Click here to sell',
                dialogX + 2,
                dialogY + 239,
                3,
                textColour
            );

            return;
        }

        this.surface.drawStringCenter(
            'You do not have any of this item to sell',
            dialogX + 204,
            dialogY + 239,
            3,
            colours.yellow
        );
    }
}

module.exports = { drawDialogShop };

},{"../game-data":44,"../opcodes/client":54,"./_colours":75}],93:[function(require,module,exports){
const clientOpcodes = require('../opcodes/client');
const colours = require('./_colours');

function drawSleep() {
    this.surface.fadeToBlack();

    if (Math.random() <= 0.15) {
        this.surface.drawStringCenter(
            'ZZZ',
            (Math.random() * 80) | 0,
            (Math.random() * 334) | 0,
            5,
            (Math.random() * 16777215) | 0
        );
    }

    if (Math.random() <= 0.15) {
        this.surface.drawStringCenter(
            'ZZZ',
            512 - ((Math.random() * 80) | 0),
            (Math.random() * 334) | 0,
            5,
            (Math.random() * 16777215) | 0
        );
    }

    this.surface.drawBox(
        ((this.gameWidth / 2) | 0) - 100,
        160,
        200,
        40,
        colours.black
    );

    this.surface.drawStringCenter(
        'You are sleeping',
        (this.gameWidth / 2) | 0,
        50,
        7,
        colours.yellow
    );

    this.surface.drawStringCenter(
        `Fatigue: ${((this.fatigueSleeping * 100) / 750) | 0}%`,
        (this.gameWidth / 2) | 0,
        90,
        7,
        colours.yellow
    );

    this.surface.drawStringCenter(
        'When you want to wake up just use your',
        (this.gameWidth / 2) | 0,
        140,
        5,
        colours.white
    );

    this.surface.drawStringCenter(
        'keyboard to type the word in the box below',
        (this.gameWidth / 2) | 0,
        160,
        5,
        colours.white
    );

    this.surface.drawStringCenter(
        this.inputTextCurrent + '*',
        (this.gameWidth / 2) | 0,
        180,
        5,
        colours.cyan
    );

    if (this.sleepingStatusText === null) {
        this.surface._drawSprite_from3(
            ((this.gameWidth / 2) | 0) - 127,
            230,
            this.spriteTexture + 1
        );
    } else {
        this.surface.drawStringCenter(
            this.sleepingStatusText,
            (this.gameWidth / 2) | 0,
            260,
            5,
            colours.red
        );
    }

    this.surface.drawBoxEdge(
        ((this.gameWidth / 2) | 0) - 128,
        229,
        257,
        42,
        colours.white
    );

    this.drawChatMessageTabs();

    this.surface.drawStringCenter(
        "If you can't read the word",
        (this.gameWidth / 2) | 0,
        290,
        1,
        colours.white
    );

    this.surface.drawStringCenter(
        '@yel@click here@whi@ to get a different one',
        (this.gameWidth / 2) | 0,
        305,
        1,
        colours.white
    );

    this.surface.draw(this.graphics, 0, 0);
}

function handleSleepInput() {
    if (this.inputTextFinal.length > 0) {
        if (/^::lostcon$/i.test(this.inputTextFinal)) {
            this.packetStream.closeStream();
        } else if (/^::closecon$/.test(this.inputTextFinal)) {
            this.closeConnection();
        } else {
            this.packetStream.newPacket(clientOpcodes.SLEEP_WORD);
            this.packetStream.putString(this.inputTextFinal);

            if (!this.sleepWordDelay) {
                this.packetStream.putByte(0);
                this.sleepWordDelay = true;
            }

            this.packetStream.sendPacket();

            this.inputTextCurrent = '';
            this.inputTextFinal = '';
            this.sleepingStatusText = 'Please wait...';
        }
    }

    if (
        this.lastMouseButtonDown === 1 &&
        this.mouseY > 275 &&
        this.mouseY < 310 &&
        this.mouseX > 56 &&
        this.mouseX < 456
    ) {
        this.packetStream.newPacket(clientOpcodes.SLEEP_WORD);
        this.packetStream.putString('-null-');

        if (!this.sleepWordDelay) {
            this.packetStream.putByte(0);
            this.sleepWordDelay = true;
        }

        this.packetStream.sendPacket();

        this.inputTextCurrent = '';
        this.inputTextFinal = '';
        this.sleepingStatusText = 'Please wait...';
    }

    this.lastMouseButtonDown = 0;
}

module.exports = {
    drawSleep,
    handleSleepInput,
    isSleeping: false
};

},{"../opcodes/client":54,"./_colours":75}],94:[function(require,module,exports){
// dialog boxes for private messaging and ignore lists

const ChatMessage = require('../chat-message');
const Utility = require('../utility');
const WordFilter = require('../word-filter');
const colours = require('./_colours');

function drawDialogSocialInput() {
    if (this.mouseButtonClick !== 0) {
        this.mouseButtonClick = 0;

        if (
            this.showDialogSocialInput === 1 &&
            (this.mouseX < 106 ||
                this.mouseY < 145 ||
                this.mouseX > 406 ||
                this.mouseY > 215)
        ) {
            this.showDialogSocialInput = 0;
            return;
        }

        if (
            this.showDialogSocialInput === 2 &&
            (this.mouseX < 6 ||
                this.mouseY < 145 ||
                this.mouseX > 506 ||
                this.mouseY > 215)
        ) {
            this.showDialogSocialInput = 0;
            return;
        }

        if (
            this.showDialogSocialInput === 3 &&
            (this.mouseX < 106 ||
                this.mouseY < 145 ||
                this.mouseX > 406 ||
                this.mouseY > 215)
        ) {
            this.showDialogSocialInput = 0;
            return;
        }

        if (
            this.mouseX > 236 &&
            this.mouseX < 276 &&
            this.mouseY > 193 &&
            this.mouseY < 213
        ) {
            this.showDialogSocialInput = 0;
            return;
        }
    }

    let y = 145;

    if (this.showDialogSocialInput === 1) {
        this.surface.drawBox(106, y, 300, 70, 0);
        this.surface.drawBoxEdge(106, y, 300, 70, colours.white);
        y += 20;
        this.surface.drawStringCenter(
            'Enter name to add to friends list',
            256,
            y,
            4,
            colours.white
        );

        y += 20;

        this.surface.drawStringCenter(
            `${this.inputTextCurrent}*`,
            256,
            y,
            4,
            colours.white
        );

        if (this.inputTextFinal.length > 0) {
            const username = this.inputTextFinal.trim();
            const encodedUsername = Utility.usernameToHash(username);

            this.inputTextCurrent = '';
            this.inputTextFinal = '';
            this.showDialogSocialInput = 0;

            if (
                username.length > 0 &&
                !encodedUsername.equals(this.localPlayer.hash)
            ) {
                this.friendAdd(username);
            }
        }
    } else if (this.showDialogSocialInput === 2) {
        this.surface.drawBox(6, y, 500, 70, 0);
        this.surface.drawBoxEdge(6, y, 500, 70, colours.white);

        y += 20;

        const targetName = Utility.hashToUsername(this.privateMessageTarget);

        this.surface.drawStringCenter(
            `Enter message to send to ${targetName}`,
            256,
            y,
            4,
            colours.white
        );

        y += 20;

        this.surface.drawStringCenter(
            this.inputPMCurrent + '*',
            256,
            y,
            4,
            colours.white
        );

        if (this.inputPMFinal.length > 0) {
            let message = this.inputPMFinal;

            this.inputPMCurrent = '';
            this.inputPMFinal = '';
            this.showDialogSocialInput = 0;

            const length = ChatMessage.scramble(message);

            this.sendPrivateMessage(
                this.privateMessageTarget,
                ChatMessage.scrambledBytes,
                length
            );

            message = ChatMessage.descramble(
                ChatMessage.scrambledBytes,
                0,
                length
            );

            if (this.options.wordFilter) {
                message = WordFilter.filter(message);
            }

            this.showServerMessage(`@pri@You tell ${targetName}: ${message}`);
        }
    } else if (this.showDialogSocialInput === 3) {
        this.surface.drawBox(106, y, 300, 70, 0);
        this.surface.drawBoxEdge(106, y, 300, 70, colours.white);

        y += 20;

        this.surface.drawStringCenter(
            'Enter name to add to ignore list',
            256,
            y,
            4,
            colours.white
        );

        y += 20;

        this.surface.drawStringCenter(
            `${this.inputTextCurrent}*`,
            256,
            y,
            4,
            colours.white
        );

        if (this.inputTextFinal.length > 0) {
            const username = this.inputTextFinal.trim();
            const encodedUsername = Utility.usernameToHash(username);

            this.inputTextCurrent = '';
            this.inputTextFinal = '';
            this.showDialogSocialInput = 0;

            if (
                username.length > 0 &&
                !encodedUsername.equals(this.localPlayer.hash)
            ) {
                this.ignoreAdd(username);
            }
        }
    }

    let textColour = colours.white;

    if (
        this.mouseX > 236 &&
        this.mouseX < 276 &&
        this.mouseY > 193 &&
        this.mouseY < 213
    ) {
        textColour = colours.yellow;
    }

    this.surface.drawStringCenter('Cancel', 256, 208, 1, textColour);
}

function resetPMText() {
    this.inputPMCurrent = '';
    this.inputPMFinal = '';
}

module.exports = {
    drawDialogSocialInput,
    resetPMText,
    showDialogSocialInput: 0
};

},{"../chat-message":40,"../utility":100,"../word-filter":102,"./_colours":75}],95:[function(require,module,exports){
const Utility = require('../utility');
const colours = require('./_colours');

const HEIGHT = 182;
const UI_X = 313;
const UI_Y = 36;
const WIDTH = 196;
const HALF_WIDTH = (WIDTH / 2) | 0;

const TABS = ['Friends', 'Ignore'];
const TAB_HEIGHT = 24;

function drawUiTabSocial(noMenus) {
    this.surface._drawSprite_from3(UI_X - 49, 3, this.spriteMedia + 5);

    this.surface.drawBoxAlpha(
        UI_X,
        UI_Y + TAB_HEIGHT,
        WIDTH,
        HEIGHT - TAB_HEIGHT,
        colours.lightGrey,
        128
    );
    this.surface.drawLineHoriz(UI_X, UI_Y + HEIGHT - 16, WIDTH, colours.black);
    this.surface.drawTabs(
        UI_X,
        UI_Y,
        WIDTH,
        TAB_HEIGHT,
        TABS,
        this.uiTabSocialSubTab
    );

    this.panelSocialList.clearList(this.controlListSocialPlayers);

    if (this.uiTabSocialSubTab === 0) {
        for (let i = 0; i < this.friendListCount; i++) {
            let colour = null;

            if (this.friendListOnline[i] === 255) {
                colour = '@gre@';
            } else if (this.friendListOnline[i] > 0) {
                colour = '@yel@';
            } else {
                colour = '@red@';
            }

            this.panelSocialList.addListEntry(
                this.controlListSocialPlayers,
                i,
                colour +
                    Utility.hashToUsername(this.friendListHashes[i]) +
                    '~439~@whi@Remove         WWWWWWWWWW'
            );
        }
    } else if (this.uiTabSocialSubTab === 1) {
        for (let i = 0; i < this.ignoreListCount; i++) {
            this.panelSocialList.addListEntry(
                this.controlListSocialPlayers,
                i,
                '@yel@' +
                    Utility.hashToUsername(this.ignoreList[i]) +
                    '~439~@whi@Remove         WWWWWWWWWW'
            );
        }
    }

    this.panelSocialList.drawPanel();

    if (this.uiTabSocialSubTab === 0) {
        const friendIndex = this.panelSocialList.getListEntryIndex(
            this.controlListSocialPlayers
        );

        if (friendIndex >= 0 && this.mouseX < 489) {
            const username = Utility.hashToUsername(
                this.friendListHashes[friendIndex]
            );

            if (this.mouseX > 429) {
                this.surface.drawStringCenter(
                    `Click to remove ${username}`,
                    UI_X + HALF_WIDTH,
                    UI_Y + 35,
                    1,
                    colours.white
                );
            } else if (this.friendListOnline[friendIndex] === 255) {
                this.surface.drawStringCenter(
                    `Click to message ${username}`,
                    UI_X + HALF_WIDTH,
                    UI_Y + 35,
                    1,
                    colours.white
                );
            } else if (this.friendListOnline[friendIndex] > 0) {
                if (this.friendListOnline[friendIndex] < 200) {
                    this.surface.drawStringCenter(
                        `${username} is on world ` +
                            (this.friendListOnline[friendIndex] - 9),
                        UI_X + HALF_WIDTH,
                        UI_Y + 35,
                        1,
                        colours.white
                    );
                } else {
                    this.surface.drawStringCenter(
                        `${username} is on classic ` +
                            (this.friendListOnline[friendIndex] - 219),
                        UI_X + HALF_WIDTH,
                        UI_Y + 35,
                        1,
                        colours.white
                    );
                }
            } else {
                this.surface.drawStringCenter(
                    `${username} is offline`,
                    UI_X + HALF_WIDTH,
                    UI_Y + 35,
                    1,
                    colours.white
                );
            }
        } else {
            this.surface.drawStringCenter(
                'Click a name to send a message',
                UI_X + HALF_WIDTH,
                UI_Y + 35,
                1,
                colours.white
            );
        }

        let textColour = colours.black;

        if (
            this.mouseX > UI_X &&
            this.mouseX < UI_X + WIDTH &&
            this.mouseY > UI_Y + HEIGHT - 16 &&
            this.mouseY < UI_Y + HEIGHT
        ) {
            textColour = colours.yellow;
        } else {
            textColour = colours.white;
        }

        this.surface.drawStringCenter(
            'Click here to add a friend',
            UI_X + HALF_WIDTH,
            UI_Y + HEIGHT - 3,
            1,
            textColour
        );
    } else if (this.uiTabSocialSubTab === 1) {
        const ignoreIndex = this.panelSocialList.getListEntryIndex(
            this.controlListSocialPlayers
        );

        if (ignoreIndex >= 0 && this.mouseX < 489 && this.mouseX > 429) {
            if (this.mouseX > 429) {
                this.surface.drawStringCenter(
                    'Click to remove ' +
                        Utility.hashToUsername(this.ignoreList[ignoreIndex]),
                    UI_X + HALF_WIDTH,
                    UI_Y + 35,
                    1,
                    colours.white
                );
            }
        } else {
            this.surface.drawStringCenter(
                'Blocking messages from:',
                UI_X + HALF_WIDTH,
                UI_Y + 35,
                1,
                colours.white
            );
        }

        let textColour = colours.black;

        if (
            this.mouseX > UI_X &&
            this.mouseX < UI_X + WIDTH &&
            this.mouseY > UI_Y + HEIGHT - 16 &&
            this.mouseY < UI_Y + HEIGHT
        ) {
            textColour = colours.yellow;
        } else {
            textColour = colours.white;
        }

        this.surface.drawStringCenter(
            'Click here to add a name',
            UI_X + HALF_WIDTH,
            UI_Y + HEIGHT - 3,
            1,
            textColour
        );
    }

    if (!noMenus) {
        return;
    }

    const mouseX = this.mouseX - UI_X;
    const mouseY = this.mouseY - UI_Y;

    if (mouseX >= 0 && mouseY >= 0 && mouseX < WIDTH && mouseY < 182) {
        this.panelSocialList.handleMouse(
            mouseX + UI_X,
            mouseY + UI_Y,
            this.lastMouseButtonDown,
            this.mouseButtonDown,
            this.mouseScrollDelta
        );

        if (mouseY <= TAB_HEIGHT && this.mouseButtonClick === 1) {
            if (mouseX < HALF_WIDTH && this.uiTabSocialSubTab === 1) {
                this.uiTabSocialSubTab = 0;
                this.panelSocialList.resetListProps(
                    this.controlListSocialPlayers
                );
            } else if (mouseX > HALF_WIDTH && this.uiTabSocialSubTab === 0) {
                this.uiTabSocialSubTab = 1;
                this.panelSocialList.resetListProps(
                    this.controlListSocialPlayers
                );
            }
        }

        if (this.mouseButtonClick === 1 && this.uiTabSocialSubTab === 0) {
            const friendIndex = this.panelSocialList.getListEntryIndex(
                this.controlListSocialPlayers
            );

            if (friendIndex >= 0 && this.mouseX < 489) {
                if (this.mouseX > 429) {
                    this.friendRemove(this.friendListHashes[friendIndex]);
                } else if (this.friendListOnline[friendIndex] !== 0) {
                    this.showDialogSocialInput = 2;
                    this.privateMessageTarget = this.friendListHashes[
                        friendIndex
                    ];
                    this.inputPMCurrent = '';
                    this.inputPMFinal = '';
                }
            }
        }

        if (this.mouseButtonClick === 1 && this.uiTabSocialSubTab === 1) {
            const ignoreIndex = this.panelSocialList.getListEntryIndex(
                this.controlListSocialPlayers
            );

            if (ignoreIndex >= 0 && this.mouseX < 489 && this.mouseX > 429) {
                this.ignoreRemove(this.ignoreList[ignoreIndex]);
            }
        }

        if (mouseY > 166 && this.mouseButtonClick === 1) {
            this.inputTextCurrent = '';
            this.inputTextFinal = '';

            if (this.uiTabSocialSubTab === 0) {
                this.showDialogSocialInput = 1;
            } else if (this.uiTabSocialSubTab === 1) {
                this.showDialogSocialInput = 3;
            }
        }

        this.mouseButtonClick = 0;
    }
}

module.exports = {
    drawUiTabSocial,
    uiTabSocialSubTab: 0
};

},{"../utility":100,"./_colours":75}],96:[function(require,module,exports){
const GameData = require('../game-data');
const Utility = require('../utility');
const clientOpcodes = require('../opcodes/client');
const colours = require('./_colours');

const DIALOG_X = 22;
const DIALOG_Y = 36;

function drawDialogTradeConfirm() {
    this.surface.drawBox(DIALOG_X, DIALOG_Y, 468, 16, 192);

    this.surface.drawBoxAlpha(
        DIALOG_X,
        DIALOG_Y + 16,
        468,
        246,
        colours.grey,
        160
    );

    this.surface.drawStringCenter(
        'Please confirm your trade with @yel@' +
            Utility.hashToUsername(this.tradeRecipientConfirmHash),
        DIALOG_X + 234,
        DIALOG_Y + 12,
        1,
        colours.white
    );

    this.surface.drawStringCenter(
        'You are about to give:',
        DIALOG_X + 117,
        DIALOG_Y + 30,
        1,
        colours.yellow
    );

    for (let i = 0; i < this.tradeConfirmItemsCount; i++) {
        let itemLine = GameData.itemName[this.tradeConfirmItems[i]];

        if (GameData.itemStackable[this.tradeConfirmItems[i]] === 0) {
            itemLine +=
                ' x ' +
                Utility.formatConfirmAmount(this.tradeConfirmItemCount[i]);
        }

        this.surface.drawStringCenter(
            itemLine,
            DIALOG_X + 117,
            DIALOG_Y + 42 + i * 12,
            1,
            colours.white
        );
    }

    if (this.tradeConfirmItemsCount === 0) {
        this.surface.drawStringCenter(
            'Nothing!',
            DIALOG_X + 117,
            DIALOG_Y + 42,
            1,
            colours.white
        );
    }

    this.surface.drawStringCenter(
        'In return you will receive:',
        DIALOG_X + 351,
        DIALOG_Y + 30,
        1,
        colours.yellow
    );

    for (let i = 0; i < this.tradeRecipientConfirmItemsCount; i++) {
        let itemLine = GameData.itemName[this.tradeRecipientConfirmItems[i]];

        if (GameData.itemStackable[this.tradeRecipientConfirmItems[i]] === 0) {
            itemLine +=
                ' x ' +
                Utility.formatConfirmAmount(
                    this.tradeRecipientConfirmItemCount[i]
                );
        }

        this.surface.drawStringCenter(
            itemLine,
            DIALOG_X + 351,
            DIALOG_Y + 42 + i * 12,
            1,
            colours.white
        );
    }

    if (this.tradeRecipientConfirmItemsCount === 0) {
        this.surface.drawStringCenter(
            'Nothing!',
            DIALOG_X + 351,
            DIALOG_Y + 42,
            1,
            colours.white
        );
    }

    this.surface.drawStringCenter(
        'Are you sure you want to do this?',
        DIALOG_X + 234,
        DIALOG_Y + 200,
        4,
        colours.cyan
    );

    this.surface.drawStringCenter(
        'There is NO WAY to reverse a trade if you change your mind.',
        DIALOG_X + 234,
        DIALOG_Y + 215,
        1,
        colours.white
    );

    this.surface.drawStringCenter(
        'Remember that not all players are trustworthy',
        DIALOG_X + 234,
        DIALOG_Y + 230,
        1,
        colours.white
    );

    if (!this.tradeConfirmAccepted) {
        this.surface._drawSprite_from3(
            DIALOG_X + 118 - 35,
            DIALOG_Y + 238,
            this.spriteMedia + 25
        );

        this.surface._drawSprite_from3(
            DIALOG_X + 352 - 35,
            DIALOG_Y + 238,
            this.spriteMedia + 26
        );
    } else {
        this.surface.drawStringCenter(
            'Waiting for other player...',
            DIALOG_X + 234,
            DIALOG_Y + 250,
            1,
            colours.yellow
        );
    }

    if (this.mouseButtonClick === 1) {
        if (
            this.mouseX < DIALOG_X ||
            this.mouseY < DIALOG_Y ||
            this.mouseX > DIALOG_X + 468 ||
            this.mouseY > DIALOG_Y + 262
        ) {
            this.showDialogTradeConfirm = false;
            this.packetStream.newPacket(clientOpcodes.TRADE_DECLINE);
            this.packetStream.sendPacket();
        }

        if (
            this.mouseX >= DIALOG_X + 118 - 35 &&
            this.mouseX <= DIALOG_X + 118 + 70 &&
            this.mouseY >= DIALOG_Y + 238 &&
            this.mouseY <= DIALOG_Y + 238 + 21
        ) {
            this.tradeConfirmAccepted = true;
            this.packetStream.newPacket(clientOpcodes.TRADE_CONFIRM_ACCEPT);
            this.packetStream.sendPacket();
        }

        if (
            this.mouseX >= DIALOG_X + 352 - 35 &&
            this.mouseX <= DIALOG_X + 353 + 70 &&
            this.mouseY >= DIALOG_Y + 238 &&
            this.mouseY <= DIALOG_Y + 238 + 21
        ) {
            this.showDialogTradeConfirm = false;
            this.packetStream.newPacket(clientOpcodes.TRADE_DECLINE);
            this.packetStream.sendPacket();
        }

        this.mouseButtonClick = 0;
    }
}

module.exports = {
    drawDialogTradeConfirm,
    showDialogTradeConfirm: false
};

},{"../game-data":44,"../opcodes/client":54,"../utility":100,"./_colours":75}],97:[function(require,module,exports){
const GameData = require('../game-data');
const clientOpcodes = require('../opcodes/client');
const colours = require('./_colours');

const DIALOG_X = 22;
const DIALOG_Y = 36;

function drawDialogTrade() {
    if (
        this.mouseButtonClick !== 0 &&
        this.mouseButtonItemCountIncrement === 0
    ) {
        this.mouseButtonItemCountIncrement = 1;
    }

    if (this.mouseButtonItemCountIncrement > 0) {
        const mouseX = this.mouseX - 22;
        const mouseY = this.mouseY - 36;

        if (mouseX >= 0 && mouseY >= 0 && mouseX < 468 && mouseY < 262) {
            if (mouseX > 216 && mouseY > 30 && mouseX < 462 && mouseY < 235) {
                const slot =
                    (((mouseX - 217) / 49) | 0) +
                    (((mouseY - 31) / 34) | 0) * 5;

                if (slot >= 0 && slot < this.inventoryItemsCount) {
                    let sendUpdate = false;
                    let itemCountAdd = 0;

                    const itemType = this.inventoryItemId[slot];

                    for (let i = 0; i < this.tradeItemsCount; i++) {
                        if (this.tradeItems[i] === itemType) {
                            if (GameData.itemStackable[itemType] === 0) {
                                for (
                                    let j = 0;
                                    j < this.mouseButtonItemCountIncrement;
                                    j++
                                ) {
                                    if (
                                        this.tradeItemCount[i] <
                                        this.inventoryItemStackCount[slot]
                                    ) {
                                        this.tradeItemCount[i]++;
                                    }

                                    sendUpdate = true;
                                }
                            } else {
                                itemCountAdd++;
                            }
                        }
                    }

                    if (this.getInventoryCount(itemType) <= itemCountAdd) {
                        sendUpdate = true;
                    }

                    if (GameData.itemSpecial[itemType] === 1) {
                        this.showMessage(
                            'This object cannot be traded with other players',
                            3
                        );
                        sendUpdate = true;
                    }

                    if (!sendUpdate && this.tradeItemsCount < 12) {
                        this.tradeItems[this.tradeItemsCount] = itemType;
                        this.tradeItemCount[this.tradeItemsCount] = 1;
                        this.tradeItemsCount++;
                        sendUpdate = true;
                    }

                    if (sendUpdate) {
                        this.packetStream.newPacket(
                            clientOpcodes.TRADE_ITEM_UPDATE
                        );
                        this.packetStream.putByte(this.tradeItemsCount);

                        for (let j = 0; j < this.tradeItemsCount; j++) {
                            this.packetStream.putShort(this.tradeItems[j]);
                            this.packetStream.putInt(this.tradeItemCount[j]);
                        }

                        this.packetStream.sendPacket();
                        this.tradeRecipientAccepted = false;
                        this.tradeAccepted = false;
                    }
                }
            }

            if (mouseX > 8 && mouseY > 30 && mouseX < 205 && mouseY < 133) {
                const itemIndex =
                    (((mouseX - 9) / 49) | 0) + (((mouseY - 31) / 34) | 0) * 4;

                if (itemIndex >= 0 && itemIndex < this.tradeItemsCount) {
                    const itemType = this.tradeItems[itemIndex];

                    for (
                        let i = 0;
                        i < this.mouseButtonItemCountIncrement;
                        i++
                    ) {
                        if (
                            GameData.itemStackable[itemType] === 0 &&
                            this.tradeItemCount[itemIndex] > 1
                        ) {
                            this.tradeItemCount[itemIndex]--;
                            continue;
                        }
                        this.tradeItemsCount--;
                        this.mouseButtonDownTime = 0;

                        for (let j = itemIndex; j < this.tradeItemsCount; j++) {
                            this.tradeItems[j] = this.tradeItems[j + 1];
                            this.tradeItemCount[j] = this.tradeItemCount[j + 1];
                        }

                        break;
                    }

                    this.packetStream.newPacket(
                        clientOpcodes.TRADE_ITEM_UPDATE
                    );
                    this.packetStream.putByte(this.tradeItemsCount);

                    for (let i = 0; i < this.tradeItemsCount; i++) {
                        this.packetStream.putShort(this.tradeItems[i]);
                        this.packetStream.putInt(this.tradeItemCount[i]);
                    }

                    this.packetStream.sendPacket();
                    this.tradeRecipientAccepted = false;
                    this.tradeAccepted = false;
                }
            }

            if (
                mouseX >= 217 &&
                mouseY >= 238 &&
                mouseX <= 286 &&
                mouseY <= 259
            ) {
                this.tradeAccepted = true;
                this.packetStream.newPacket(clientOpcodes.TRADE_ACCEPT);
                this.packetStream.sendPacket();
            }

            if (
                mouseX >= 394 &&
                mouseY >= 238 &&
                mouseX < 463 &&
                mouseY < 259
            ) {
                this.showDialogTrade = false;
                this.packetStream.newPacket(clientOpcodes.TRADE_DECLINE);
                this.packetStream.sendPacket();
            }
        } else if (this.mouseButtonClick !== 0) {
            this.showDialogTrade = false;
            this.packetStream.newPacket(clientOpcodes.TRADE_DECLINE);
            this.packetStream.sendPacket();
        }

        this.mouseButtonClick = 0;
        this.mouseButtonItemCountIncrement = 0;
    }

    if (!this.showDialogTrade) {
        return;
    }

    this.surface.drawBox(DIALOG_X, DIALOG_Y, 468, 12, 192);

    this.surface.drawBoxAlpha(
        DIALOG_X,
        DIALOG_Y + 12,
        468,
        18,
        colours.grey,
        160
    );

    this.surface.drawBoxAlpha(
        DIALOG_X,
        DIALOG_Y + 30,
        8,
        248,
        colours.grey,
        160
    );

    this.surface.drawBoxAlpha(
        DIALOG_X + 205,
        DIALOG_Y + 30,
        11,
        248,
        colours.grey,
        160
    );

    this.surface.drawBoxAlpha(
        DIALOG_X + 462,
        DIALOG_Y + 30,
        6,
        248,
        colours.grey,
        160
    );

    this.surface.drawBoxAlpha(
        DIALOG_X + 8,
        DIALOG_Y + 133,
        197,
        22,
        colours.grey,
        160
    );

    this.surface.drawBoxAlpha(
        DIALOG_X + 8,
        DIALOG_Y + 258,
        197,
        20,
        colours.grey,
        160
    );

    this.surface.drawBoxAlpha(
        DIALOG_X + 216,
        DIALOG_Y + 235,
        246,
        43,
        colours.grey,
        160
    );

    this.surface.drawBoxAlpha(
        DIALOG_X + 8,
        DIALOG_Y + 30,
        197,
        103,
        colours.lightGrey2,
        160
    );

    this.surface.drawBoxAlpha(
        DIALOG_X + 8,
        DIALOG_Y + 155,
        197,
        103,
        colours.lightGrey2,
        160
    );

    this.surface.drawBoxAlpha(
        DIALOG_X + 216,
        DIALOG_Y + 30,
        246,
        205,
        colours.lightGrey2,
        160
    );

    for (let i = 0; i < 4; i++) {
        this.surface.drawLineHoriz(
            DIALOG_X + 8,
            DIALOG_Y + 30 + i * 34,
            197,
            colours.black
        );
    }

    for (let i = 0; i < 4; i++) {
        this.surface.drawLineHoriz(
            DIALOG_X + 8,
            DIALOG_Y + 155 + i * 34,
            197,
            colours.black
        );
    }

    for (let i = 0; i < 7; i++) {
        this.surface.drawLineHoriz(
            DIALOG_X + 216,
            DIALOG_Y + 30 + i * 34,
            246,
            colours.black
        );
    }

    for (let i = 0; i < 6; i++) {
        if (i < 5) {
            this.surface.drawLineVert(
                DIALOG_X + 8 + i * 49,
                DIALOG_Y + 30,
                103,
                colours.black
            );
            this.surface.drawLineVert(
                DIALOG_X + 8 + i * 49,
                DIALOG_Y + 155,
                103,
                colours.black
            );
        }

        this.surface.drawLineVert(
            DIALOG_X + 216 + i * 49,
            DIALOG_Y + 30,
            205,
            colours.black
        );
    }

    this.surface.drawString(
        'Trading with: ' + this.tradeRecipientName,
        DIALOG_X + 1,
        DIALOG_Y + 10,
        1,
        colours.white
    );

    this.surface.drawString(
        'Your Offer',
        DIALOG_X + 9,
        DIALOG_Y + 27,
        4,
        colours.white
    );

    this.surface.drawString(
        "Opponent's Offer",
        DIALOG_X + 9,
        DIALOG_Y + 152,
        4,
        colours.white
    );

    this.surface.drawString(
        'Your Inventory',
        DIALOG_X + 216,
        DIALOG_Y + 27,
        4,
        colours.white
    );

    if (!this.tradeAccepted) {
        this.surface._drawSprite_from3(
            DIALOG_X + 217,
            DIALOG_Y + 238,
            this.spriteMedia + 25
        );
    }

    this.surface._drawSprite_from3(
        DIALOG_X + 394,
        DIALOG_Y + 238,
        this.spriteMedia + 26
    );

    if (this.tradeRecipientAccepted) {
        this.surface.drawStringCenter(
            'Other player',
            DIALOG_X + 341,
            DIALOG_Y + 246,
            1,
            colours.white
        );

        this.surface.drawStringCenter(
            'has accepted',
            DIALOG_X + 341,
            DIALOG_Y + 256,
            1,
            colours.white
        );
    }

    if (this.tradeAccepted) {
        this.surface.drawStringCenter(
            'Waiting for',
            DIALOG_X + 217 + 35,
            DIALOG_Y + 246,
            1,
            colours.white
        );

        this.surface.drawStringCenter(
            'other player',
            DIALOG_X + 217 + 35,
            DIALOG_Y + 256,
            1,
            colours.white
        );
    }

    for (let i = 0; i < this.inventoryItemsCount; i++) {
        const slotX = 217 + DIALOG_X + (i % 5) * 49;
        const slotY = 31 + DIALOG_Y + ((i / 5) | 0) * 34;

        this.surface._spriteClipping_from9(
            slotX,
            slotY,
            48,
            32,
            this.spriteItem + GameData.itemPicture[this.inventoryItemId[i]],
            GameData.itemMask[this.inventoryItemId[i]],
            0,
            0,
            false
        );

        if (GameData.itemStackable[this.inventoryItemId[i]] === 0) {
            this.surface.drawString(
                this.inventoryItemStackCount[i].toString(),
                slotX + 1,
                slotY + 10,
                1,
                colours.yellow
            );
        }
    }

    for (let i = 0; i < this.tradeItemsCount; i++) {
        const slotX = 9 + DIALOG_X + (i % 4) * 49;
        const slotY = 31 + DIALOG_Y + ((i / 4) | 0) * 34;

        this.surface._spriteClipping_from9(
            slotX,
            slotY,
            48,
            32,
            this.spriteItem + GameData.itemPicture[this.tradeItems[i]],
            GameData.itemMask[this.tradeItems[i]],
            0,
            0,
            false
        );

        if (GameData.itemStackable[this.tradeItems[i]] === 0) {
            this.surface.drawString(
                this.tradeItemCount[i].toString(),
                slotX + 1,
                slotY + 10,
                1,
                colours.yellow
            );
        }

        if (
            this.mouseX > slotX &&
            this.mouseX < slotX + 48 &&
            this.mouseY > slotY &&
            this.mouseY < slotY + 32
        ) {
            this.surface.drawString(
                `${GameData.itemName[this.tradeItems[i]]}: @whi@` +
                    GameData.itemDescription[this.tradeItems[i]],
                DIALOG_X + 8,
                DIALOG_Y + 273,
                1,
                colours.yellow
            );
        }
    }

    for (let i = 0; i < this.tradeRecipientItemsCount; i++) {
        const slotX = 9 + DIALOG_X + (i % 4) * 49;
        const slotY = 156 + DIALOG_Y + ((i / 4) | 0) * 34;

        this.surface._spriteClipping_from9(
            slotX,
            slotY,
            48,
            32,
            this.spriteItem + GameData.itemPicture[this.tradeRecipientItems[i]],
            GameData.itemMask[this.tradeRecipientItems[i]],
            0,
            0,
            false
        );

        if (GameData.itemStackable[this.tradeRecipientItems[i]] === 0) {
            this.surface.drawString(
                this.tradeRecipientItemCount[i].toString(),
                slotX + 1,
                slotY + 10,
                1,
                colours.yellow
            );
        }

        if (
            this.mouseX > slotX &&
            this.mouseX < slotX + 48 &&
            this.mouseY > slotY &&
            this.mouseY < slotY + 32
        ) {
            this.surface.drawString(
                GameData.itemName[this.tradeRecipientItems[i]] +
                    ': @whi@' +
                    GameData.itemDescription[this.tradeRecipientItems[i]],
                DIALOG_X + 8,
                DIALOG_Y + 273,
                1,
                colours.yellow
            );
        }
    }
}

module.exports = {
    drawDialogTrade,
    showDialogTrade: false
};

},{"../game-data":44,"../opcodes/client":54,"./_colours":75}],98:[function(require,module,exports){
const colours = require('./_colours');

const WIDTH = 400;

function drawDialogWelcome() {
    let height = 65;

    if (this.welcomeRecoverySetDays !== 201) {
        height += 60;
    }

    if (this.welcomeUnreadMessages > 0) {
        height += 60;
    }

    if (this.welcomeLastLoggedInIP !== 0) {
        height += 45;
    }

    let y = 167 - ((height / 2) | 0);

    this.surface.drawBox(56, 167 - ((height / 2) | 0), WIDTH, height, 0);
    this.surface.drawBoxEdge(
        56,
        167 - ((height / 2) | 0),
        WIDTH,
        height,
        colours.white
    );

    y += 20;

    this.surface.drawStringCenter(
        'Welcome to RuneScape ' + this.loginUser,
        256,
        y,
        4,
        colours.yellow
    );

    y += 30;

    let daysAgo = null;

    if (this.welcomeLastLoggedInDays === 0) {
        daysAgo = 'earlier today';
    } else if (this.welcomeLastLoggedInDays === 1) {
        daysAgo = 'yesterday';
    } else {
        daysAgo = `${this.welcomeLastLoggedInDays} days ago`;
    }

    if (this.welcomeLastLoggedInIP !== 0) {
        this.surface.drawStringCenter(
            `You last logged in ${daysAgo}`,
            256,
            y,
            1,
            colours.white
        );

        y += 15;

        if (this.welcomeLastLoggedInHost === null) {
            this.welcomeLastLoggedInHost = this.getHostnameIP(
                this.welcomeLastLoggedInIP
            );
        }

        this.surface.drawStringCenter(
            'from: ' + this.welcomeLastLoggedInHost,
            256,
            y,
            1,
            colours.white
        );

        y += 15;
        y += 15;
    }

    if (this.welcomeUnreadMessages > 0) {
        const textColour = colours.white;

        this.surface.drawStringCenter(
            'Jagex staff will NEVER email you. We use the',
            256,
            y,
            1,
            textColour
        );

        y += 15;

        this.surface.drawStringCenter(
            'message-centre on this website instead.',
            256,
            y,
            1,
            textColour
        );

        y += 15;

        if (this.welcomeUnreadMessages === 1) {
            this.surface.drawStringCenter(
                'You have @yel@0@whi@ unread messages in your message-centre',
                256,
                y,
                1,
                colours.white
            );
        } else {
            this.surface.drawStringCenter(
                'You have @gre@' +
                    (this.welcomeUnreadMessages - 1) +
                    ' unread messages @whi@in your message-centre',
                256,
                y,
                1,
                colours.white
            );
        }

        y += 15;
        y += 15;
    }

    if (this.welcomeRecoverySetDays !== 201) {
        if (this.welcomeRecoverySetDays === 200) {
            this.surface.drawStringCenter(
                'You have not yet set any password recovery questions.',
                256,
                y,
                1,
                colours.orange
            );

            y += 15;

            this.surface.drawStringCenter(
                'We strongly recommend you do so now to secure your account.',
                256,
                y,
                1,
                colours.orange
            );

            y += 15;

            this.surface.drawStringCenter(
                "Do this from the 'account management' area on our front " +
                    'webpage',
                256,
                y,
                1,
                colours.orange
            );

            y += 15;
        } else {
            let daysAgo = null;

            if (this.welcomeRecoverySetDays === 0) {
                daysAgo = 'Earlier today';
            } else if (this.welcomeRecoverySetDays === 1) {
                daysAgo = 'Yesterday';
            } else {
                daysAgo = `${this.welcomeRecoverySetDays} days ago`;
            }

            this.surface.drawStringCenter(
                `${daysAgo} you changed your recovery questions`,
                256,
                y,
                1,
                colours.orange
            );

            y += 15;

            this.surface.drawStringCenter(
                'If you do not remember making this change then cancel it ' +
                    'immediately',
                256,
                y,
                1,
                colours.orange
            );

            y += 15;

            this.surface.drawStringCenter(
                "Do this from the 'account management' area on our front " +
                    'webpage',
                256,
                y,
                1,
                colours.orange
            );

            y += 15;
        }

        y += 15;
    }

    let textColour = colours.white;

    if (
        this.mouseY > y - 12 &&
        this.mouseY <= y &&
        this.mouseX > 106 &&
        this.mouseX < 406
    ) {
        textColour = colours.red;
    }

    this.surface.drawStringCenter(
        'Click here to close window',
        256,
        y,
        1,
        textColour
    );

    if (this.mouseButtonClick === 1) {
        if (textColour === colours.red) {
            this.showDialogWelcome = false;
        }

        if (
            (this.mouseX < 86 || this.mouseX > 426) &&
            (this.mouseY < 167 - ((height / 2) | 0) ||
                this.mouseY > 167 + ((height / 2) | 0))
        ) {
            this.showDialogWelcome = false;
        }
    }

    this.mouseButtonClick = 0;
}

module.exports = {
    drawDialogWelcome,
    showDialogWelcome: false
};

},{"./_colours":75}],99:[function(require,module,exports){
const colours = require('./_colours');

function drawDialogWildWarn() {
    let y = 97;

    this.surface.drawBox(86, 77, 340, 180, colours.black);
    this.surface.drawBoxEdge(86, 77, 340, 180, colours.white);

    this.surface.drawStringCenter(
        'Warning! Proceed with caution',
        256,
        y,
        4,
        colours.red
    );

    y += 26;

    this.surface.drawStringCenter(
        'If you go much further north you will ' + 'enter the',
        256,
        y,
        1,
        colours.white
    );

    y += 13;

    this.surface.drawStringCenter(
        'wilderness. This a very dangerous area where',
        256,
        y,
        1,
        colours.white
    );

    y += 13;

    this.surface.drawStringCenter(
        'other players can attack you!',
        256,
        y,
        1,
        colours.white
    );

    y += 22;

    this.surface.drawStringCenter(
        'The further north you go the more dangerous it',
        256,
        y,
        1,
        colours.white
    );

    y += 13;

    this.surface.drawStringCenter(
        'becomes, but the more treasure you will find.',
        256,
        y,
        1,
        colours.white
    );

    y += 22;

    this.surface.drawStringCenter(
        'In the wilderness an indicator at the bottom-right',
        256,
        y,
        1,
        colours.white
    );

    y += 13;

    this.surface.drawStringCenter(
        'of the screen will show the current level of danger',
        256,
        y,
        1,
        colours.white
    );

    y += 22;

    let textColour = colours.white;

    if (
        this.mouseY > y - 12 &&
        this.mouseY <= y &&
        this.mouseX > 181 &&
        this.mouseX < 331
    ) {
        textColour = colours.red;
    }

    this.surface.drawStringCenter(
        'Click here to close window',
        256,
        y,
        1,
        textColour
    );

    if (this.mouseButtonClick !== 0) {
        if (
            this.mouseY > y - 12 &&
            this.mouseY <= y &&
            this.mouseX > 181 &&
            this.mouseX < 331
        ) {
            this.showUiWildWarn = 2;
        }

        if (
            this.mouseX < 86 ||
            this.mouseX > 426 ||
            this.mouseY < 77 ||
            this.mouseY > 257
        ) {
            this.showUiWildWarn = 2;
        }

        this.mouseButtonClick = 0;
    }
}

module.exports = {
    showUiWildWarn: 0,
    drawDialogWildWarn
};

},{"./_colours":75}],100:[function(require,module,exports){
const BZLib = require('./bzlib');
const FileDownloadStream = require('./lib/net/file-download-stream');
const Long = require('long');

const C_0 = '0'.charCodeAt(0);
const C_9 = '9'.charCodeAt(0);
const C_A = 'a'.charCodeAt(0);
const C_BIG_A = 'A'.charCodeAt(0);
const C_BIG_Z = 'Z'.charCodeAt(0);
const C_Z = 'z'.charCodeAt(0);

class Utility {
    static openFile(s) {
        return new FileDownloadStream(s);
    }

    static getUnsignedByte(i) {
        return i & 0xff;
    }

    static getUnsignedShort(buffer, i) {
        return ((buffer[i] & 0xff) << 8) + (buffer[i + 1] & 0xff);
    }

    static getUnsignedInt(buffer, i) {
        return (
            ((buffer[i] & 0xff) << 24) +
            ((buffer[i + 1] & 0xff) << 16) +
            ((buffer[i + 2] & 0xff) << 8) +
            (buffer[i + 3] & 0xff)
        );
    }

    static getUnsignedLong(buffer, offset) {
        return Long.fromInt(Utility.getUnsignedInt(buffer, offset) & 0xffffffff)
            .shiftLeft(32)
            .add(
                new Long(
                    Utility.getUnsignedInt(buffer, offset + 4) & 0xffffffff
                )
            );
    }

    static getSignedShort(buffer, i) {
        let j =
            (Utility.getUnsignedByte(buffer[i]) * 256 +
                Utility.getUnsignedByte(buffer[i + 1])) |
            0;

        if (j > 32767) {
            j -= 0x10000;
        }

        return j;
    }

    static getStackInt(buffer, i) {
        if ((buffer[i] & 0xff) < 128) {
            return buffer[i];
        } else {
            return (
                (((buffer[i] & 0xff) - 128) << 24) +
                ((buffer[i + 1] & 0xff) << 16) +
                ((buffer[i + 2] & 0xff) << 8) +
                (buffer[i + 3] & 0xff)
            );
        }
    }

    static getBitMask(buffer, start, length) {
        let byteOffset = start >> 3;
        let bitOffset = 8 - (start & 7);
        let bits = 0;

        for (; length > bitOffset; bitOffset = 8) {
            bits +=
                (buffer[byteOffset++] & Utility.bitmask[bitOffset]) <<
                (length - bitOffset);
            length -= bitOffset;
        }

        if (length === bitOffset) {
            bits += buffer[byteOffset] & Utility.bitmask[bitOffset];
        } else {
            bits +=
                (buffer[byteOffset] >> (bitOffset - length)) &
                Utility.bitmask[length];
        }

        return bits;
    }

    static formatAuthString(raw, maxLength) {
        let formatted = '';

        for (let i = 0; i < maxLength; i++) {
            if (i >= raw.length) {
                formatted = formatted + ' ';
            } else {
                let charCode = raw.charCodeAt(i);

                if (charCode >= C_A && charCode <= C_Z) {
                    formatted = formatted + String.fromCharCode(charCode);
                } else if (charCode >= C_BIG_A && charCode <= C_BIG_Z) {
                    formatted = formatted + String.fromCharCode(charCode);
                } else if (charCode >= C_0 && charCode <= C_9) {
                    formatted = formatted + String.fromCharCode(charCode);
                } else {
                    formatted = formatted + '_';
                }
            }
        }

        return formatted;
    }

    static ipToString(ip) {
        return (
            ((ip >> 24) & 0xff) +
            '.' +
            ((ip >> 16) & 0xff) +
            '.' +
            ((ip >> 8) & 0xff) +
            '.' +
            (ip & 0xff)
        );
    }

    static usernameToHash(username) {
        let cleaned = '';

        for (let i = 0; i < username.length; i++) {
            let c = username.charCodeAt(i);

            if (c >= C_A && c <= C_Z) {
                cleaned = cleaned + String.fromCharCode(c);
            } else if (c >= C_BIG_A && c <= C_BIG_Z) {
                cleaned = cleaned + String.fromCharCode(c + 97 - 65);
            } else if (c >= C_0 && c <= C_9) {
                cleaned = cleaned + String.fromCharCode(c);
            } else {
                cleaned = cleaned + ' ';
            }
        }

        cleaned = cleaned.trim();

        if (cleaned.length > 12) {
            cleaned = cleaned.slice(0, 12);
        }

        let hash = new Long(0);

        for (let j = 0; j < cleaned.length; j++) {
            let charCode = cleaned.charCodeAt(j);

            hash = hash.multiply(37);

            if (charCode >= C_A && charCode <= C_Z) {
                hash = hash.add(1 + charCode - 97);
            } else if (charCode >= C_0 && charCode <= C_9) {
                hash = hash.add(27 + charCode - 48);
            }
        }

        return hash;
    }

    static hashToUsername(hash) {
        if (hash.lessThan(0)) {
            return 'invalidName';
        }

        let username = '';

        while (!hash.equals(0)) {
            let charCode = hash.modulo(37).toInt();
            hash = hash.divide(37);

            if (charCode === 0) {
                username = ' ' + username;
            } else if (charCode < 27) {
                if (hash.modulo(37).equals(0)) {
                    username =
                        String.fromCharCode(charCode + 65 - 1) + username;
                } else {
                    username =
                        String.fromCharCode(charCode + 97 - 1) + username;
                }
            } else {
                username = String.fromCharCode(charCode + 48 - 27) + username;
            }
        }

        return username;
    }

    static getDataFileOffset(fileName, data) {
        let numEntries = Utility.getUnsignedShort(data, 0);
        let wantedHash = 0;

        fileName = fileName.toUpperCase();

        for (let k = 0; k < fileName.length; k++) {
            wantedHash = ((wantedHash * 61) | 0) + fileName.charCodeAt(k) - 32;
        }

        let offset = 2 + numEntries * 10;

        for (let entry = 0; entry < numEntries; entry++) {
            let fileHash =
                ((data[entry * 10 + 2] & 0xff) * 0x1000000 +
                    (data[entry * 10 + 3] & 0xff) * 0x10000 +
                    (data[entry * 10 + 4] & 0xff) * 256 +
                    (data[entry * 10 + 5] & 0xff)) |
                0;

            let fileSize =
                ((data[entry * 10 + 9] & 0xff) * 0x10000 +
                    (data[entry * 10 + 10] & 0xff) * 256 +
                    (data[entry * 10 + 11] & 0xff)) |
                0;

            if (fileHash === wantedHash) {
                return offset;
            }

            offset += fileSize;
        }

        return 0;
    }

    static getDataFileLength(fileName, buffer) {
        const numEntries = Utility.getUnsignedShort(buffer, 0);
        let wantedHash = 0;

        fileName = fileName.toUpperCase();

        for (let i = 0; i < fileName.length; i++) {
            wantedHash = ((wantedHash * 61) | 0) + fileName.charCodeAt(i) - 32;
        }

        for (let i = 0; i < numEntries; i++) {
            let fileHash =
                ((buffer[i * 10 + 2] & 0xff) * 0x1000000 +
                    (buffer[i * 10 + 3] & 0xff) * 0x10000 +
                    (buffer[i * 10 + 4] & 0xff) * 256 +
                    (buffer[i * 10 + 5] & 0xff)) |
                0;

            let fileSize =
                ((buffer[i * 10 + 6] & 0xff) * 0x10000 +
                    (buffer[i * 10 + 7] & 0xff) * 256 +
                    (buffer[i * 10 + 8] & 0xff)) |
                0;

            if (fileHash === wantedHash) {
                return fileSize;
            }
        }

        return 0;
    }

    static loadData(fileName, extraSize, archiveData) {
        return Utility.unpackData(fileName, extraSize, archiveData, null);
    }

    static unpackData(fileName, extraSize, archiveData, fileData) {
        const numEntries =
            ((archiveData[0] & 0xff) * 256 + (archiveData[1] & 0xff)) | 0;
        let wantedHash = 0;

        fileName = fileName.toUpperCase();

        for (let l = 0; l < fileName.length; l++) {
            wantedHash = ((wantedHash * 61) | 0) + fileName.charCodeAt(l) - 32;
        }

        let offset = 2 + numEntries * 10;

        for (let entry = 0; entry < numEntries; entry++) {
            const fileHash =
                ((archiveData[entry * 10 + 2] & 0xff) * 0x1000000 +
                    (archiveData[entry * 10 + 3] & 0xff) * 0x10000 +
                    (archiveData[entry * 10 + 4] & 0xff) * 256 +
                    (archiveData[entry * 10 + 5] & 0xff)) |
                0;
            const fileSize =
                ((archiveData[entry * 10 + 6] & 0xff) * 0x10000 +
                    (archiveData[entry * 10 + 7] & 0xff) * 256 +
                    (archiveData[entry * 10 + 8] & 0xff)) |
                0;
            const fileSizeCompressed =
                ((archiveData[entry * 10 + 9] & 0xff) * 0x10000 +
                    (archiveData[entry * 10 + 10] & 0xff) * 256 +
                    (archiveData[entry * 10 + 11] & 0xff)) |
                0;

            if (fileHash === wantedHash) {
                if (fileData === null) {
                    fileData = new Int8Array(fileSize + extraSize);
                }

                if (fileSize !== fileSizeCompressed) {
                    BZLib.decompress(
                        fileData,
                        fileSize,
                        archiveData,
                        fileSizeCompressed,
                        offset
                    );
                } else {
                    for (let j = 0; j < fileSize; j++) {
                        fileData[j] = archiveData[offset + j];
                    }
                }

                return fileData;
            }

            offset += fileSizeCompressed;
        }

        return null;
    }

    static formatConfirmAmount(amount) {
        let formatted = amount.toString();

        for (let i = formatted.length - 3; i > 0; i -= 3) {
            formatted =
                formatted.substring(0, i) + ',' + formatted.substring(i);
        }

        if (formatted.length > 8) {
            formatted =
                `@gre@${formatted.substring(0, formatted.length - 8)}` +
                ` million @whi@(${formatted})`;
        } else if (formatted.length > 4) {
            formatted =
                `@cya@${formatted.substring(0, formatted.length - 4)}` +
                `K @whi@(${formatted})`;
        }

        return formatted;
    }
}

Utility.bitmask = new Int32Array([
    0,
    1,
    3,
    7,
    15,
    31,
    63,
    127,
    255,
    511,
    1023,
    2047,
    4095,
    8191,
    16383,
    32767,
    65535,
    0x1ffff,
    0x3ffff,
    0x7ffff,
    0xfffff,
    0x1fffff,
    0x3fffff,
    0x7fffff,
    0xffffff,
    0x1ffffff,
    0x3ffffff,
    0x7ffffff,
    0xfffffff,
    0x1fffffff,
    0x3fffffff,
    0x7fffffff,
    -1
]);

module.exports = Utility;

},{"./bzlib":39,"./lib/net/file-download-stream":51,"long":33}],101:[function(require,module,exports){
module.exports={
    "CLIENT": 204,
    "CONFIG": 85,
    "ENTITY": 24,
    "FILTER": 2,
    "FONTS": 1,
    "MAPS": 63,
    "MEDIA": 58,
    "MODELS": 36,
    "SOUNDS": 1,
    "TEXTURES": 17
}

},{}],102:[function(require,module,exports){
const C_0 = '0'.charCodeAt(0);
const C_9 = '9'.charCodeAt(0);
const C_A = 'a'.charCodeAt(0);
const C_ASTERISK = '*'.charCodeAt(0);
const C_BACKSLASH = '\\'.charCodeAt(0);
const C_BIG_A = 'A'.charCodeAt(0);
const C_BIG_Z = 'Z'.charCodeAt(0);
const C_COMMA = ','.charCodeAt(0);
const C_DOT = '.'.charCodeAt(0);
const C_J = 'j'.charCodeAt(0);
const C_Q = 'q'.charCodeAt(0);
const C_SINGLE_QUOTE = "'".charCodeAt(0);
const C_SLASH = '/'.charCodeAt(0);
const C_SPACE = ' '.charCodeAt(0);
const C_V = 'v'.charCodeAt(0);
const C_X = 'x'.charCodeAt(0);
const C_Z = 'z'.charCodeAt(0);

function toCharArray(s) {
    let a = new Uint16Array(s.length);

    for (let i = 0; i < s.length; i += 1) {
        a[i] = s.charCodeAt(i);
    }

    return a;
}

function fromCharArray(a) {
    return Array.from(a)
        .map((c) => String.fromCharCode(c))
        .join('');
}

class WordFilter {
    static loadFilters(fragments, bad, host, tld) {
        WordFilter.loadBad(bad);
        WordFilter.loadHost(host);
        WordFilter.loadFragments(fragments);
        WordFilter.loadTld(tld);
    }

    static loadTld(buffer) {
        let wordCount = buffer.getUnsignedInt();

        WordFilter.tldList = [];
        WordFilter.tldType = new Int32Array(wordCount);

        for (let i = 0; i < wordCount; i++) {
            WordFilter.tldType[i] = buffer.getUnsignedByte();

            let ac = new Uint16Array(buffer.getUnsignedByte());

            for (let j = 0; j < ac.length; j++) {
                ac[j] = buffer.getUnsignedByte();
            }

            WordFilter.tldList.push(ac);
        }
    }

    static loadBad(buffer) {
        let wordCount = buffer.getUnsignedInt();

        WordFilter.badList = [];
        WordFilter.badList.length = wordCount;
        WordFilter.badList.fill(null);
        WordFilter.badCharIds = [];
        WordFilter.badCharIds.length = wordCount;
        WordFilter.badCharIds.fill(null);

        WordFilter.readBuffer(
            buffer,
            WordFilter.badList,
            WordFilter.badCharIds
        );
    }

    static loadHost(buffer) {
        let wordCount = buffer.getUnsignedInt();

        WordFilter.hostList = [];
        WordFilter.hostList.length = wordCount;
        WordFilter.hostList.fill(null);
        WordFilter.hostCharIds = [];
        WordFilter.hostCharIds.length = wordCount;
        WordFilter.hostCharIds.fill(null);

        WordFilter.readBuffer(
            buffer,
            WordFilter.hostList,
            WordFilter.hostCharIds
        );
    }

    static loadFragments(buffer) {
        WordFilter.hashFragments = new Int32Array(buffer.getUnsignedInt());

        for (let i = 0; i < WordFilter.hashFragments.length; i++) {
            WordFilter.hashFragments[i] = buffer.getUnsignedShort();
        }
    }

    static readBuffer(buffer, wordList, charIds) {
        for (let i = 0; i < wordList.length; i++) {
            let currentWord = new Uint16Array(buffer.getUnsignedByte());

            for (let j = 0; j < currentWord.length; j++) {
                currentWord[j] = buffer.getUnsignedByte();
            }

            wordList[i] = currentWord;

            let ids = [];
            ids.length = buffer.getUnsignedInt();

            for (let j = 0; j < ids.length; j++) {
                ids[j] = [
                    buffer.getUnsignedByte() & 0xff,
                    buffer.getUnsignedByte() & 0xff
                ];
            }

            if (ids.length > 0) {
                charIds[i] = ids;
            }
        }
    }

    static filter(input) {
        let inputChars = toCharArray(input.toLowerCase());

        WordFilter.applyDotSlashFilter(inputChars);
        WordFilter.applyBadwordFilter(inputChars);
        WordFilter.applyHostFilter(inputChars);
        WordFilter.heywhathteufck(inputChars);

        for (
            let ignoreIdx = 0;
            ignoreIdx < WordFilter.ignoreList.length;
            ignoreIdx++
        ) {
            for (
                let inputIgnoreIdx = -1;
                (inputIgnoreIdx = input.indexOf(
                    WordFilter.ignoreList[ignoreIdx],
                    inputIgnoreIdx + 1
                )) !== -1;

            ) {
                let ignoreWordChars = toCharArray(
                    WordFilter.ignoreList[ignoreIdx]
                );

                for (
                    let ignorewordIdx = 0;
                    ignorewordIdx < ignoreWordChars.length;
                    ignorewordIdx++
                ) {
                    inputChars[ignorewordIdx + inputIgnoreIdx] =
                        ignoreWordChars[ignorewordIdx];
                }
            }
        }

        if (WordFilter.forceLowerCase) {
            WordFilter.stripLowerCase(toCharArray(input), inputChars);
            WordFilter.toLowerCase(inputChars);
        }

        return fromCharArray(inputChars);
    }

    static stripLowerCase(input, output) {
        for (let i = 0; i < input.length; i++) {
            if (output[i] !== C_ASTERISK && WordFilter.isUpperCase(input[i])) {
                output[i] = input[i];
            }
        }
    }

    static toLowerCase(input) {
        let isUpperCase = true;

        for (let i = 0; i < input.length; i++) {
            let current = input[i];

            if (WordFilter.isLetter(current)) {
                if (isUpperCase) {
                    if (WordFilter.isLowerCase(current)) {
                        isUpperCase = false;
                    }
                } else if (WordFilter.isUpperCase(current)) {
                    input[i] = current + 97 - 65;
                }
            } else {
                isUpperCase = true;
            }
        }
    }

    static applyBadwordFilter(input) {
        for (let i = 0; i < 2; i++) {
            for (let j = WordFilter.badList.length - 1; j >= 0; j--) {
                WordFilter.applyWordFilter(
                    input,
                    WordFilter.badList[j],
                    WordFilter.badCharIds[j]
                );
            }
        }
    }

    static applyHostFilter(input) {
        for (let i = WordFilter.hostList.length - 1; i >= 0; i--) {
            WordFilter.applyWordFilter(
                input,
                WordFilter.hostList[i],
                WordFilter.hostCharIds[i]
            );
        }
    }

    static applyDotSlashFilter(input) {
        let input1 = input.slice();
        let dot = toCharArray('dot');
        WordFilter.applyWordFilter(input1, dot, null);

        let input2 = input.slice();
        let slash = toCharArray('slash');
        WordFilter.applyWordFilter(input2, slash, null);

        for (let i = 0; i < WordFilter.tldList.length; i++) {
            WordFilter.applyTldFilter(
                input,
                input1,
                input2,
                WordFilter.tldList[i],
                WordFilter.tldType[i]
            );
        }
    }

    static applyTldFilter(input, input1, input2, tld, type) {
        if (tld.length > input.length) {
            return;
        }

        for (
            let charIndex = 0;
            charIndex <= input.length - tld.length;
            charIndex++
        ) {
            let inputCharCount = charIndex;
            let l = 0;

            while (inputCharCount < input.length) {
                let i1 = 0;
                let current = input[inputCharCount];
                let next = 0;

                if (inputCharCount + 1 < input.length) {
                    next = input[inputCharCount + 1];
                }

                if (
                    l < tld.length &&
                    (i1 = WordFilter.compareLettersNumbers(
                        tld[l],
                        current,
                        next
                    )) > 0
                ) {
                    inputCharCount += i1;
                    l++;
                    continue;
                }

                if (l === 0) {
                    break;
                }

                if (
                    (i1 = WordFilter.compareLettersNumbers(
                        tld[l - 1],
                        current,
                        next
                    )) > 0
                ) {
                    inputCharCount += i1;
                    continue;
                }

                if (l >= tld.length || !WordFilter.isSpecial(current)) {
                    break;
                }

                inputCharCount++;
            }

            if (l >= tld.length) {
                let flag = false;
                let startMatch = WordFilter.getAsteriskCount(
                    input,
                    input1,
                    charIndex
                );
                let endMatch = WordFilter.getAsteriskCount2(
                    input,
                    input2,
                    inputCharCount - 1
                );

                if (WordFilter.DEBUGTLD) {
                    console.log(
                        `Potential tld: ${tld} at char ${charIndex} ` +
                            `(type="${type}, startmatch="${startMatch}, ` +
                            `endmatch=${endMatch})`
                    );
                }

                if (type === 1 && startMatch > 0 && endMatch > 0) {
                    flag = true;
                }

                if (
                    type === 2 &&
                    ((startMatch > 2 && endMatch > 0) ||
                        (startMatch > 0 && endMatch > 2))
                ) {
                    flag = true;
                }

                if (type === 3 && startMatch > 0 && endMatch > 2) {
                    flag = true;
                }

                if (flag) {
                    if (WordFilter.DEBUGTLD) {
                        console.log(
                            `Filtered tld: ${tld} at char ${charIndex}`
                        );
                    }

                    let l1 = charIndex;
                    let i2 = inputCharCount - 1;

                    if (startMatch > 2) {
                        if (startMatch === 4) {
                            let flag1 = false;

                            for (let k2 = l1 - 1; k2 >= 0; k2--) {
                                if (flag1) {
                                    if (input1[k2] !== C_ASTERISK) {
                                        break;
                                    }

                                    l1 = k2;
                                } else if (input1[k2] === C_ASTERISK) {
                                    l1 = k2;
                                    flag1 = true;
                                }
                            }
                        }

                        let flag2 = false;

                        for (let l2 = l1 - 1; l2 >= 0; l2--) {
                            if (flag2) {
                                if (WordFilter.isSpecial(input[l2])) {
                                    break;
                                }

                                l1 = l2;
                            } else if (!WordFilter.isSpecial(input[l2])) {
                                flag2 = true;
                                l1 = l2;
                            }
                        }
                    }

                    if (endMatch > 2) {
                        if (endMatch === 4) {
                            let flag3 = false;

                            for (let i3 = i2 + 1; i3 < input.length; i3++) {
                                if (flag3) {
                                    if (input2[i3] !== C_ASTERISK) {
                                        break;
                                    }

                                    i2 = i3;
                                } else if (input2[i3] === C_ASTERISK) {
                                    i2 = i3;
                                    flag3 = true;
                                }
                            }
                        }

                        let flag4 = false;

                        for (let j3 = i2 + 1; j3 < input.length; j3++) {
                            if (flag4) {
                                if (WordFilter.isSpecial(input[j3])) {
                                    break;
                                }

                                i2 = j3;
                            } else if (!WordFilter.isSpecial(input[j3])) {
                                flag4 = true;
                                i2 = j3;
                            }
                        }
                    }

                    for (let j2 = l1; j2 <= i2; j2++) {
                        input[j2] = C_ASTERISK;
                    }
                }
            }
        }
    }

    static getAsteriskCount(input, input1, len) {
        if (len === 0) {
            return 2;
        }

        for (let j = len - 1; j >= 0; j--) {
            if (!WordFilter.isSpecial(input[j])) {
                break;
            }

            if (input[j] === C_COMMA || input[j] === C_DOT) {
                return 3;
            }
        }

        let filtered = 0;

        for (let l = len - 1; l >= 0; l--) {
            if (!WordFilter.isSpecial(input1[l])) {
                break;
            }

            if (input1[l] === C_ASTERISK) {
                filtered++;
            }
        }

        if (filtered >= 3) {
            return 4;
        }

        return WordFilter.isSpecial(input[len - 1]) ? 1 : 0;
    }

    static getAsteriskCount2(input, input1, len) {
        if (len + 1 === input.length) {
            return 2;
        }

        for (let j = len + 1; j < input.length; j++) {
            if (!WordFilter.isSpecial(input[j])) {
                break;
            }

            if (input[j] === C_BACKSLASH || input[j] === C_SLASH) {
                return 3;
            }
        }

        let filtered = 0;

        for (let l = len + 1; l < input.length; l++) {
            if (!WordFilter.isSpecial(input1[l])) {
                break;
            }

            if (input1[l] === C_ASTERISK) {
                filtered++;
            }
        }

        if (filtered >= 5) {
            return 4;
        }

        return WordFilter.isSpecial(input[len + 1]) ? 1 : 0;
    }

    static applyWordFilter(input, wordList, charIds) {
        if (wordList.length > input.length) {
            return;
        }

        for (
            let charIndex = 0;
            charIndex <= input.length - wordList.length;
            charIndex++
        ) {
            let inputCharCount = charIndex;
            let k = 0;
            let specialChar = false;

            while (inputCharCount < input.length) {
                let l = 0;
                let inputChar = input[inputCharCount];
                let nextChar = 0;

                if (inputCharCount + 1 < input.length) {
                    nextChar = input[inputCharCount + 1];
                }

                if (
                    k < wordList.length &&
                    (l = WordFilter.compareLettersSymbols(
                        wordList[k],
                        inputChar,
                        nextChar
                    )) > 0
                ) {
                    inputCharCount += l;
                    k++;
                    continue;
                }

                if (k === 0) {
                    break;
                }

                if (
                    (l = WordFilter.compareLettersSymbols(
                        wordList[k - 1],
                        inputChar,
                        nextChar
                    )) > 0
                ) {
                    inputCharCount += l;
                    continue;
                }

                if (
                    k >= wordList.length ||
                    !WordFilter.isNotLowerCase(inputChar)
                ) {
                    break;
                }

                if (
                    WordFilter.isSpecial(inputChar) &&
                    inputChar !== C_SINGLE_QUOTE
                ) {
                    specialChar = true;
                }

                inputCharCount++;
            }

            if (k >= wordList.length) {
                let filter = true;

                if (WordFilter.DEBUGTLD) {
                    console.log(
                        `Potential word: ${wordList} at char ${charIndex}`
                    );
                }

                if (!specialChar) {
                    let prevChar = C_SPACE;

                    if (charIndex - 1 >= 0) {
                        prevChar = input[charIndex - 1];
                    }

                    let curChar = C_SPACE;

                    if (inputCharCount < input.length) {
                        curChar = input[inputCharCount];
                    }

                    let prevId = WordFilter.getCharId(prevChar);
                    let curId = WordFilter.getCharId(curChar);

                    if (
                        charIds &&
                        WordFilter.compareCharIds(charIds, prevId, curId)
                    ) {
                        filter = false;
                    }
                } else {
                    let flag2 = false;
                    let flag3 = false;

                    if (
                        charIndex - 1 < 0 ||
                        (WordFilter.isSpecial(input[charIndex - 1]) &&
                            input[charIndex - 1] !== C_SINGLE_QUOTE)
                    ) {
                        flag2 = true;
                    }

                    if (
                        inputCharCount >= input.length ||
                        (WordFilter.isSpecial(input[inputCharCount]) &&
                            input[inputCharCount] !== C_SINGLE_QUOTE)
                    ) {
                        flag3 = true;
                    }

                    if (!flag2 || !flag3) {
                        let flag4 = false;
                        let j1 = charIndex - 2;

                        if (flag2) {
                            j1 = charIndex;
                        }

                        for (; !flag4 && j1 < inputCharCount; j1++) {
                            if (
                                j1 >= 0 &&
                                (!WordFilter.isSpecial(input[j1]) ||
                                    input[j1] === C_SINGLE_QUOTE)
                            ) {
                                let ac2 = new Uint16Array(3);
                                let k1;

                                for (k1 = 0; k1 < 3; k1++) {
                                    if (
                                        j1 + k1 >= input.length ||
                                        (WordFilter.isSpecial(input[j1 + k1]) &&
                                            input[j1 + k1] !== C_SINGLE_QUOTE)
                                    ) {
                                        break;
                                    }

                                    ac2[k1] = input[j1 + k1];
                                }

                                let flag5 = true;

                                if (k1 === 0) {
                                    flag5 = false;
                                }

                                if (
                                    k1 < 3 &&
                                    j1 - 1 >= 0 &&
                                    (!WordFilter.isSpecial(input[j1 - 1]) ||
                                        input[j1 - 1] === C_SINGLE_QUOTE)
                                ) {
                                    flag5 = false;
                                }

                                if (
                                    flag5 &&
                                    !WordFilter.containsFragmentHashes(ac2)
                                ) {
                                    flag4 = true;
                                }
                            }
                        }

                        if (!flag4) {
                            filter = false;
                        }
                    }
                }

                if (filter) {
                    if (WordFilter.DEBUGWORD) {
                        console.log(
                            `Filtered word: ${wordList} at char ${charIndex}`
                        );
                    }

                    for (let i1 = charIndex; i1 < inputCharCount; i1++) {
                        input[i1] = C_ASTERISK;
                    }
                }
            }
        }
    }

    static compareCharIds(charIdData, prevCharId, curCharId) {
        let first = 0;

        if (
            charIdData[first][0] === prevCharId &&
            charIdData[first][1] === curCharId
        ) {
            return true;
        }

        let last = charIdData.length - 1;

        if (
            charIdData[last][0] === prevCharId &&
            charIdData[last][1] === curCharId
        ) {
            return true;
        }

        while (first !== last && first + 1 !== last) {
            let middle = ((first + last) / 2) | 0;

            if (
                charIdData[middle][0] === prevCharId &&
                charIdData[middle][1] === curCharId
            ) {
                return true;
            }

            if (
                prevCharId < charIdData[middle][0] ||
                (prevCharId === charIdData[middle][0] &&
                    curCharId < charIdData[middle][1])
            ) {
                last = middle;
            } else {
                first = middle;
            }
        }

        return false;
    }

    static compareLettersNumbers(filterChar, currentChar, nextChar) {
        filterChar = String.fromCharCode(filterChar);
        currentChar = String.fromCharCode(currentChar);
        nextChar = String.fromCharCode(nextChar);

        if (filterChar === currentChar) {
            return 1;
        }

        if (filterChar === 'e' && currentChar === '3') {
            return 1;
        }

        if (
            filterChar === 't' &&
            (currentChar === '7' || currentChar === '+')
        ) {
            return 1;
        }

        if (
            filterChar === 'a' &&
            (currentChar === '4' || currentChar === '@')
        ) {
            return 1;
        }

        if (filterChar === 'o' && currentChar === '0') {
            return 1;
        }

        if (filterChar === 'i' && currentChar === '1') {
            return 1;
        }

        if (filterChar === 's' && currentChar === '5') {
            return 1;
        }

        if (filterChar === 'f' && currentChar === 'p' && nextChar === 'h') {
            return 2;
        }

        return filterChar === 'g' && currentChar === '9' ? 1 : 0;
    }

    static compareLettersSymbols(filterChar, currentChar, nextChar) {
        filterChar = String.fromCharCode(filterChar);
        currentChar = String.fromCharCode(currentChar);
        nextChar = String.fromCharCode(nextChar);

        if (filterChar === '*') {
            return 0;
        }

        if (filterChar === currentChar) {
            return 1;
        }

        if (filterChar >= 'a' && filterChar <= 'z') {
            if (filterChar === 'e') {
                return currentChar === '3' ? 1 : 0;
            }

            if (filterChar === 't') {
                return currentChar === '7' ? 1 : 0;
            }

            if (filterChar === 'a') {
                return currentChar === '4' || currentChar === '@' ? 1 : 0;
            }

            if (filterChar === 'o') {
                if (currentChar === '0' || currentChar === '*') {
                    return 1;
                }

                return currentChar === '(' && nextChar === ')' ? 2 : 0;
            }

            if (filterChar === 'i') {
                return currentChar === 'y' ||
                    currentChar === 'l' ||
                    currentChar === 'j' ||
                    currentChar === 'l' ||
                    currentChar === '!' ||
                    currentChar === ':' ||
                    currentChar === ';'
                    ? 1
                    : 0;
            }

            if (filterChar === 'n') {
                return 0;
            }

            if (filterChar === 's') {
                return currentChar === '5' ||
                    currentChar === 'z' ||
                    currentChar === '$'
                    ? 1
                    : 0;
            }

            if (filterChar === 'r') {
                return 0;
            }

            if (filterChar === 'h') {
                return 0;
            }

            if (filterChar === 'l') {
                return currentChar === '1' ? 1 : 0;
            }

            if (filterChar === 'd') {
                return 0;
            }

            if (filterChar === 'c') {
                return currentChar === '(' ? 1 : 0;
            }

            if (filterChar === 'u') {
                return currentChar === 'v' ? 1 : 0;
            }

            if (filterChar === 'm') {
                return 0;
            }

            if (filterChar === 'f') {
                return currentChar === 'p' && nextChar === 'h' ? 2 : 0;
            }

            if (filterChar === 'p') {
                return 0;
            }

            if (filterChar === 'g') {
                return currentChar === '9' || currentChar === '6' ? 1 : 0;
            }

            if (filterChar === 'w') {
                return currentChar === 'v' && nextChar === 'v' ? 2 : 0;
            }

            if (filterChar === 'y') {
                return 0;
            }

            if (filterChar === 'b') {
                return currentChar === '1' && nextChar === '3' ? 2 : 0;
            }

            if (filterChar === 'v') {
                return 0;
            }

            if (filterChar === 'k') {
                return 0;
            }

            if (filterChar === 'x') {
                return currentChar === ')' && nextChar === '(' ? 2 : 0;
            }

            if (filterChar === 'j') {
                return 0;
            }

            if (filterChar === 'q') {
                return 0;
            }

            if (filterChar === 'z') {
                return 0;
            }
        }

        if (filterChar >= '0' && filterChar <= '9') {
            if (filterChar === '0') {
                if (currentChar === 'o' || currentChar === 'O') {
                    return 1;
                }

                return currentChar === '(' && nextChar === ')' ? 2 : 0;
            }
            if (filterChar === '1') {
                return currentChar !== 'l' ? 0 : 1;
            }

            if (filterChar === '2') {
                return 0;
            }

            if (filterChar === '3') {
                return 0;
            }

            if (filterChar === '4') {
                return 0;
            }

            if (filterChar === '5') {
                return 0;
            }

            if (filterChar === '6') {
                return 0;
            }

            if (filterChar === '7') {
                return 0;
            }

            if (filterChar === '8') {
                return 0;
            }

            if (filterChar === '9') {
                return 0;
            }
        }

        if (filterChar === '-') {
            return 0;
        }

        if (filterChar === ',') {
            return currentChar === '.' ? 1 : 0;
        }

        if (filterChar === '.') {
            return currentChar === ',' ? 1 : 0;
        }

        if (filterChar === '(') {
            return 0;
        }

        if (filterChar === ')') {
            return 0;
        }

        if (filterChar === '!') {
            return currentChar === 'i' ? 1 : 0;
        }

        if (filterChar === "'") {
            return 0;
        }

        if (WordFilter.DEBUGWORD) {
            console.log(`Letter=${filterChar} not matched`);
        }

        return 0;
    }

    static getCharId(c) {
        if (c >= C_A && c <= C_Z) {
            return c - 97 + 1;
        }

        if (c === C_SINGLE_QUOTE) {
            return 28;
        }

        if (c >= C_0 && c <= C_9) {
            return c - 48 + 29;
        }

        return 27;
    }

    static heywhathteufck(input) {
        let digitIndex = 0;
        let fromIndex = 0;
        let k = 0;
        let l = 0;

        while ((digitIndex = WordFilter.indexOfDigit(input, fromIndex)) != -1) {
            let flag = false;

            for (let i = fromIndex; i >= 0 && i < digitIndex && !flag; i++) {
                if (
                    !WordFilter.isSpecial(input[i]) &&
                    !WordFilter.isNotLowerCase(input[i])
                ) {
                    flag = true;
                }
            }

            if (flag) {
                k = 0;
            }

            if (k === 0) {
                l = digitIndex;
            }

            fromIndex = WordFilter.indexOfNonDigit(input, digitIndex);

            let j1 = 0;

            for (let k1 = digitIndex; k1 < fromIndex; k1++) {
                j1 = j1 * 10 + input[k1] - 48;
            }

            if (j1 > 255 || fromIndex - digitIndex > 8) {
                k = 0;
            } else {
                k++;
            }

            if (k === 4) {
                for (let i = l; i < fromIndex; i++) {
                    input[i] = C_ASTERISK;
                }

                k = 0;
            }
        }
    }

    static indexOfDigit(input, fromIndex) {
        for (let i = fromIndex; i < input.length && i >= 0; i++) {
            if (input[i] >= C_0 && input[i] <= C_9) {
                return i;
            }
        }

        return -1;
    }

    static indexOfNonDigit(input, fromIndex) {
        for (let i = fromIndex; i < input.length && i >= 0; i++) {
            if (input[i] < C_0 || input[i] > C_9) {
                return i;
            }
        }

        return input.length;
    }

    static isSpecial(c) {
        return !WordFilter.isLetter(c) && !WordFilter.isDigit(c);
    }

    static isNotLowerCase(c) {
        if (c < C_A || c > C_Z) {
            return true;
        }

        return c === C_V || c === C_X || c === C_J || c === C_Q || c === C_Z;
    }

    static isLetter(c) {
        return (c >= C_A && c <= C_Z) || (c >= C_BIG_A && c <= C_BIG_Z);
    }

    static isDigit(c) {
        return c >= C_0 && c <= C_9;
    }

    static isLowerCase(c) {
        return c >= C_A && c <= C_Z;
    }

    static isUpperCase(c) {
        return c >= C_BIG_A && c <= C_BIG_Z;
    }

    static containsFragmentHashes(input) {
        let notNum = true;

        for (let i = 0; i < input.length; i++) {
            if (!WordFilter.isDigit(input[i]) && input[i] !== 0) {
                notNum = false;
            }
        }

        if (notNum) {
            return true;
        }

        let inputHash = WordFilter.wordToHash(input);
        let first = 0;
        let last = WordFilter.hashFragments.length - 1;

        if (
            inputHash === WordFilter.hashFragments[first] ||
            inputHash === WordFilter.hashFragments[last]
        ) {
            return true;
        }

        while (first != last && first + 1 != last) {
            let middle = ((first + last) / 2) | 0;

            if (inputHash === WordFilter.hashFragments[middle]) {
                return true;
            }

            if (inputHash < WordFilter.hashFragments[middle]) {
                last = middle;
            } else {
                first = middle;
            }
        }

        return false;
    }

    static wordToHash(word) {
        if (word.length > 6) {
            return 0;
        }

        let hash = 0;

        for (let i = 0; i < word.length; i++) {
            let c = word[word.length - i - 1];

            if (c >= C_A && c <= C_Z) {
                hash = (hash * 38 + c - 97 + 1) | 0;
            } else if (c === C_SINGLE_QUOTE) {
                hash = (hash * 38 + 27) | 0;
            } else if (c >= C_0 && c <= C_9) {
                hash = (hash * 38 + c - 48 + 28) | 0;
            } else if (c !== 0) {
                if (WordFilter.DEBUGWORD) {
                    console.log(`wordToHash failed on ${fromCharArray(word)}`);
                }

                return 0;
            }
        }

        return hash;
    }
}

WordFilter.DEBUGTLD = false;
WordFilter.DEBUGWORD = false;
WordFilter.forceLowerCase = true;
WordFilter.ignoreList = ['cook', "cook's", 'cooks', 'seeks', 'sheet'];

module.exports = WordFilter;


},{}],103:[function(require,module,exports){
const GameData = require('./game-data');
const Scene = require('./scene');
const GameModel = require('./game-model');
const Utility = require('./utility');
const ndarray = require('ndarray');

class World {
    constructor(scene, surface) {
        this.regionWidth = 96;
        this.regionHeight = 96;
        this.anInt585 = 128;
        this.parentModel = null;

        // Int8Arrays
        this.landscapePack = null;
        this.mapPack = null;
        this.memberLandscapePack = null;
        this.memberMapPack = null;

        this.worldInitialised = true;
        this.objectAdjacency = ndarray(
            new Int32Array(this.regionWidth * this.regionHeight),
            [this.regionWidth, this.regionHeight]
        );
        this.tileDirection = ndarray(new Int8Array(4 * 2304), [4, 2304]);

        this.wallModels = [];
        this.roofModels = [];

        for (let i = 0; i < 4; i += 1) {
            this.wallModels.push([]);
            this.roofModels.push([]);

            for (let j = 0; j < 64; j += 1) {
                this.wallModels[i].push(null);
                this.roofModels[i].push(null);
            }
        }

        this.terrainColours = new Int32Array(256);
        this.wallsNorthSouth = ndarray(new Int8Array(4 * 2304), [4, 2304]);
        this.wallsRoof = ndarray(new Int8Array(4 * 2304), [4, 2304]);
        this.terrainHeight = ndarray(new Int8Array(4 * 2304), [4, 2304]);
        this.terrainColour = ndarray(new Int8Array(4 * 2304), [4, 2304]);
        this.localY = new Int32Array(18432);
        this.tileDecoration = ndarray(new Int8Array(4 * 2304), [4, 2304]);
        this.routeVia = ndarray(
            new Int32Array(this.regionWidth * this.regionHeight),
            [this.regionWidth, this.regionHeight]
        );
        this.wallsDiagonal = ndarray(new Int32Array(4 * 2304), [4, 2304]);
        this.wallsEastWest = ndarray(new Int8Array(4 * 2304), [4, 2304]);
        this.aBoolean592 = false;
        this.playerAlive = false;
        this.terrainHeightLocal = ndarray(
            new Int32Array(this.regionWidth * this.regionHeight),
            [this.regionWidth, this.regionHeight]
        );

        this.terrainModels = [];
        this.terrainModels.length = 64;
        this.terrainModels.fill(null);

        this.localX = new Int32Array(18432);
        this.baseMediaSprite = 750;

        this.scene = scene;
        this.surface = surface;

        for (let i = 0; i < 64; i++) {
            this.terrainColours[i] = Scene.rgb(
                255 - i * 4,
                255 - ((i * 1.75) | 0),
                255 - i * 4
            );
        }

        for (let j = 0; j < 64; j++) {
            this.terrainColours[j + 64] = Scene.rgb(j * 3, 144, 0);
        }

        for (let k = 0; k < 64; k++) {
            this.terrainColours[k + 128] = Scene.rgb(
                192 - ((k * 1.5) | 0),
                144 - ((k * 1.5) | 0),
                0
            );
        }

        for (let l = 0; l < 64; l++) {
            this.terrainColours[l + 192] = Scene.rgb(
                96 - ((l * 1.5) | 0),
                48 + ((l * 1.5) | 0),
                0
            );
        }
    }

    getWallEastWest(x, y) {
        if (x < 0 || x >= this.regionWidth || y < 0 || y >= this.regionHeight) {
            return 0;
        }

        let h = 0;

        if (x >= 48 && y < 48) {
            h = 1;
            x -= 48;
        } else if (x < 48 && y >= 48) {
            h = 2;
            y -= 48;
        } else if (x >= 48 && y >= 48) {
            h = 3;
            x -= 48;
            y -= 48;
        }

        return this.wallsEastWest.get(h, x * 48 + y) & 0xff;
    }

    setTerrainAmbience(x, y, x2, y2, ambience) {
        let gameModel = this.terrainModels[x + y * 8];

        for (let j1 = 0; j1 < gameModel.numVertices; j1++) {
            if (
                gameModel.vertexX[j1] === x2 * this.anInt585 &&
                gameModel.vertexZ[j1] === y2 * this.anInt585
            ) {
                gameModel.setVertexAmbience(j1, ambience);
                return;
            }
        }
    }

    getWallRoof(x, y) {
        if (x < 0 || x >= this.regionWidth || y < 0 || y >= this.regionHeight) {
            return 0;
        }

        let h = 0;

        if (x >= 48 && y < 48) {
            h = 1;
            x -= 48;
        } else if (x < 48 && y >= 48) {
            h = 2;
            y -= 48;
        } else if (x >= 48 && y >= 48) {
            h = 3;
            x -= 48;
            y -= 48;
        }

        return this.wallsRoof.get(h, x * 48 + y);
    }

    getElevation(x, y) {
        let sX = x >> 7;
        let sY = y >> 7;
        let aX = x & 0x7f;
        let aY = y & 0x7f;

        if (sX < 0 || sY < 0 || sX >= 95 || sY >= 95) {
            return 0;
        }

        let h = 0;
        let hx = 0;
        let hy = 0;

        if (aX <= this.anInt585 - aY) {
            h = this.getTerrainHeight(sX, sY);
            hx = this.getTerrainHeight(sX + 1, sY) - h;
            hy = this.getTerrainHeight(sX, sY + 1) - h;
        } else {
            h = this.getTerrainHeight(sX + 1, sY + 1);
            hx = this.getTerrainHeight(sX, sY + 1) - h;
            hy = this.getTerrainHeight(sX + 1, sY) - h;
            aX = this.anInt585 - aX;
            aY = this.anInt585 - aY;
        }

        let elevation =
            h +
            (((hx * aX) / this.anInt585) | 0) +
            (((hy * aY) / this.anInt585) | 0);

        return elevation;
    }

    getWallDiagonal(x, y) {
        if (x < 0 || x >= this.regionWidth || y < 0 || y >= this.regionHeight) {
            return 0;
        }

        let h = 0;

        if (x >= 48 && y < 48) {
            h = 1;
            x -= 48;
        } else if (x < 48 && y >= 48) {
            h = 2;
            y -= 48;
        } else if (x >= 48 && y >= 48) {
            h = 3;
            x -= 48;
            y -= 48;
        }

        return this.wallsDiagonal.get(h, x * 48 + y);
    }

    removeObject2(x, y, id) {
        if (x < 0 || y < 0 || x >= 95 || y >= 95) {
            return;
        }

        if (GameData.objectType[id] === 1 || GameData.objectType[id] === 2) {
            let tileDir = this.getTileDirection(x, y);
            let modelWidth = 0;
            let modelHeight = 0;

            if (tileDir === 0 || tileDir === 4) {
                modelWidth = GameData.objectWidth[id];
                modelHeight = GameData.objectHeight[id];
            } else {
                modelHeight = GameData.objectWidth[id];
                modelWidth = GameData.objectHeight[id];
            }

            for (let mx = x; mx < x + modelWidth; mx++) {
                for (let my = y; my < y + modelHeight; my++) {
                    const adjacency = this.objectAdjacency.get(mx, my);

                    if (GameData.objectType[id] === 1) {
                        this.objectAdjacency.set(mx, my, adjacency | 0x40);
                    } else if (tileDir === 0) {
                        this.objectAdjacency.set(mx, my, adjacency | 2);

                        if (mx > 0) {
                            this._setObjectAdjacency_from3(mx - 1, my, 8);
                        }
                    } else if (tileDir === 2) {
                        this.objectAdjacency.set(mx, my, adjacency | 4);

                        if (my < 95) {
                            this._setObjectAdjacency_from3(mx, my + 1, 1);
                        }
                    } else if (tileDir === 4) {
                        this.objectAdjacency.set(mx, my, adjacency | 8);

                        if (mx < 95) {
                            this._setObjectAdjacency_from3(mx + 1, my, 2);
                        }
                    } else if (tileDir === 6) {
                        this.objectAdjacency.set(mx, my, adjacency | 1);

                        if (my > 0) {
                            this._setObjectAdjacency_from3(mx, my - 1, 4);
                        }
                    }
                }
            }

            this.method404(x, y, modelWidth, modelHeight);
        }
    }

    removeWallObject(x, y, k, id) {
        if (x < 0 || y < 0 || x >= 95 || y >= 95) {
            return;
        }

        if (GameData.wallObjectAdjacent[id] === 1) {
            const adjacency = this.objectAdjacency.get(x, y);

            if (k === 0) {
                this.objectAdjacency.set(x, y, adjacency & 0xfffe);

                if (y > 0) {
                    this.method407(x, y - 1, 4);
                }
            } else if (k === 1) {
                this.objectAdjacency.set(x, y, adjacency & 0xfffd);

                if (x > 0) {
                    this.method407(x - 1, y, 8);
                }
            } else if (k === 2) {
                this.objectAdjacency.set(x, y, adjacency & 0xffef);
            } else if (k === 3) {
                this.objectAdjacency.set(x, y, adjacency & 0xffdf);
            }

            this.method404(x, y, 1, 1);
        }
    }

    method402(i, j, k, l, i1) {
        let j1 = i * 3;
        let k1 = j * 3;
        let l1 = this.scene.method302(l);
        let i2 = this.scene.method302(i1);
        l1 = (l1 >> 1) & 0x7f7f7f;
        i2 = (i2 >> 1) & 0x7f7f7f;

        if (k === 0) {
            this.surface.drawLineHoriz(j1, k1, 3, l1);
            this.surface.drawLineHoriz(j1, k1 + 1, 2, l1);
            this.surface.drawLineHoriz(j1, k1 + 2, 1, l1);
            this.surface.drawLineHoriz(j1 + 2, k1 + 1, 1, i2);
            this.surface.drawLineHoriz(j1 + 1, k1 + 2, 2, i2);

            return;
        }

        if (k === 1) {
            this.surface.drawLineHoriz(j1, k1, 3, i2);
            this.surface.drawLineHoriz(j1 + 1, k1 + 1, 2, i2);
            this.surface.drawLineHoriz(j1 + 2, k1 + 2, 1, i2);
            this.surface.drawLineHoriz(j1, k1 + 1, 1, l1);
            this.surface.drawLineHoriz(j1, k1 + 2, 2, l1);
        }
    }

    _loadSection_from4I(x, y, plane, chunk) {
        let mapName =
            'm' + plane + ((x / 10) | 0) + (x % 10) + ((y / 10) | 0) + (y % 10);

        try {
            if (this.landscapePack !== null) {
                let mapData = Utility.loadData(
                    mapName + '.hei',
                    0,
                    this.landscapePack
                );

                if (mapData === null && this.memberLandscapePack !== null) {
                    mapData = Utility.loadData(
                        mapName + '.hei',
                        0,
                        this.memberLandscapePack
                    );
                }

                if (mapData !== null && mapData.length > 0) {
                    let off = 0;
                    let lastVal = 0;

                    for (let tile = 0; tile < 2304; ) {
                        let val = mapData[off++] & 0xff;

                        if (val < 128) {
                            this.terrainHeight.set(chunk, tile++, val & 0xff);
                            lastVal = val;
                        }

                        if (val >= 128) {
                            for (let i = 0; i < val - 128; i++) {
                                this.terrainHeight.set(
                                    chunk,
                                    tile++,
                                    lastVal & 0xff
                                );
                            }
                        }
                    }

                    lastVal = 64;

                    for (let tileY = 0; tileY < 48; tileY++) {
                        for (let tileX = 0; tileX < 48; tileX++) {
                            lastVal =
                                (this.terrainHeight.get(
                                    chunk,
                                    tileX * 48 + tileY
                                ) +
                                    lastVal) &
                                0x7f;
                            this.terrainHeight.set(
                                chunk,
                                tileX * 48 + tileY,
                                (lastVal * 2) & 0xff
                            );
                        }
                    }

                    lastVal = 0;

                    for (let tile = 0; tile < 2304; ) {
                        let val = mapData[off++] & 0xff;

                        if (val < 128) {
                            this.terrainColour.set(chunk, tile++, val & 0xff);
                            lastVal = val;
                        }

                        if (val >= 128) {
                            for (let i = 0; i < val - 128; i++) {
                                this.terrainColour.set(
                                    chunk,
                                    tile++,
                                    lastVal & 0xff
                                );
                            }
                        }
                    }

                    lastVal = 35;

                    for (let tileY = 0; tileY < 48; tileY++) {
                        for (let tileX = 0; tileX < 48; tileX++) {
                            lastVal =
                                (this.terrainColour.get(
                                    chunk,
                                    tileX * 48 + tileY
                                ) +
                                    lastVal) &
                                0x7f; // ??? wat
                            this.terrainColour.set(
                                chunk,
                                tileX * 48 + tileY,
                                (lastVal * 2) & 0xff
                            );
                        }
                    }
                } else {
                    for (let tile = 0; tile < 2304; tile++) {
                        this.terrainHeight.set(chunk, tile, 0);
                        this.terrainColour.set(chunk, tile, 0);
                    }
                }

                mapData = Utility.loadData(mapName + '.dat', 0, this.mapPack);

                if (mapData === null && this.memberMapPack !== null) {
                    mapData = Utility.loadData(
                        mapName + '.dat',
                        0,
                        this.memberMapPack
                    );
                }

                if (mapData === null || mapData.length === 0) {
                    throw new Error();
                }

                let off = 0;

                for (let tile = 0; tile < 2304; tile++) {
                    this.wallsNorthSouth.set(chunk, tile, mapData[off++]);
                }

                for (let tile = 0; tile < 2304; tile++) {
                    this.wallsEastWest.set(chunk, tile, mapData[off++]);
                }

                for (let tile = 0; tile < 2304; tile++) {
                    this.wallsDiagonal.set(chunk, tile, mapData[off++] & 0xff);
                }

                for (let tile = 0; tile < 2304; tile++) {
                    let val = mapData[off++] & 0xff;

                    if (val > 0) {
                        this.wallsDiagonal.set(chunk, tile, val + 12000);
                    }
                }

                for (let tile = 0; tile < 2304; ) {
                    let val = mapData[off++] & 0xff;

                    if (val < 128) {
                        this.wallsRoof.set(chunk, tile++, val & 0xff);
                    } else {
                        for (let i = 0; i < val - 128; i++) {
                            this.wallsRoof.set(chunk, tile++, 0);
                        }
                    }
                }

                let lastVal = 0;

                for (let tile = 0; tile < 2304; ) {
                    let val = mapData[off++] & 0xff;

                    if (val < 128) {
                        this.tileDecoration.set(chunk, tile++, val & 0xff);
                        lastVal = val;
                    } else {
                        for (let i = 0; i < val - 128; i++) {
                            this.tileDecoration.set(chunk, tile++, lastVal);
                        }
                    }
                }

                for (let tile = 0; tile < 2304; ) {
                    let val = mapData[off++] & 0xff;

                    if (val < 128) {
                        this.tileDirection.set(chunk, tile++, val & 0xff);
                    } else {
                        for (let i = 0; i < val - 128; i++) {
                            this.tileDirection.set(chunk, tile++, 0);
                        }
                    }
                }

                mapData = Utility.loadData(mapName + '.loc', 0, this.mapPack);

                if (mapData !== null && mapData.length > 0) {
                    off = 0;

                    for (let tile = 0; tile < 2304; ) {
                        let val = mapData[off++] & 0xff;

                        if (val < 128) {
                            this.wallsDiagonal.set(chunk, tile++, val + 48000);
                        } else {
                            tile += val - 128;
                        }
                    }

                    return;
                }
            } else {
                console.log('stub. removed reading from ../gamedata/');
            }

            return;
        } catch (e) {
            console.error(e);
        }

        for (let tile = 0; tile < 2304; tile++) {
            this.terrainHeight.set(chunk, tile, 0);
            this.terrainColour.set(chunk, tile, 0);
            this.wallsNorthSouth.set(chunk, tile, 0);
            this.wallsEastWest.set(chunk, tile, 0);
            this.wallsDiagonal.set(chunk, tile, 0);
            this.wallsRoof.set(chunk, tile, 0);
            this.tileDecoration.set(chunk, tile, 0);

            if (plane === 0) {
                this.tileDecoration.set(chunk, tile, -6);
            }

            if (plane === 3) {
                this.tileDecoration.set(chunk, tile, 8);
            }

            this.tileDirection.set(chunk, tile, 0);
        }
    }

    loadSection(...args) {
        switch (args.length) {
            case 3:
                return this._loadSection_from3(...args);
            case 4:
                if (typeof args[3] === 'number') {
                    return this._loadSection_from4I(...args);
                }

                return this._loadSection_from4(...args);
        }
    }

    method404(x, y, k, l) {
        if (
            x < 1 ||
            y < 1 ||
            x + k >= this.regionWidth ||
            y + l >= this.regionHeight
        ) {
            return;
        }

        for (let xx = x; xx <= x + k; xx++) {
            for (let yy = y; yy <= y + l; yy++) {
                if (
                    (this.getObjectAdjacency(xx, yy) & 0x63) !== 0 ||
                    (this.getObjectAdjacency(xx - 1, yy) & 0x59) !== 0 ||
                    (this.getObjectAdjacency(xx, yy - 1) & 0x56) !== 0 ||
                    (this.getObjectAdjacency(xx - 1, yy - 1) & 0x6c) !== 0
                ) {
                    this.method425(xx, yy, 35);
                } else {
                    this.method425(xx, yy, 0);
                }
            }
        }
    }

    getObjectAdjacency(x, y) {
        if (x < 0 || y < 0 || x >= this.regionWidth || y >= this.regionHeight) {
            return 0;
        } else {
            return this.objectAdjacency.get(x, y);
        }
    }

    hasRoof(x, y) {
        return (
            this.getWallRoof(x, y) > 0 &&
            this.getWallRoof(x - 1, y) > 0 &&
            this.getWallRoof(x - 1, y - 1) > 0 &&
            this.getWallRoof(x, y - 1) > 0
        );
    }

    method407(i, j, k) {
        const adjacency = this.objectAdjacency.get(i, j);
        this.objectAdjacency.set(i, j, adjacency & (0xffff - k));
    }

    getTerrainColour(x, y) {
        if (x < 0 || x >= this.regionWidth || y < 0 || y >= this.regionHeight) {
            return 0;
        }

        let byte0 = 0;

        if (x >= 48 && y < 48) {
            byte0 = 1;
            x -= 48;
        } else if (x < 48 && y >= 48) {
            byte0 = 2;
            y -= 48;
        } else if (x >= 48 && y >= 48) {
            byte0 = 3;
            x -= 48;
            y -= 48;
        }

        return this.terrainColour.get(byte0, x * 48 + y) & 0xff;
    }

    reset() {
        if (this.worldInitialised) {
            this.scene.dispose();
        }

        for (let i = 0; i < 64; i++) {
            this.terrainModels[i] = null;

            for (let j = 0; j < 4; j++) {
                this.wallModels[j][i] = null;
            }

            for (let k = 0; k < 4; k++) {
                this.roofModels[k][i] = null;
            }
        }
    }

    setTiles() {
        for (let x = 0; x < this.regionWidth; x++) {
            for (let y = 0; y < this.regionHeight; y++) {
                if (this.getTileDecoration(x, y, 0) === 250) {
                    if (
                        x === 47 &&
                        this.getTileDecoration(x + 1, y, 0) !== 250 &&
                        this.getTileDecoration(x + 1, y, 0) !== 2
                    ) {
                        this.setTileDecoration(x, y, 9);
                    } else if (
                        y === 47 &&
                        this.getTileDecoration(x, y + 1, 0) !== 250 &&
                        this.getTileDecoration(x, y + 1, 0) !== 2
                    ) {
                        this.setTileDecoration(x, y, 9);
                    } else {
                        this.setTileDecoration(x, y, 2);
                    }
                }
            }
        }
    }

    getWallNorthSouth(x, y) {
        if (x < 0 || x >= this.regionWidth || y < 0 || y >= this.regionHeight) {
            return 0;
        }

        let h = 0;

        if (x >= 48 && y < 48) {
            h = 1;
            x -= 48;
        } else if (x < 48 && y >= 48) {
            h = 2;
            y -= 48;
        } else if (x >= 48 && y >= 48) {
            h = 3;
            x -= 48;
            y -= 48;
        }

        return this.wallsNorthSouth.get(h, x * 48 + y) & 0xff;
    }

    getTileDirection(x, y) {
        if (x < 0 || x >= this.regionWidth || y < 0 || y >= this.regionHeight) {
            return 0;
        }

        let h = 0;

        if (x >= 48 && y < 48) {
            h = 1;
            x -= 48;
        } else if (x < 48 && y >= 48) {
            h = 2;
            y -= 48;
        } else if (x >= 48 && y >= 48) {
            h = 3;
            x -= 48;
            y -= 48;
        }

        return this.tileDirection.get(h, x * 48 + y);
    }

    _getTileDecoration_from4(x, y, unused, def) {
        const decoration = this._getTileDecoration_from3(x, y);

        if (decoration === 0) {
            return def;
        } else {
            return GameData.tileDecoration[decoration - 1];
        }
    }

    _getTileDecoration_from3(x, y) {
        if (x < 0 || x >= this.regionWidth || y < 0 || y >= this.regionHeight) {
            return 0;
        }

        let h = 0;

        if (x >= 48 && y < 48) {
            h = 1;
            x -= 48;
        } else if (x < 48 && y >= 48) {
            h = 2;
            y -= 48;
        } else if (x >= 48 && y >= 48) {
            h = 3;
            x -= 48;
            y -= 48;
        }

        return this.tileDecoration.get(h, x * 48 + y) & 0xff;
    }

    getTileDecoration(...args) {
        switch (args.length) {
            case 3:
                return this._getTileDecoration_from3(...args);
            case 4:
                return this._getTileDecoration_from4(...args);
        }
    }

    setTileDecoration(x, y, v) {
        if (x < 0 || x >= this.regionWidth || y < 0 || y >= this.regionHeight) {
            return;
        }

        let h = 0;

        if (x >= 48 && y < 48) {
            h = 1;
            x -= 48;
        } else if (x < 48 && y >= 48) {
            h = 2;
            y -= 48;
        } else if (x >= 48 && y >= 48) {
            h = 3;
            x -= 48;
            y -= 48;
        }

        this.tileDecoration.set(h, x * 48 + y, v & 0xff);
    }

    route(startX, startY, endX1, endY1, endX2, endY2, routeX, routeY, objects) {
        for (let x = 0; x < this.regionWidth; x++) {
            for (let y = 0; y < this.regionHeight; y++) {
                this.routeVia.set(x, y, 0);
            }
        }

        let writePtr = 0;
        let readPtr = 0;
        let x = startX;
        let y = startY;

        this.routeVia.set(startX, startY, 99);
        routeX[writePtr] = startX;
        routeY[writePtr++] = startY;

        let size = routeX.length;
        let reached = false;

        while (readPtr !== writePtr) {
            x = routeX[readPtr];
            y = routeY[readPtr];
            readPtr = (readPtr + 1) % size;

            if (x >= endX1 && x <= endX2 && y >= endY1 && y <= endY2) {
                reached = true;
                break;
            }

            if (objects) {
                if (
                    x > 0 &&
                    x - 1 >= endX1 &&
                    x - 1 <= endX2 &&
                    y >= endY1 &&
                    y <= endY2 &&
                    (this.objectAdjacency.get(x - 1, y) & 8) === 0
                ) {
                    reached = true;
                    break;
                }

                if (
                    x < 95 &&
                    x + 1 >= endX1 &&
                    x + 1 <= endX2 &&
                    y >= endY1 &&
                    y <= endY2 &&
                    (this.objectAdjacency.get(x + 1, y) & 2) === 0
                ) {
                    reached = true;
                    break;
                }

                if (
                    y > 0 &&
                    x >= endX1 &&
                    x <= endX2 &&
                    y - 1 >= endY1 &&
                    y - 1 <= endY2 &&
                    (this.objectAdjacency.get(x, y - 1) & 4) === 0
                ) {
                    reached = true;
                    break;
                }

                if (
                    y < 95 &&
                    x >= endX1 &&
                    x <= endX2 &&
                    y + 1 >= endY1 &&
                    y + 1 <= endY2 &&
                    (this.objectAdjacency.get(x, y + 1) & 1) === 0
                ) {
                    reached = true;
                    break;
                }
            }

            if (
                x > 0 &&
                this.routeVia.get(x - 1, y) === 0 &&
                (this.objectAdjacency.get(x - 1, y) & 0x78) === 0
            ) {
                routeX[writePtr] = x - 1;
                routeY[writePtr] = y;
                writePtr = (writePtr + 1) % size;
                this.routeVia.set(x - 1, y, 2);
            }

            if (
                x < 95 &&
                this.routeVia.get(x + 1, y) === 0 &&
                (this.objectAdjacency.get(x + 1, y) & 0x72) === 0
            ) {
                routeX[writePtr] = x + 1;
                routeY[writePtr] = y;
                writePtr = (writePtr + 1) % size;
                this.routeVia.set(x + 1, y, 8);
            }

            if (
                y > 0 &&
                this.routeVia.get(x, y - 1) === 0 &&
                (this.objectAdjacency.get(x, y - 1) & 0x74) === 0
            ) {
                routeX[writePtr] = x;
                routeY[writePtr] = y - 1;
                writePtr = (writePtr + 1) % size;
                this.routeVia.set(x, y - 1, 1);
            }

            if (
                y < 95 &&
                this.routeVia.get(x, y + 1) === 0 &&
                (this.objectAdjacency.get(x, y + 1) & 0x71) === 0
            ) {
                routeX[writePtr] = x;
                routeY[writePtr] = y + 1;
                writePtr = (writePtr + 1) % size;
                this.routeVia.set(x, y + 1, 4);
            }

            if (
                x > 0 &&
                y > 0 &&
                (this.objectAdjacency.get(x, y - 1) & 0x74) === 0 &&
                (this.objectAdjacency.get(x - 1, y) & 0x78) === 0 &&
                (this.objectAdjacency.get(x - 1, y - 1) & 0x7c) === 0 &&
                this.routeVia.get(x - 1, y - 1) === 0
            ) {
                routeX[writePtr] = x - 1;
                routeY[writePtr] = y - 1;
                writePtr = (writePtr + 1) % size;
                this.routeVia.set(x - 1, y - 1, 3);
            }

            if (
                x < 95 &&
                y > 0 &&
                (this.objectAdjacency.get(x, y - 1) & 0x74) === 0 &&
                (this.objectAdjacency.get(x + 1, y) & 0x72) === 0 &&
                (this.objectAdjacency.get(x + 1, y - 1) & 0x76) === 0 &&
                this.routeVia.get(x + 1, y - 1) === 0
            ) {
                routeX[writePtr] = x + 1;
                routeY[writePtr] = y - 1;
                writePtr = (writePtr + 1) % size;
                this.routeVia.set(x + 1, y - 1, 9);
            }

            if (
                x > 0 &&
                y < 95 &&
                (this.objectAdjacency.get(x, y + 1) & 0x71) === 0 &&
                (this.objectAdjacency.get(x - 1, y) & 0x78) === 0 &&
                (this.objectAdjacency.get(x - 1, y + 1) & 0x79) === 0 &&
                this.routeVia.get(x - 1, y + 1) === 0
            ) {
                routeX[writePtr] = x - 1;
                routeY[writePtr] = y + 1;
                writePtr = (writePtr + 1) % size;
                this.routeVia.set(x - 1, y + 1, 6);
            }

            if (
                x < 95 &&
                y < 95 &&
                (this.objectAdjacency.get(x, y + 1) & 0x71) === 0 &&
                (this.objectAdjacency.get(x + 1, y) & 0x72) === 0 &&
                (this.objectAdjacency.get(x + 1, y + 1) & 0x73) === 0 &&
                this.routeVia.get(x + 1, y + 1) === 0
            ) {
                routeX[writePtr] = x + 1;
                routeY[writePtr] = y + 1;
                writePtr = (writePtr + 1) % size;
                this.routeVia.set(x + 1, y + 1, 12);
            }
        }

        if (!reached) {
            return -1;
        }

        readPtr = 0;
        routeX[readPtr] = x;
        routeY[readPtr++] = y;

        let stride;

        for (
            let step = (stride = this.routeVia.get(x, y));
            x !== startX || y !== startY;
            step = this.routeVia.get(x, y)
        ) {
            if (step !== stride) {
                stride = step;
                routeX[readPtr] = x;
                routeY[readPtr++] = y;
            }

            if ((step & 2) !== 0) {
                x++;
            } else if ((step & 8) !== 0) {
                x--;
            }

            if ((step & 1) !== 0) {
                y++;
            } else if ((step & 4) !== 0) {
                y--;
            }
        }

        return readPtr;
    }

    _setObjectAdjacency_from4(x, y, dir, id) {
        if (x < 0 || y < 0 || x >= 95 || y >= 95) {
            return;
        }

        if (GameData.wallObjectAdjacent[id] === 1) {
            const adjacency = this.objectAdjacency.get(x, y);

            if (dir === 0) {
                this.objectAdjacency.set(x, y, adjacency | 1);

                if (y > 0) {
                    this._setObjectAdjacency_from3(x, y - 1, 4);
                }
            } else if (dir === 1) {
                this.objectAdjacency.set(x, y, adjacency | 2);

                if (x > 0) {
                    this._setObjectAdjacency_from3(x - 1, y, 8);
                }
            } else if (dir === 2) {
                this.objectAdjacency.set(x, y, adjacency | 0x10);
            } else if (dir === 3) {
                this.objectAdjacency.set(x, y, adjacency | 0x20);
            }

            this.method404(x, y, 1, 1);
        }
    }

    setObjectAdjacency(...args) {
        switch (args.length) {
            case 4:
                return this._setObjectAdjacency_from4(...args);
            case 3:
                return this._setObjectAdjacency_from3(...args);
        }
    }

    _loadSection_from4(x, y, plane, flag) {
        let l = ((x + 24) / 48) | 0;
        let i1 = ((y + 24) / 48) | 0;

        this._loadSection_from4I(l - 1, i1 - 1, plane, 0);
        this._loadSection_from4I(l, i1 - 1, plane, 1);
        this._loadSection_from4I(l - 1, i1, plane, 2);
        this._loadSection_from4I(l, i1, plane, 3);
        this.setTiles();

        if (this.parentModel === null) {
            this.parentModel = GameModel._from7(
                18688,
                18688,
                true,
                true,
                false,
                false,
                true
            );
        }

        if (flag) {
            this.surface.blackScreen();

            for (let j1 = 0; j1 < this.regionWidth; j1++) {
                for (let l1 = 0; l1 < this.regionHeight; l1++) {
                    this.objectAdjacency.set(j1, l1, 0);
                }
            }

            let gameModel = this.parentModel;
            gameModel.clear();

            for (let j2 = 0; j2 < this.regionWidth; j2++) {
                for (let i3 = 0; i3 < this.regionHeight; i3++) {
                    let i4 = -this.getTerrainHeight(j2, i3);

                    if (
                        this.getTileDecoration(j2, i3, plane) > 0 &&
                        GameData.tileType[
                            this.getTileDecoration(j2, i3, plane) - 1
                        ] === 4
                    ) {
                        i4 = 0;
                    }

                    if (
                        this.getTileDecoration(j2 - 1, i3, plane) > 0 &&
                        GameData.tileType[
                            this.getTileDecoration(j2 - 1, i3, plane) - 1
                        ] === 4
                    ) {
                        i4 = 0;
                    }

                    if (
                        this.getTileDecoration(j2, i3 - 1, plane) > 0 &&
                        GameData.tileType[
                            this.getTileDecoration(j2, i3 - 1, plane) - 1
                        ] === 4
                    ) {
                        i4 = 0;
                    }

                    if (
                        this.getTileDecoration(j2 - 1, i3 - 1, plane) > 0 &&
                        GameData.tileType[
                            this.getTileDecoration(j2 - 1, i3 - 1, plane) - 1
                        ] === 4
                    ) {
                        i4 = 0;
                    }

                    let j5 = gameModel.vertexAt(
                        j2 * this.anInt585,
                        i4,
                        i3 * this.anInt585
                    );
                    let j7 = ((Math.random() * 10) | 0) - 5;

                    gameModel.setVertexAmbience(j5, j7);
                }
            }

            for (let lx = 0; lx < 95; lx++) {
                for (let ly = 0; ly < 95; ly++) {
                    let colourIndex = this.getTerrainColour(lx, ly);
                    let colour = this.terrainColours[colourIndex];
                    let colour_1 = colour;
                    let colour_2 = colour;
                    let l14 = 0;

                    if (plane === 1 || plane === 2) {
                        colour = World.colourTransparent;
                        colour_1 = World.colourTransparent;
                        colour_2 = World.colourTransparent;
                    }

                    if (this.getTileDecoration(lx, ly, plane) > 0) {
                        let decorationType = this.getTileDecoration(
                            lx,
                            ly,
                            plane
                        );
                        let decorationTileType =
                            GameData.tileType[decorationType - 1];
                        let tileType = this.getTileType(lx, ly, plane);

                        colour = colour_1 =
                            GameData.tileDecoration[decorationType - 1];

                        if (decorationTileType === 4) {
                            colour = 1;
                            colour_1 = 1;

                            if (decorationType === 12) {
                                colour = 31;
                                colour_1 = 31;
                            }
                        }

                        if (decorationTileType === 5) {
                            if (
                                this.getWallDiagonal(lx, ly) > 0 &&
                                this.getWallDiagonal(lx, ly) < 24000
                            ) {
                                if (
                                    this.getTileDecoration(
                                        lx - 1,
                                        ly,
                                        plane,
                                        colour_2
                                    ) !== World.colourTransparent &&
                                    this.getTileDecoration(
                                        lx,
                                        ly - 1,
                                        plane,
                                        colour_2
                                    ) !== World.colourTransparent
                                ) {
                                    colour = this.getTileDecoration(
                                        lx - 1,
                                        ly,
                                        plane,
                                        colour_2
                                    );
                                    l14 = 0;
                                } else if (
                                    this.getTileDecoration(
                                        lx + 1,
                                        ly,
                                        plane,
                                        colour_2
                                    ) !== World.colourTransparent &&
                                    this.getTileDecoration(
                                        lx,
                                        ly + 1,
                                        plane,
                                        colour_2
                                    ) !== World.colourTransparent
                                ) {
                                    colour_1 = this.getTileDecoration(
                                        lx + 1,
                                        ly,
                                        plane,
                                        colour_2
                                    );
                                    l14 = 0;
                                } else if (
                                    this.getTileDecoration(
                                        lx + 1,
                                        ly,
                                        plane,
                                        colour_2
                                    ) !== World.colourTransparent &&
                                    this.getTileDecoration(
                                        lx,
                                        ly - 1,
                                        plane,
                                        colour_2
                                    ) !== World.colourTransparent
                                ) {
                                    colour_1 = this.getTileDecoration(
                                        lx + 1,
                                        ly,
                                        plane,
                                        colour_2
                                    );
                                    l14 = 1;
                                } else if (
                                    this.getTileDecoration(
                                        lx - 1,
                                        ly,
                                        plane,
                                        colour_2
                                    ) !== World.colourTransparent &&
                                    this.getTileDecoration(
                                        lx,
                                        ly + 1,
                                        plane,
                                        colour_2
                                    ) !== World.colourTransparent
                                ) {
                                    colour = this.getTileDecoration(
                                        lx - 1,
                                        ly,
                                        plane,
                                        colour_2
                                    );
                                    l14 = 1;
                                }
                            }
                        } else if (
                            decorationTileType !== 2 ||
                            (this.getWallDiagonal(lx, ly) > 0 &&
                                this.getWallDiagonal(lx, ly) < 24000)
                        ) {
                            if (
                                this.getTileType(lx - 1, ly, plane) !==
                                    tileType &&
                                this.getTileType(lx, ly - 1, plane) !== tileType
                            ) {
                                colour = colour_2;
                                l14 = 0;
                            } else if (
                                this.getTileType(lx + 1, ly, plane) !==
                                    tileType &&
                                this.getTileType(lx, ly + 1, plane) !== tileType
                            ) {
                                colour_1 = colour_2;
                                l14 = 0;
                            } else if (
                                this.getTileType(lx + 1, ly, plane) !==
                                    tileType &&
                                this.getTileType(lx, ly - 1, plane) !== tileType
                            ) {
                                colour_1 = colour_2;
                                l14 = 1;
                            } else if (
                                this.getTileType(lx - 1, ly, plane) !==
                                    tileType &&
                                this.getTileType(lx, ly + 1, plane) !== tileType
                            ) {
                                colour = colour_2;
                                l14 = 1;
                            }
                        }

                        if (GameData.tileAdjacent[decorationType - 1] !== 0) {
                            const adjacency = this.objectAdjacency.get(lx, ly);
                            this.objectAdjacency.set(lx, ly, adjacency | 0x40);
                        }

                        if (GameData.tileType[decorationType - 1] === 2) {
                            const adjacency = this.objectAdjacency.get(lx, ly);
                            this.objectAdjacency.set(lx, ly, adjacency | 0x80);
                        }
                    }

                    this.method402(lx, ly, l14, colour, colour_1);

                    let i17 =
                        this.getTerrainHeight(lx + 1, ly + 1) -
                        this.getTerrainHeight(lx + 1, ly) +
                        this.getTerrainHeight(lx, ly + 1) -
                        this.getTerrainHeight(lx, ly);

                    if (colour !== colour_1 || i17 !== 0) {
                        let ai = new Int32Array(3);
                        let ai7 = new Int32Array(3);

                        if (l14 === 0) {
                            if (colour !== World.colourTransparent) {
                                ai[0] = ly + lx * 96 + 96;
                                ai[1] = ly + lx * 96;
                                ai[2] = ly + lx * 96 + 1;

                                let l21 = gameModel.createFace(
                                    3,
                                    ai,
                                    World.colourTransparent,
                                    colour
                                );

                                this.localX[l21] = lx;
                                this.localY[l21] = ly;

                                gameModel.faceTag[l21] = 0x30d40 + l21;
                            }

                            if (colour_1 !== World.colourTransparent) {
                                ai7[0] = ly + lx * 96 + 1;
                                ai7[1] = ly + lx * 96 + 96 + 1;
                                ai7[2] = ly + lx * 96 + 96;

                                let i22 = gameModel.createFace(
                                    3,
                                    ai7,
                                    World.colourTransparent,
                                    colour_1
                                );

                                this.localX[i22] = lx;
                                this.localY[i22] = ly;

                                gameModel.faceTag[i22] = 0x30d40 + i22;
                            }
                        } else {
                            if (colour !== World.colourTransparent) {
                                ai[0] = ly + lx * 96 + 1;
                                ai[1] = ly + lx * 96 + 96 + 1;
                                ai[2] = ly + lx * 96;

                                let j22 = gameModel.createFace(
                                    3,
                                    ai,
                                    World.colourTransparent,
                                    colour
                                );

                                this.localX[j22] = lx;
                                this.localY[j22] = ly;

                                gameModel.faceTag[j22] = 0x30d40 + j22;
                            }

                            if (colour_1 !== World.colourTransparent) {
                                ai7[0] = ly + lx * 96 + 96;
                                ai7[1] = ly + lx * 96;
                                ai7[2] = ly + lx * 96 + 96 + 1;

                                let k22 = gameModel.createFace(
                                    3,
                                    ai7,
                                    World.colourTransparent,
                                    colour_1
                                );

                                this.localX[k22] = lx;
                                this.localY[k22] = ly;

                                gameModel.faceTag[k22] = 0x30d40 + k22;
                            }
                        }
                    } else if (colour !== World.colourTransparent) {
                        let ai1 = new Int32Array(4);
                        ai1[0] = ly + lx * 96 + 96;
                        ai1[1] = ly + lx * 96;
                        ai1[2] = ly + lx * 96 + 1;
                        ai1[3] = ly + lx * 96 + 96 + 1;

                        let l19 = gameModel.createFace(
                            4,
                            ai1,
                            World.colourTransparent,
                            colour
                        );

                        this.localX[l19] = lx;
                        this.localY[l19] = ly;

                        gameModel.faceTag[l19] = 0x30d40 + l19;
                    }
                }
            }

            for (let k4 = 1; k4 < 95; k4++) {
                for (let i6 = 1; i6 < 95; i6++) {
                    if (
                        this.getTileDecoration(k4, i6, plane) > 0 &&
                        GameData.tileType[
                            this.getTileDecoration(k4, i6, plane) - 1
                        ] === 4
                    ) {
                        let l7 =
                            GameData.tileDecoration[
                                this.getTileDecoration(k4, i6, plane) - 1
                            ];
                        let j10 = gameModel.vertexAt(
                            k4 * this.anInt585,
                            -this.getTerrainHeight(k4, i6),
                            i6 * this.anInt585
                        );
                        let l12 = gameModel.vertexAt(
                            (k4 + 1) * this.anInt585,
                            -this.getTerrainHeight(k4 + 1, i6),
                            i6 * this.anInt585
                        );
                        let i15 = gameModel.vertexAt(
                            (k4 + 1) * this.anInt585,
                            -this.getTerrainHeight(k4 + 1, i6 + 1),
                            (i6 + 1) * this.anInt585
                        );
                        let j17 = gameModel.vertexAt(
                            k4 * this.anInt585,
                            -this.getTerrainHeight(k4, i6 + 1),
                            (i6 + 1) * this.anInt585
                        );
                        let ai2 = new Int32Array([j10, l12, i15, j17]);
                        let i20 = gameModel.createFace(
                            4,
                            ai2,
                            l7,
                            World.colourTransparent
                        );
                        this.localX[i20] = k4;
                        this.localY[i20] = i6;
                        gameModel.faceTag[i20] = 0x30d40 + i20;
                        this.method402(k4, i6, 0, l7, l7);
                    } else if (
                        this.getTileDecoration(k4, i6, plane) === 0 ||
                        GameData.tileType[
                            this.getTileDecoration(k4, i6, plane) - 1
                        ] !== 3
                    ) {
                        if (
                            this.getTileDecoration(k4, i6 + 1, plane) > 0 &&
                            GameData.tileType[
                                this.getTileDecoration(k4, i6 + 1, plane) - 1
                            ] === 4
                        ) {
                            let i8 =
                                GameData.tileDecoration[
                                    this.getTileDecoration(k4, i6 + 1, plane) -
                                        1
                                ];
                            let k10 = gameModel.vertexAt(
                                k4 * this.anInt585,
                                -this.getTerrainHeight(k4, i6),
                                i6 * this.anInt585
                            );
                            let i13 = gameModel.vertexAt(
                                (k4 + 1) * this.anInt585,
                                -this.getTerrainHeight(k4 + 1, i6),
                                i6 * this.anInt585
                            );
                            let j15 = gameModel.vertexAt(
                                (k4 + 1) * this.anInt585,
                                -this.getTerrainHeight(k4 + 1, i6 + 1),
                                (i6 + 1) * this.anInt585
                            );
                            let k17 = gameModel.vertexAt(
                                k4 * this.anInt585,
                                -this.getTerrainHeight(k4, i6 + 1),
                                (i6 + 1) * this.anInt585
                            );
                            let ai3 = new Int32Array([k10, i13, j15, k17]);
                            let j20 = gameModel.createFace(
                                4,
                                ai3,
                                i8,
                                World.colourTransparent
                            );
                            this.localX[j20] = k4;
                            this.localY[j20] = i6;
                            gameModel.faceTag[j20] = 0x30d40 + j20;
                            this.method402(k4, i6, 0, i8, i8);
                        }

                        if (
                            this.getTileDecoration(k4, i6 - 1, plane) > 0 &&
                            GameData.tileType[
                                this.getTileDecoration(k4, i6 - 1, plane) - 1
                            ] === 4
                        ) {
                            let j8 =
                                GameData.tileDecoration[
                                    this.getTileDecoration(k4, i6 - 1, plane) -
                                        1
                                ];
                            let l10 = gameModel.vertexAt(
                                k4 * this.anInt585,
                                -this.getTerrainHeight(k4, i6),
                                i6 * this.anInt585
                            );
                            let j13 = gameModel.vertexAt(
                                (k4 + 1) * this.anInt585,
                                -this.getTerrainHeight(k4 + 1, i6),
                                i6 * this.anInt585
                            );
                            let k15 = gameModel.vertexAt(
                                (k4 + 1) * this.anInt585,
                                -this.getTerrainHeight(k4 + 1, i6 + 1),
                                (i6 + 1) * this.anInt585
                            );
                            let l17 = gameModel.vertexAt(
                                k4 * this.anInt585,
                                -this.getTerrainHeight(k4, i6 + 1),
                                (i6 + 1) * this.anInt585
                            );
                            let ai4 = new Int32Array([l10, j13, k15, l17]);
                            let k20 = gameModel.createFace(
                                4,
                                ai4,
                                j8,
                                World.colourTransparent
                            );
                            this.localX[k20] = k4;
                            this.localY[k20] = i6;
                            gameModel.faceTag[k20] = 0x30d40 + k20;
                            this.method402(k4, i6, 0, j8, j8);
                        }

                        if (
                            this.getTileDecoration(k4 + 1, i6, plane) > 0 &&
                            GameData.tileType[
                                this.getTileDecoration(k4 + 1, i6, plane) - 1
                            ] === 4
                        ) {
                            let k8 =
                                GameData.tileDecoration[
                                    this.getTileDecoration(k4 + 1, i6, plane) -
                                        1
                                ];
                            let i11 = gameModel.vertexAt(
                                k4 * this.anInt585,
                                -this.getTerrainHeight(k4, i6),
                                i6 * this.anInt585
                            );
                            let k13 = gameModel.vertexAt(
                                (k4 + 1) * this.anInt585,
                                -this.getTerrainHeight(k4 + 1, i6),
                                i6 * this.anInt585
                            );
                            let l15 = gameModel.vertexAt(
                                (k4 + 1) * this.anInt585,
                                -this.getTerrainHeight(k4 + 1, i6 + 1),
                                (i6 + 1) * this.anInt585
                            );
                            let i18 = gameModel.vertexAt(
                                k4 * this.anInt585,
                                -this.getTerrainHeight(k4, i6 + 1),
                                (i6 + 1) * this.anInt585
                            );
                            let ai5 = new Int32Array([i11, k13, l15, i18]);
                            let l20 = gameModel.createFace(
                                4,
                                ai5,
                                k8,
                                World.colourTransparent
                            );
                            this.localX[l20] = k4;
                            this.localY[l20] = i6;
                            gameModel.faceTag[l20] = 0x30d40 + l20;
                            this.method402(k4, i6, 0, k8, k8);
                        }

                        if (
                            this.getTileDecoration(k4 - 1, i6, plane) > 0 &&
                            GameData.tileType[
                                this.getTileDecoration(k4 - 1, i6, plane) - 1
                            ] === 4
                        ) {
                            let l8 =
                                GameData.tileDecoration[
                                    this.getTileDecoration(k4 - 1, i6, plane) -
                                        1
                                ];
                            let j11 = gameModel.vertexAt(
                                k4 * this.anInt585,
                                -this.getTerrainHeight(k4, i6),
                                i6 * this.anInt585
                            );
                            let l13 = gameModel.vertexAt(
                                (k4 + 1) * this.anInt585,
                                -this.getTerrainHeight(k4 + 1, i6),
                                i6 * this.anInt585
                            );
                            let i16 = gameModel.vertexAt(
                                (k4 + 1) * this.anInt585,
                                -this.getTerrainHeight(k4 + 1, i6 + 1),
                                (i6 + 1) * this.anInt585
                            );
                            let j18 = gameModel.vertexAt(
                                k4 * this.anInt585,
                                -this.getTerrainHeight(k4, i6 + 1),
                                (i6 + 1) * this.anInt585
                            );
                            let ai6 = new Int32Array([j11, l13, i16, j18]);
                            let i21 = gameModel.createFace(
                                4,
                                ai6,
                                l8,
                                World.colourTransparent
                            );
                            this.localX[i21] = k4;
                            this.localY[i21] = i6;
                            gameModel.faceTag[i21] = 0x30d40 + i21;
                            this.method402(k4, i6, 0, l8, l8);
                        }
                    }
                }
            }

            gameModel._setLight_from6(true, 40, 48, -50, -10, -50);
            this.terrainModels = this.parentModel.split(
                0,
                0,
                1536,
                1536,
                8,
                64,
                233,
                false
            );

            for (let j6 = 0; j6 < 64; j6++) {
                this.scene.addModel(this.terrainModels[j6]);
            }

            for (let X = 0; X < this.regionWidth; X++) {
                for (let Y = 0; Y < this.regionHeight; Y++) {
                    this.terrainHeightLocal.set(
                        X,
                        Y,
                        this.getTerrainHeight(X, Y)
                    );
                }
            }
        }

        this.parentModel.clear();
        let k1 = 0x606060;

        for (let i2 = 0; i2 < 95; i2++) {
            for (let k2 = 0; k2 < 95; k2++) {
                let k3 = this.getWallEastWest(i2, k2);

                if (
                    k3 > 0 &&
                    (GameData.wallObjectInvisible[k3 - 1] === 0 ||
                        this.aBoolean592)
                ) {
                    this.method422(
                        this.parentModel,
                        k3 - 1,
                        i2,
                        k2,
                        i2 + 1,
                        k2
                    );

                    if (flag && GameData.wallObjectAdjacent[k3 - 1] !== 0) {
                        const adjacency = this.objectAdjacency.get(i2, k2);
                        this.objectAdjacency.set(i2, k2, adjacency | 1);

                        if (k2 > 0) {
                            this._setObjectAdjacency_from3(i2, k2 - 1, 4);
                        }
                    }

                    if (flag) {
                        this.surface.drawLineHoriz(i2 * 3, k2 * 3, 3, k1);
                    }
                }

                k3 = this.getWallNorthSouth(i2, k2);

                if (
                    k3 > 0 &&
                    (GameData.wallObjectInvisible[k3 - 1] === 0 ||
                        this.aBoolean592)
                ) {
                    this.method422(
                        this.parentModel,
                        k3 - 1,
                        i2,
                        k2,
                        i2,
                        k2 + 1
                    );

                    if (flag && GameData.wallObjectAdjacent[k3 - 1] !== 0) {
                        const adjacency = this.objectAdjacency.get(i2, k2);
                        this.objectAdjacency.set(i2, k2, adjacency | 2);

                        if (i2 > 0) {
                            this._setObjectAdjacency_from3(i2 - 1, k2, 8);
                        }
                    }

                    if (flag) {
                        this.surface.drawLineVert(i2 * 3, k2 * 3, 3, k1);
                    }
                }

                k3 = this.getWallDiagonal(i2, k2);

                if (
                    k3 > 0 &&
                    k3 < 12000 &&
                    (GameData.wallObjectInvisible[k3 - 1] === 0 ||
                        this.aBoolean592)
                ) {
                    this.method422(
                        this.parentModel,
                        k3 - 1,
                        i2,
                        k2,
                        i2 + 1,
                        k2 + 1
                    );

                    if (flag && GameData.wallObjectAdjacent[k3 - 1] !== 0) {
                        const adjacency = this.objectAdjacency.get(i2, k2);
                        this.objectAdjacency.set(i2, k2, adjacency | 0x20);
                    }

                    if (flag) {
                        this.surface.setPixel(i2 * 3, k2 * 3, k1);
                        this.surface.setPixel(i2 * 3 + 1, k2 * 3 + 1, k1);
                        this.surface.setPixel(i2 * 3 + 2, k2 * 3 + 2, k1);
                    }
                }

                if (
                    k3 > 12000 &&
                    k3 < 24000 &&
                    (GameData.wallObjectInvisible[k3 - 12001] === 0 ||
                        this.aBoolean592)
                ) {
                    this.method422(
                        this.parentModel,
                        k3 - 12001,
                        i2 + 1,
                        k2,
                        i2,
                        k2 + 1
                    );

                    if (flag && GameData.wallObjectAdjacent[k3 - 12001] !== 0) {
                        const adjacency = this.objectAdjacency.get(i2, k2);
                        this.objectAdjacency.set(i2, k2, adjacency | 0x10);
                    }

                    if (flag) {
                        this.surface.setPixel(i2 * 3 + 2, k2 * 3, k1);
                        this.surface.setPixel(i2 * 3 + 1, k2 * 3 + 1, k1);
                        this.surface.setPixel(i2 * 3, k2 * 3 + 2, k1);
                    }
                }
            }
        }

        if (flag) {
            this.surface.drawSpriteMinimap(
                this.baseMediaSprite - 1,
                0,
                0,
                285,
                285
            );
        }

        this.parentModel._setLight_from6(false, 60, 24, -50, -10, -50);

        this.wallModels[plane] = this.parentModel.split(
            0,
            0,
            1536,
            1536,
            8,
            64,
            338,
            true
        );

        for (let l2 = 0; l2 < 64; l2++) {
            this.scene.addModel(this.wallModels[plane][l2]);
        }

        for (let l3 = 0; l3 < 95; l3++) {
            for (let l4 = 0; l4 < 95; l4++) {
                let k6 = this.getWallEastWest(l3, l4);

                if (k6 > 0) {
                    this.method428(k6 - 1, l3, l4, l3 + 1, l4);
                }

                k6 = this.getWallNorthSouth(l3, l4);

                if (k6 > 0) {
                    this.method428(k6 - 1, l3, l4, l3, l4 + 1);
                }

                k6 = this.getWallDiagonal(l3, l4);

                if (k6 > 0 && k6 < 12000) {
                    this.method428(k6 - 1, l3, l4, l3 + 1, l4 + 1);
                }

                if (k6 > 12000 && k6 < 24000) {
                    this.method428(k6 - 12001, l3 + 1, l4, l3, l4 + 1);
                }
            }
        }

        for (let i5 = 1; i5 < 95; i5++) {
            for (let l6 = 1; l6 < 95; l6++) {
                let j9 = this.getWallRoof(i5, l6);

                if (j9 > 0) {
                    let l11 = i5;
                    let i14 = l6;
                    let j16 = i5 + 1;
                    let k18 = l6;
                    let j19 = i5 + 1;
                    let j21 = l6 + 1;
                    let l22 = i5;
                    let j23 = l6 + 1;
                    let l23 = 0;
                    let j24 = this.terrainHeightLocal.get(l11, i14);
                    let l24 = this.terrainHeightLocal.get(j16, k18);
                    let j25 = this.terrainHeightLocal.get(j19, j21);
                    let l25 = this.terrainHeightLocal.get(l22, j23);

                    if (j24 > 0x13880) {
                        j24 -= 0x13880;
                    }

                    if (l24 > 0x13880) {
                        l24 -= 0x13880;
                    }

                    if (j25 > 0x13880) {
                        j25 -= 0x13880;
                    }

                    if (l25 > 0x13880) {
                        l25 -= 0x13880;
                    }

                    if (j24 > l23) {
                        l23 = j24;
                    }

                    if (l24 > l23) {
                        l23 = l24;
                    }

                    if (j25 > l23) {
                        l23 = j25;
                    }

                    if (l25 > l23) {
                        l23 = l25;
                    }

                    if (l23 >= 0x13880) {
                        l23 -= 0x13880;
                    }

                    if (j24 < 0x13880) {
                        this.terrainHeightLocal.set(l11, i14, l23);
                    } else {
                        const height = this.terrainHeightLocal.get(l11, i14);
                        this.terrainHeightLocal.set(l11, i14, height - 0x13880);
                    }

                    if (l24 < 0x13880) {
                        this.terrainHeightLocal.set(j16, k18, l23);
                    } else {
                        const height = this.terrainHeightLocal.get(j16, k18);
                        this.terrainHeightLocal.set(j16, k18, height - 0x13880);
                    }

                    if (j25 < 0x13880) {
                        this.terrainHeightLocal.set(j19, j21, l23);
                    } else {
                        const height = this.terrainHeightLocal.get(j19, j21);
                        this.terrainHeightLocal.set(j19, j21, height - 0x13880);
                    }

                    if (l25 < 0x13880) {
                        this.terrainHeightLocal.set(l22, j23, l23);
                    } else {
                        const height = this.terrainHeightLocal.get(l22, j23);
                        this.terrainHeightLocal.set(l22, j23, height - 0x13880);
                    }
                }
            }
        }

        this.parentModel.clear();

        for (let i7 = 1; i7 < 95; i7++) {
            for (let k9 = 1; k9 < 95; k9++) {
                let roofNvs = this.getWallRoof(i7, k9);

                if (roofNvs > 0) {
                    let j14 = i7;
                    let k16 = k9;
                    let l18 = i7 + 1;
                    let k19 = k9;
                    let k21 = i7 + 1;
                    let i23 = k9 + 1;
                    let k23 = i7;
                    let i24 = k9 + 1;
                    let k24 = i7 * this.anInt585;
                    let i25 = k9 * this.anInt585;
                    let k25 = k24 + this.anInt585;
                    let i26 = i25 + this.anInt585;
                    let j26 = k24;
                    let k26 = i25;
                    let l26 = k25;
                    let i27 = i26;
                    let j27 = this.terrainHeightLocal.get(j14, k16);
                    let k27 = this.terrainHeightLocal.get(l18, k19);
                    let l27 = this.terrainHeightLocal.get(k21, i23);
                    let i28 = this.terrainHeightLocal.get(k23, i24);
                    let unknown = GameData.roofHeight[roofNvs - 1];

                    if (this.hasRoof(j14, k16) && j27 < 0x13880) {
                        j27 += unknown + 0x13880;
                        this.terrainHeightLocal.set(j14, k16, j27);
                    }

                    if (this.hasRoof(l18, k19) && k27 < 0x13880) {
                        k27 += unknown + 0x13880;
                        this.terrainHeightLocal.set(l18, k19, k27);
                    }

                    if (this.hasRoof(k21, i23) && l27 < 0x13880) {
                        l27 += unknown + 0x13880;
                        this.terrainHeightLocal.set(k21, i23, l27);
                    }

                    if (this.hasRoof(k23, i24) && i28 < 0x13880) {
                        i28 += unknown + 0x13880;
                        this.terrainHeightLocal.set(k23, i24, i28);
                    }

                    if (j27 >= 0x13880) {
                        j27 -= 0x13880;
                    }

                    if (k27 >= 0x13880) {
                        k27 -= 0x13880;
                    }

                    if (l27 >= 0x13880) {
                        l27 -= 0x13880;
                    }

                    if (i28 >= 0x13880) {
                        i28 -= 0x13880;
                    }

                    let byte0 = 16;

                    if (!this.method427(j14 - 1, k16)) {
                        k24 -= byte0;
                    }

                    if (!this.method427(j14 + 1, k16)) {
                        k24 += byte0;
                    }

                    if (!this.method427(j14, k16 - 1)) {
                        i25 -= byte0;
                    }

                    if (!this.method427(j14, k16 + 1)) {
                        i25 += byte0;
                    }

                    if (!this.method427(l18 - 1, k19)) {
                        k25 -= byte0;
                    }

                    if (!this.method427(l18 + 1, k19)) {
                        k25 += byte0;
                    }

                    if (!this.method427(l18, k19 - 1)) {
                        k26 -= byte0;
                    }

                    if (!this.method427(l18, k19 + 1)) {
                        k26 += byte0;
                    }

                    if (!this.method427(k21 - 1, i23)) {
                        l26 -= byte0;
                    }

                    if (!this.method427(k21 + 1, i23)) {
                        l26 += byte0;
                    }

                    if (!this.method427(k21, i23 - 1)) {
                        i26 -= byte0;
                    }

                    if (!this.method427(k21, i23 + 1)) {
                        i26 += byte0;
                    }

                    if (!this.method427(k23 - 1, i24)) {
                        j26 -= byte0;
                    }

                    if (!this.method427(k23 + 1, i24)) {
                        j26 += byte0;
                    }

                    if (!this.method427(k23, i24 - 1)) {
                        i27 -= byte0;
                    }

                    if (!this.method427(k23, i24 + 1)) {
                        i27 += byte0;
                    }

                    roofNvs = GameData.roofNumVertices[roofNvs - 1];
                    j27 = -j27;
                    k27 = -k27;
                    l27 = -l27;
                    i28 = -i28;

                    if (
                        this.getWallDiagonal(i7, k9) > 12000 &&
                        this.getWallDiagonal(i7, k9) < 24000 &&
                        this.getWallRoof(i7 - 1, k9 - 1) === 0
                    ) {
                        let ai8 = new Int32Array(3);
                        ai8[0] = this.parentModel.vertexAt(l26, l27, i26);
                        ai8[1] = this.parentModel.vertexAt(j26, i28, i27);
                        ai8[2] = this.parentModel.vertexAt(k25, k27, k26);

                        this.parentModel.createFace(
                            3,
                            ai8,
                            roofNvs,
                            World.colourTransparent
                        );
                    } else if (
                        this.getWallDiagonal(i7, k9) > 12000 &&
                        this.getWallDiagonal(i7, k9) < 24000 &&
                        this.getWallRoof(i7 + 1, k9 + 1) === 0
                    ) {
                        let ai9 = new Int32Array(3);
                        ai9[0] = this.parentModel.vertexAt(k24, j27, i25);
                        ai9[1] = this.parentModel.vertexAt(k25, k27, k26);
                        ai9[2] = this.parentModel.vertexAt(j26, i28, i27);

                        this.parentModel.createFace(
                            3,
                            ai9,
                            roofNvs,
                            World.colourTransparent
                        );
                    } else if (
                        this.getWallDiagonal(i7, k9) > 0 &&
                        this.getWallDiagonal(i7, k9) < 12000 &&
                        this.getWallRoof(i7 + 1, k9 - 1) === 0
                    ) {
                        let ai10 = new Int32Array(3);
                        ai10[0] = this.parentModel.vertexAt(j26, i28, i27);
                        ai10[1] = this.parentModel.vertexAt(k24, j27, i25);
                        ai10[2] = this.parentModel.vertexAt(l26, l27, i26);

                        this.parentModel.createFace(
                            3,
                            ai10,
                            roofNvs,
                            World.colourTransparent
                        );
                    } else if (
                        this.getWallDiagonal(i7, k9) > 0 &&
                        this.getWallDiagonal(i7, k9) < 12000 &&
                        this.getWallRoof(i7 - 1, k9 + 1) === 0
                    ) {
                        let ai11 = new Int32Array(3);
                        ai11[0] = this.parentModel.vertexAt(k25, k27, k26);
                        ai11[1] = this.parentModel.vertexAt(l26, l27, i26);
                        ai11[2] = this.parentModel.vertexAt(k24, j27, i25);

                        this.parentModel.createFace(
                            3,
                            ai11,
                            roofNvs,
                            World.colourTransparent
                        );
                    } else if (j27 === k27 && l27 === i28) {
                        let ai12 = new Int32Array(4);
                        ai12[0] = this.parentModel.vertexAt(k24, j27, i25);
                        ai12[1] = this.parentModel.vertexAt(k25, k27, k26);
                        ai12[2] = this.parentModel.vertexAt(l26, l27, i26);
                        ai12[3] = this.parentModel.vertexAt(j26, i28, i27);

                        this.parentModel.createFace(
                            4,
                            ai12,
                            roofNvs,
                            World.colourTransparent
                        );
                    } else if (j27 === i28 && k27 === l27) {
                        let ai13 = new Int32Array(4);
                        ai13[0] = this.parentModel.vertexAt(j26, i28, i27);
                        ai13[1] = this.parentModel.vertexAt(k24, j27, i25);
                        ai13[2] = this.parentModel.vertexAt(k25, k27, k26);
                        ai13[3] = this.parentModel.vertexAt(l26, l27, i26);

                        this.parentModel.createFace(
                            4,
                            ai13,
                            roofNvs,
                            World.colourTransparent
                        );
                    } else {
                        let flag1 = true;

                        if (this.getWallRoof(i7 - 1, k9 - 1) > 0) {
                            flag1 = false;
                        }

                        if (this.getWallRoof(i7 + 1, k9 + 1) > 0) {
                            flag1 = false;
                        }

                        if (!flag1) {
                            let ai14 = new Int32Array(3);
                            ai14[0] = this.parentModel.vertexAt(k25, k27, k26);
                            ai14[1] = this.parentModel.vertexAt(l26, l27, i26);
                            ai14[2] = this.parentModel.vertexAt(k24, j27, i25);

                            this.parentModel.createFace(
                                3,
                                ai14,
                                roofNvs,
                                World.colourTransparent
                            );

                            let ai16 = new Int32Array(3);
                            ai16[0] = this.parentModel.vertexAt(j26, i28, i27);
                            ai16[1] = this.parentModel.vertexAt(k24, j27, i25);
                            ai16[2] = this.parentModel.vertexAt(l26, l27, i26);

                            this.parentModel.createFace(
                                3,
                                ai16,
                                roofNvs,
                                World.colourTransparent
                            );
                        } else {
                            let ai15 = new Int32Array(3);
                            ai15[0] = this.parentModel.vertexAt(k24, j27, i25);
                            ai15[1] = this.parentModel.vertexAt(k25, k27, k26);
                            ai15[2] = this.parentModel.vertexAt(j26, i28, i27);

                            this.parentModel.createFace(
                                3,
                                ai15,
                                roofNvs,
                                World.colourTransparent
                            );

                            let ai17 = new Int32Array(3);
                            ai17[0] = this.parentModel.vertexAt(l26, l27, i26);
                            ai17[1] = this.parentModel.vertexAt(j26, i28, i27);
                            ai17[2] = this.parentModel.vertexAt(k25, k27, k26);

                            this.parentModel.createFace(
                                3,
                                ai17,
                                roofNvs,
                                World.colourTransparent
                            );
                        }
                    }
                }
            }
        }

        this.parentModel._setLight_from6(true, 50, 50, -50, -10, -50);
        this.roofModels[plane] = this.parentModel.split(
            0,
            0,
            1536,
            1536,
            8,
            64,
            169,
            true
        );

        for (let l9 = 0; l9 < 64; l9++) {
            this.scene.addModel(this.roofModels[plane][l9]);
        }

        if (this.roofModels[plane][0] === null) {
            throw new EvalError('null roof!');
        }

        for (let j12 = 0; j12 < this.regionWidth; j12++) {
            for (let k14 = 0; k14 < this.regionHeight; k14++) {
                if (this.terrainHeightLocal.get(j12, k14) >= 0x13880) {
                    const height = this.terrainHeightLocal.get(j12, k14);
                    this.terrainHeightLocal.set(j12, k14, height - 0x13880);
                }
            }
        }
    }

    _setObjectAdjacency_from3(i, j, k) {
        const adjacency = this.objectAdjacency.get(i, j);
        this.objectAdjacency.set(i, j, adjacency | k);
    }

    getTileType(i, j, k) {
        let l = this.getTileDecoration(i, j, k);

        if (l === 0) {
            return -1;
        }

        let i1 = GameData.tileType[l - 1];

        return i1 !== 2 ? 0 : 1;
    }

    addModels(models) {
        for (let i = 0; i < 94; i++) {
            for (let j = 0; j < 94; j++) {
                if (
                    this.getWallDiagonal(i, j) > 48000 &&
                    this.getWallDiagonal(i, j) < 60000
                ) {
                    let k = this.getWallDiagonal(i, j) - 48001;
                    let l = this.getTileDirection(i, j);
                    let i1 = 0;
                    let j1 = 0;

                    if (l === 0 || l === 4) {
                        i1 = GameData.objectWidth[k];
                        j1 = GameData.objectHeight[k];
                    } else {
                        j1 = GameData.objectWidth[k];
                        i1 = GameData.objectHeight[k];
                    }

                    this.removeObject2(i, j, k);

                    let gameModel = models[GameData.objectModelIndex[k]].copy(
                        false,
                        true,
                        false,
                        false
                    );
                    let k1 = (((i + i + i1) * this.anInt585) / 2) | 0;
                    let i2 = (((j + j + j1) * this.anInt585) / 2) | 0;
                    gameModel.translate(k1, -this.getElevation(k1, i2), i2);
                    gameModel.orient(0, this.getTileDirection(i, j) * 32, 0);
                    this.scene.addModel(gameModel);
                    gameModel._setLight_from5(48, 48, -50, -10, -50);

                    if (i1 > 1 || j1 > 1) {
                        for (let k2 = i; k2 < i + i1; k2++) {
                            for (let l2 = j; l2 < j + j1; l2++) {
                                if (
                                    (k2 > i || l2 > j) &&
                                    this.getWallDiagonal(k2, l2) - 48001 === k
                                ) {
                                    let l1 = k2;
                                    let j2 = l2;
                                    let byte0 = 0;

                                    if (l1 >= 48 && j2 < 48) {
                                        byte0 = 1;
                                        l1 -= 48;
                                    } else if (l1 < 48 && j2 >= 48) {
                                        byte0 = 2;
                                        j2 -= 48;
                                    } else if (l1 >= 48 && j2 >= 48) {
                                        byte0 = 3;
                                        l1 -= 48;
                                        j2 -= 48;
                                    }

                                    this.wallsDiagonal.set(
                                        byte0,
                                        l1 * 48 + j2,
                                        0
                                    );
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    method422(gameModel, i, j, k, l, i1) {
        this.method425(j, k, 40);
        this.method425(l, i1, 40);

        let h = GameData.wallObjectHeight[i];
        let front = GameData.wallObjectTextureFront[i];
        let back = GameData.wallObjectTextureBack[i];
        let i2 = j * this.anInt585;
        let j2 = k * this.anInt585;
        let k2 = l * this.anInt585;
        let l2 = i1 * this.anInt585;
        let i3 = gameModel.vertexAt(i2, -this.terrainHeightLocal.get(j, k), j2);
        let j3 = gameModel.vertexAt(
            i2,
            -this.terrainHeightLocal.get(j, k) - h,
            j2
        );
        let k3 = gameModel.vertexAt(
            k2,
            -this.terrainHeightLocal.get(l, i1) - h,
            l2
        );
        let l3 = gameModel.vertexAt(
            k2,
            -this.terrainHeightLocal.get(l, i1),
            l2
        );
        let ai = new Int32Array([i3, j3, k3, l3]);
        let i4 = gameModel.createFace(4, ai, front, back);

        if (GameData.wallObjectInvisible[i] === 5) {
            gameModel.faceTag[i4] = 30000 + i;
            return;
        } else {
            gameModel.faceTag[i4] = 0;
            return;
        }
    }

    getTerrainHeight(x, y) {
        if (x < 0 || x >= this.regionWidth || y < 0 || y >= this.regionHeight) {
            return 0;
        }

        let d = 0;

        if (x >= 48 && y < 48) {
            d = 1;
            x -= 48;
        } else if (x < 48 && y >= 48) {
            d = 2;
            y -= 48;
        } else if (x >= 48 && y >= 48) {
            d = 3;
            x -= 48;
            y -= 48;
        }

        return (this.terrainHeight.get(d, x * 48 + y) & 0xff) * 3;
    }

    _loadSection_from3(x, y, plane) {
        this.reset();

        let l = ((x + 24) / 48) | 0;
        let i1 = ((y + 24) / 48) | 0;

        this._loadSection_from4(x, y, plane, true);

        if (plane === 0) {
            this._loadSection_from4(x, y, 1, false);
            this._loadSection_from4(x, y, 2, false);
            this._loadSection_from4I(l - 1, i1 - 1, plane, 0);
            this._loadSection_from4I(l, i1 - 1, plane, 1);
            this._loadSection_from4I(l - 1, i1, plane, 2);
            this._loadSection_from4I(l, i1, plane, 3);
            this.setTiles();
        }
    }

    method425(i, j, k) {
        let l = (i / 12) | 0;
        let i1 = (j / 12) | 0;
        let j1 = ((i - 1) / 12) | 0;
        let k1 = ((j - 1) / 12) | 0;

        this.setTerrainAmbience(l, i1, i, j, k);

        if (l !== j1) {
            this.setTerrainAmbience(j1, i1, i, j, k);
        }

        if (i1 !== k1) {
            this.setTerrainAmbience(l, k1, i, j, k);
        }

        if (l !== j1 && i1 !== k1) {
            this.setTerrainAmbience(j1, k1, i, j, k);
        }
    }

    removeObject(x, y, id) {
        if (x < 0 || y < 0 || x >= 95 || y >= 95) {
            return;
        }

        if (GameData.objectType[id] === 1 || GameData.objectType[id] === 2) {
            let l = this.getTileDirection(x, y);
            let i1 = 0;
            let j1 = 0;

            if (l === 0 || l === 4) {
                i1 = GameData.objectWidth[id];
                j1 = GameData.objectHeight[id];
            } else {
                j1 = GameData.objectWidth[id];
                i1 = GameData.objectHeight[id];
            }

            for (let k1 = x; k1 < x + i1; k1++) {
                for (let l1 = y; l1 < y + j1; l1++) {
                    const adjacency = this.objectAdjacency.get(k1, l1);

                    if (GameData.objectType[id] === 1) {
                        this.objectAdjacency.set(k1, l1, adjacency & 0xffbf);
                    } else if (l === 0) {
                        this.objectAdjacency.set(k1, l1, adjacency & 0xfffd);

                        if (k1 > 0) {
                            this.method407(k1 - 1, l1, 8);
                        }
                    } else if (l === 2) {
                        this.objectAdjacency.set(k1, l1, adjacency & 0xfffb);

                        if (l1 < 95) {
                            this.method407(k1, l1 + 1, 1);
                        }
                    } else if (l === 4) {
                        this.objectAdjacency.set(k1, l1, adjacency & 0xfff7);

                        if (k1 < 95) {
                            this.method407(k1 + 1, l1, 2);
                        }
                    } else if (l === 6) {
                        this.objectAdjacency.set(k1, l1, adjacency & 0xfffe);

                        if (l1 > 0) {
                            this.method407(k1, l1 - 1, 4);
                        }
                    }
                }
            }

            this.method404(x, y, i1, j1);
        }
    }

    method427(i, j) {
        return (
            this.getWallRoof(i, j) > 0 ||
            this.getWallRoof(i - 1, j) > 0 ||
            this.getWallRoof(i - 1, j - 1) > 0 ||
            this.getWallRoof(i, j - 1) > 0
        );
    }

    method428(i, j, k, l, i1) {
        let j1 = GameData.wallObjectHeight[i];

        const height = this.terrainHeightLocal.get(j, k);

        if (height < 0x13880) {
            this.terrainHeightLocal.set(j, k, height + 0x13880 + j1);
        }

        const height2 = this.terrainHeightLocal.get(l, i1);

        if (height2 < 0x13880) {
            this.terrainHeightLocal.set(l, i1, height2 + 0x13880 + j1);
        }
    }
}

World.colourTransparent = 12345678;

module.exports = World;

},{"./game-data":44,"./game-model":45,"./scene":72,"./utility":100,"ndarray":34}]},{},[1]);
